'use strict';

var _ = require('lodash');
var loggingUtils = require('./logger');
var logger = loggingUtils.getLogger('/Destination service');
var xsenv = require('@sap/xsenv');
var request = require('request');
var tokenUtils = require ('./token-utils');

exports.adjustDestinationProperties = adjustDestinationProperties;
exports.normalizeDestinationProperties = normalizeDestinationProperties;
exports.getDestinationServiceCredentials = getDestinationServiceCredentials;
exports.findDestination = findDestination;
exports.getDestinationsByTenant = getDestinationsByTenant;
exports.getDestinationsByDestinationKey = getDestinationsByDestinationKey;
exports.getServiceInstanceDestinationsByTenant = getServiceInstanceDestinationsByTenant;

function getServiceInstanceDestinationsByTenant(req,cb){
  let getDestinationPromises = [];
  let serviceInstanceDestinations = [];
  let tenant = req.tenant;
  getDestinationInstanceCredentialsByTenant(req,function(err,tenantDestinations){
    if (err){
      return cb(err);
    }
    if (!tenantDestinations || tenantDestinations.length === 0){
      return cb(null,serviceInstanceDestinations);
    }
    tenantDestinations.forEach((tenantDestination) => {
      getDestinationPromises.push(
        new Promise((resolve,reject) => {
          let destinationKey = tenant + '_' + tenantDestination.Name;
          getDestinationsByDestinationKey(req.app, destinationKey, function(err,destinations){
            if (err){
              reject(err);
            } else {
              resolve(destinations);
            }
          });
        })
      );
    });
    Promise.all(getDestinationPromises)
      .then(values => {
        values.forEach(function(instanceDestinations){
          serviceInstanceDestinations = serviceInstanceDestinations.concat(instanceDestinations);
        });
        cb(null,serviceInstanceDestinations);
      }).catch(reason => {
        cb(reason);
      });
  });
}

function getDestinationInstanceCredentialsByTenant(req, cb){
  let token = req.app && req.app.services['destination'] && req.app.services['destination'].token;
  let tenantDestinations = [];
  getDestinationsByTenant(null,token,function(err,destinations) {
    if (err){
      return cb(err);
    }
    destinations.forEach((destination) => {
      if (destination.identityzone === req.tenant && destination.Name === destination.instanceid){
        tenantDestinations.push(destination);
      }
    });
    cb(null,tenantDestinations);
  });
}

function getDestinationsByDestinationKey(app,destinationKey, cb){
  let destinationToken = app.services && app.services[destinationKey] && app.services[destinationKey].token;
  if (!destinationToken || destinationToken.tokenRefreshTimestamp - Date.now() <= 0 || !app.services[destinationKey].credentials) {
    // eslint-disable-next-line no-unused-vars
    const [tenant,destinationId] = destinationKey.split('_');
    findDestination(destinationId, null, {app: app}, function (err, response) {
      if (err){
        return cb(err);
      }
      let credentials = {
        url: response.destinationConfiguration.tokenServiceURL,
        clientid: response.destinationConfiguration.clientId,
        clientsecret: response.destinationConfiguration.clientSecret
      };
      tokenUtils.loadClientCredentialsToken(app, credentials,destinationKey, function(err){
        if (err){
          return cb('Error while fetching client_credentials token for service instance ' + destinationKey + err);
        }
        destinationToken = app.services && app.services[destinationKey] && app.services[destinationKey].token;
        app.services[destinationKey].credentials = response.destinationConfiguration;
        return getDestinationsByServiceInstance(destinationToken,destinationKey,cb);
      });
    });
  } else {
    return getDestinationsByServiceInstance(destinationToken,destinationKey,cb);
  }
}

function getDestinationsByServiceInstance(token,destinationKey,cb){
  getDestinationsByInstanceReqOptions(token,function(err, requestOptions){
    if (err){
      return cb('Error while retrieving destinations for service instance ' + destinationKey + err);
    }
    request.get(requestOptions, function onResponse(err, res) {
      if (err || !res || !res.statusCode) {
        if (err){
          logger.error('Destination error: ' + err);
        }
        return cb('Error while retrieving destinations for service instance ' + destinationKey + err);
      }
      if (res.statusCode !== 200 || !res.body) {
        let errorMessage = 'Error while retrieving destinations for service instance ' + destinationKey + ' from destination service. HTTP status code: ' + res.statusCode;
        logger.error(errorMessage);
        return cb(errorMessage);
      }
      try {
        let destinationLookUpResult = JSON.parse(res.body);
        destinationLookUpResult.forEach((destination) => {
          destination.destinationId = destinationKey.split('_')[1];
        });
        return cb(null, destinationLookUpResult);
      } catch (err) {
        return cb(err);
      }
    });
  });
}

function getDestinationsByInstanceReqOptions(token, cb){
  let credentials = getDestinationServiceCredentials();
  if (!credentials) {
    return cb ('Destination service is not bound');
  }
  let headers = {'accept': 'application/json;charset=utf-8'};
  headers.Authorization = 'Bearer ' + token.accessToken;
  return cb (null, {
    url: credentials.uri + '/destination-configuration/v1/instanceDestinations',
    headers: headers
  });
}

function getDestinationsByTenant(tenant,token, cb){
  getDestinationsByTenantReqOptions(tenant,token, function(error, requestOptions){
    if (error){
      return cb(error);
    }
    request.get(requestOptions, function onResponse(err, res) {
      if (err || !res || !res.statusCode) {
        if (err){
          logger.error('Destination error: ' + err);
        }
        return cb('Error while retrieving destinations for tenant ' + tenant);
      }
      if (res.statusCode !== 200 || !res.body) {
        var errorMessage = 'Error while retrieving destinations for tenant ' + tenant + ' from destination service. HTTP status code: ' + res.statusCode;
        logger.error(errorMessage);
        return cb(errorMessage);
      }
      try {
        var destinationLookUpResult = JSON.parse(res.body);
      } catch (err) {
        return cb(err);
      }
      cb(null, destinationLookUpResult);
    });
  });
}

function adjustDestinationProperties(destinations) {
  destinations.forEach(function (destination) {
    if (destination.proxyType === 'OnPremise') {
      try {
        var credentials = xsenv.serviceCredentials({tag: 'connectivity'});
        destination['proxyHost'] = credentials.onpremise_proxy_host;
        destination['proxyPort'] = credentials.onpremise_proxy_port;
      } catch (error) {
        throw 'Destination \"' + destination.name +
        '\" with  ProxyType \"OnPremise\" but connectivity service is not bound.';
      }
    }
    _.defaults(destination, {
      timeout: 30000
    });
  });
}

function normalizeDestinationProperties(destinations) {
  if (!destinations) {
    return;
  }
  if (!Array.isArray(destinations)){
    throw new Error('destinations type invalid, array is expected');
  }
  destinations.forEach(function (destination, i, destinations) {
    if (destinations[i].Authentication){ // if it destination from destinations service
      destinations[i] = normalizeDestination (destination);
      destinations[i].forwardAuthToken = destinations[i].forwardAuthToken === 'true' || destinations[i].forwardAuthToken === true;
      destinations[i].preserveHostHeader = destinations[i].preserveHostHeader === 'true' || destinations[i].preserveHostHeader === true;
      destinations[i].dynamicDestination = destinations[i].dynamicDestination === 'true' || destinations[i].dynamicDestination === true;
      if (destinations[i].hasOwnProperty('setXForwardedHeaders')) {
        destinations[i].setXForwardedHeaders = destinations[i].setXForwardedHeaders === 'true' || destinations[i].setXForwardedHeaders === true;
      }
      if (destinations[i].timeout && !isNaN(destinations[i].timeout)) {
        destinations[i].timeout = _.toSafeInteger(destinations[i].timeout);
      }
    }
  });
}

function getDestinationsByTenantReqOptions (tenant,token, cb) {
  var credentials = getDestinationServiceCredentials();
  var destinationUrl = credentials.uri + '/destination-configuration/v1/subaccountDestinations';
  if (!credentials) {
    return cb ('Destination service is not bound');
  }
  var headers = {'accept': 'application/json;charset=utf-8'};
  if (token){
    headers.Authorization = 'Bearer ' + token.accessToken;
    return cb (null, {
      url: destinationUrl,
      headers: headers
    });
  }
  tokenUtils.getClientCredentialsTokenByTenant(tenant, credentials, function(err, token){
    if (err){
      return cb(err);
    }
    headers.Authorization = 'Bearer ' + token.accessToken;
    return cb (null, {
      url: destinationUrl,
      headers: headers
    });
  });
}

function getFindDestinationReqOptions (destinationName, token, options, cb) {
  var credentials = getDestinationServiceCredentials ();
  var headers = {'accept': 'application/json;charset=utf-8'};
  if (!credentials) {
    return cb ('Destination service is not bound');
  }

  var auth;
  if (token) {
    auth = token.token ? token : token;
  } else if (options && options.destinationKey && options.app.services && options.app.services[options.destinationKey]){
    auth = options.app.services[options.destinationKey].token;
  } else if (options && options.app && options.app.services['destination'] && options.app.services['destination'].token){
    auth = options.app.services['destination'].token.accessToken;
  } else {
    return cb('obtain token error');
  }
  headers.Authorization = 'Bearer ' + auth;
  return cb (null, {
    url: credentials.uri + '/destination-configuration/v1/destinations/' + destinationName,
    headers: headers
  });
}

function normalizeDestination (destination){
  if (!destination) {
    return;
  }
  var keys = Object.keys(destination);
  var n = keys.length;
  var newobj = {};
  var key;
  while (n--) {
    key = keys[n];
    if (key === 'URL'){
      newobj[key.toLowerCase()] = destination[key];
    } else
    {
      var value = destination[key];
      key = key.replace('HTML5.', '');
      var newKey = key.substr(0, 1).toLowerCase() + key.substr(1);
      newobj[newKey] = value;
    }
  }
  return newobj;
}

function getDestinationServiceCredentials() {
  var errorOccurred;
  var credentials;
  try {
    credentials = xsenv.serviceCredentials({tag: 'destination'});
  } catch (e) {
    errorOccurred = true;
  }
  if (errorOccurred || !credentials) {
    return null;
  }
  return credentials;
}

// Finds a destination by name on all levels and returns the first match
// Search priority is destination on instance level and after that fallback to the shared destinations on subaccount level.
function findDestination (destinationName, token, options, cb){
  if (!destinationName) {
    return cb('Cannot find destination, destination name is missing');
  }

  if (destinationName.includes('$')){
    return cb('destination contains invalid characters, check xs-app.json route.source attribute to make sure the regex is correct');
  }

  if (destinationName.includes('*')){
    return cb('destination contains invalid characters, make sure the DESTINATION_HOST_PATTERN regex is correct');
  }

  var errorMessage;
  getFindDestinationReqOptions(destinationName, token, options, function(error, requestOptions){
    if (error){
      return cb(error);
    }
    request.get(requestOptions, function onResponse(err, res) {
      if (err || !res || !res.statusCode) {
        if (err){
          logger.error('Destination error: ' + err);
        }
        return cb('Error while retrieving destination ' + destinationName + ' from destination service');
      }
      if (res.statusCode !== 200 || !res.body) {
        errorMessage = 'Error while retrieving destination ' + destinationName + ' from destination service. HTTP status code: ' + res.statusCode;
        logger.error(errorMessage);
        return cb(errorMessage);
      }
      try {
        var destinationLookUpResult = JSON.parse(res.body);
      } catch (err) {
        return cb(err);
      }
      cb(null, destinationLookUpResult);
    });
  });
}