import { xml2js } from "xml-js";
import { ensureArray, ParserOutputInstance } from "./utils";
import {
	Action,
	EntityType,
	V4NavigationProperty,
	V2NavigationProperty,
	ReferentialConstraint,
	Property,
	EntitySet,
	Multiplicity,
	Association,
	AssociationEnd,
	Schema,
	EntityContainer,
	ParserOutput,
	Reference,
	AssociationSet,
	AssociationSetEnd,
	ComplexType
} from "@sap-ux/vocabularies-types/dist/Parser";
import {
	SimpleIdentifier,
	FullyQualifiedName,
	PropertyValue,
	AnnotationList,
	AnnotationRecord,
	PropertyPathExpression,
	NavigationPropertyPathExpression,
	AnnotationPathExpression,
	PathExpression,
	Apply,
	Expression,
	Annotation
} from "@sap-ux/vocabularies-types";
import { convertV2Annotations, V2Annotations } from "./v2annotations";

const collectionRegexp = /Collection\(([^)]+)\)/;

type PropertyOutput = {
	entityProperties: Property[];
	entityKeys: Property[];
};

// Type guards

function isV4NavProperty(
	navPropertyAttributes: EDMX.NavigationPropertyAttributesV2 | EDMX.NavigationPropertyAttributesV4
): navPropertyAttributes is EDMX.NavigationPropertyAttributesV4 {
	return (
		(navPropertyAttributes as EDMX.NavigationPropertyAttributesV4).Type !== null &&
		(navPropertyAttributes as EDMX.NavigationPropertyAttributesV4).Type !== undefined
	);
}

// Parser Methods
/**
 * Retrieves the name of the keys for that entity type
 * @param propertyRefs {EDMX.PropertyRef} property reference
 */
function getEntityTypeKeys(propertyRefs: EDMX.PropertyRef[]): SimpleIdentifier[] {
	return propertyRefs.map(propertyRef => propertyRef._attributes.Name);
}

/**
 * Parse the EDMX.Property to retrieve the property
 * @param entityProperties
 * @param entityKeys
 * @param entityTypeFQN
 */
function parseProperties(
	entityProperties: EDMX.Property[],
	entityKeys: SimpleIdentifier[],
	entityTypeFQN: FullyQualifiedName,
	annotationLists: AnnotationList[]
): PropertyOutput {
	return entityProperties.reduce(
		(outObject: PropertyOutput, entityProperty: EDMX.Property) => {
			const edmProperty: Property = {
				_type: "Property",
				name: entityProperty._attributes.Name,
				fullyQualifiedName: `${entityTypeFQN}/${entityProperty._attributes.Name}`,
				type: entityProperty._attributes.Type
			};
			if (entityProperty._attributes.MaxLength) {
				edmProperty.maxLength = parseInt(entityProperty._attributes.MaxLength);
			}
			if (entityProperty._attributes.Precision) {
				edmProperty.precision = parseInt(entityProperty._attributes.Precision);
			}
			if (entityProperty._attributes.Scale) {
				edmProperty.scale = parseInt(entityProperty._attributes.Scale);
			}
			if (entityProperty._attributes.Nullable) {
				edmProperty.nullable = entityProperty._attributes.Nullable !== "false";
			}
			if (entityProperty._attributes.DefaultValue) {
				switch (edmProperty.type) {
					case "Edm.Int16":
					case "Edm.Byte":
					case "Edm.Int32":
					case "Edm.Int64":
						edmProperty.defaultValue = parseInt(entityProperty._attributes.DefaultValue);
						break;
					case "Edm.Decimal":
						edmProperty.defaultValue = parseFloat(entityProperty._attributes.DefaultValue);
						break;
					case "Edm.Boolean":
						edmProperty.defaultValue = entityProperty._attributes.DefaultValue === "true";
						break;
					default:
						edmProperty.defaultValue = entityProperty._attributes.DefaultValue;
						break;
				}
			}

			outObject.entityProperties.push(edmProperty);
			if (entityKeys.indexOf(edmProperty.name) !== -1) {
				outObject.entityKeys.push(edmProperty);
			}

			const v2Annotations = convertV2Annotations(
				entityProperty._attributes as V2Annotations,
				"Property",
				entityProperty._attributes.Name
			);
			if (v2Annotations.length > 0) {
				annotationLists.push(createAnnotationList(edmProperty.fullyQualifiedName, v2Annotations));
			}

			return outObject;
		},
		{ entityProperties: [], entityKeys: [] }
	);
}

function parseReferentialConstraint(
	referentialConstraints: EDMX.ReferentialConstraint[],
	sourceTypeName: FullyQualifiedName,
	targetTypeName: FullyQualifiedName
): ReferentialConstraint[] {
	return referentialConstraints.reduce((outArray: ReferentialConstraint[], refCon: EDMX.ReferentialConstraint) => {
		outArray.push({
			sourceTypeName: sourceTypeName,
			sourceProperty: refCon._attributes.Property,
			targetTypeName: targetTypeName,
			targetProperty: refCon._attributes.ReferencedProperty
		});
		return outArray;
	}, []);
}

function parseNavigationProperties(
	navigationProperties: EDMX.NavigationProperty[],
	currentEntityType: EDMX.EntityType | EDMX.ComplexType,
	entityTypeFQN: FullyQualifiedName,
	annotationLists: AnnotationList[]
): (V2NavigationProperty | V4NavigationProperty)[] {
	return navigationProperties.reduce(
		(outArray: (V2NavigationProperty | V4NavigationProperty)[], navigationProperty) => {
			// V4
			const attributes: EDMX.NavigationPropertyAttributesV4 | EDMX.NavigationPropertyAttributesV2 =
				navigationProperty._attributes;
			if (isV4NavProperty(attributes)) {
				const matches = attributes.Type.match(collectionRegexp);
				const isCollection = matches !== null;
				const typeName = matches ? matches[1] : attributes.Type;
				outArray.push({
					_type: "NavigationProperty",
					name: attributes.Name,
					fullyQualifiedName: `${entityTypeFQN}/${attributes.Name}`,
					partner: attributes.Partner,
					containsTarget: attributes.ContainsTarget === "true",
					isCollection,
					targetTypeName: typeName,
					referentialConstraint: parseReferentialConstraint(
						ensureArray(navigationProperty.ReferentialConstraint),
						currentEntityType._attributes.Name,
						typeName
					)
				});
			} else {
				// V2
				const { Relationship, ToRole, FromRole } = attributes;
				outArray.push({
					_type: "NavigationProperty",
					name: attributes.Name,
					fullyQualifiedName: `${entityTypeFQN}/${attributes.Name}`,
					relationship: Relationship,
					toRole: ToRole,
					fromRole: FromRole
				});
				const v2Annotations = convertV2Annotations(attributes as V2Annotations, "Property", attributes.Name);
				if (v2Annotations.length > 0) {
					annotationLists.push(createAnnotationList(`${entityTypeFQN}/${attributes.Name}`, v2Annotations));
				}
			}

			return outArray;
		},
		[]
	);
}

/**
 * Parse the multiplicty string and return the corresponding enum
 * @param multiplicity the multiplicity string
 * @returns the enum value
 */
function getMultiplicityFromString(multiplicity: string): Multiplicity {
	switch (multiplicity) {
		case "1":
			return Multiplicity.One;
		case "0..1":
			return Multiplicity.ZeroOrOne;
		case "*":
			return Multiplicity.Many;
	}
	return Multiplicity.Unknown;
}

function parseAssociationSets(associations: EDMX.AssociationSet[], namespace: string): AssociationSet[] {
	return associations.map(association => {
		const associationFQN = `${namespace}.${association._attributes.Name}`;
		const associationEnd: AssociationSetEnd[] = ensureArray(association.End).map(
			(endValue: EDMX.AssociationSetEnd) => {
				return {
					entitySet: endValue._attributes.EntitySet,
					role: endValue._attributes.Role
				};
			}
		);
		return {
			fullyQualifiedName: associationFQN,
			name: association._attributes.Name,
			association: association._attributes.Association,
			associationEnd: associationEnd
		};
	});
}

function parseAssociations(associations: EDMX.Association[], namespace: string): Association[] {
	return associations.map(association => {
		const associationFQN = `${namespace}.${association._attributes.Name}`;
		const associationEnd: AssociationEnd[] = ensureArray(association.End).map((endValue: EDMX.AssociationEnd) => {
			return {
				type: endValue._attributes.Type,
				role: endValue._attributes.Role,
				multiplicity: getMultiplicityFromString(endValue._attributes.Multiplicity)
			};
		});
		return {
			fullyQualifiedName: associationFQN,
			name: association._attributes.Name,
			associationEnd: associationEnd
		};
	});
}

function parseEntityTypes(
	entityTypes: EDMX.EntityType[],
	annotations: AnnotationList[],
	namespace: string
): EntityType[] {
	return entityTypes.reduce((outArray: EntityType[], entityType) => {
		const entityKeyNames = getEntityTypeKeys(ensureArray(entityType.Key.PropertyRef));
		const entityTypeFQN = `${namespace}.${entityType._attributes.Name}`;
		const { entityProperties, entityKeys } = parseProperties(
			ensureArray(entityType.Property),
			entityKeyNames,
			entityTypeFQN,
			annotations
		);
		const navigationProperties = parseNavigationProperties(
			ensureArray(entityType.NavigationProperty),
			entityType,
			entityTypeFQN,
			annotations
		);
		outArray.push({
			_type: "EntityType",
			name: entityType._attributes.Name,
			fullyQualifiedName: entityTypeFQN,
			keys: entityKeys,
			entityProperties,
			navigationProperties: navigationProperties
		});
		return outArray;
	}, []);
}

function parseComplexTypes(
	complexTypes: EDMX.ComplexType[],
	annotationLists: AnnotationList[],
	namespace: string
): ComplexType[] {
	return complexTypes.reduce((outArray: ComplexType[], complexType) => {
		const complexTypeFQN = `${namespace}.${complexType._attributes.Name}`;
		const { entityProperties, entityKeys } = parseProperties(
			ensureArray(complexType.Property),
			[],
			complexTypeFQN,
			annotationLists
		);
		const navigationProperties = parseNavigationProperties(
			ensureArray(complexType.NavigationProperty),
			complexType,
			complexTypeFQN,
			annotationLists
		);
		outArray.push({
			_type: "ComplexType",
			name: complexType._attributes.Name,
			fullyQualifiedName: complexTypeFQN,
			properties: entityProperties,
			navigationProperties
		});
		return outArray;
	}, []);
}

function parseEntitySets(
	entitySets: EDMX.EntitySet[],
	namespace: string,
	entityContainerName: string,
	annotationLists: AnnotationList[]
): EntitySet[] {
	const outEntitySets: EntitySet[] = entitySets.map(entitySet => {
		const outEntitySet: EntitySet = {
			_type: "EntitySet",
			name: entitySet._attributes.Name,
			entityTypeName: entitySet._attributes.EntityType,
			navigationPropertyBinding: {},
			fullyQualifiedName: `${namespace}.${entityContainerName}/${entitySet._attributes.Name}`
		};
		const v2Annotations = convertV2Annotations(
			entitySet._attributes as V2Annotations,
			"EntitySet",
			entitySet._attributes.Name
		);
		if (v2Annotations.length > 0) {
			annotationLists.push(createAnnotationList(outEntitySet.fullyQualifiedName, v2Annotations));
		}
		return outEntitySet;
	});
	entitySets.forEach(entitySet => {
		const currentOutEntitySet = outEntitySets.find(
			outEntitySet => outEntitySet.name === entitySet._attributes.Name
		);
		if (currentOutEntitySet) {
			ensureArray(entitySet.NavigationPropertyBinding).forEach(navPropertyBinding => {
				const currentTargetEntitySet = outEntitySets.find(
					outEntitySet => outEntitySet.name === navPropertyBinding._attributes.Target
				);
				if (currentTargetEntitySet) {
					currentOutEntitySet.navigationPropertyBinding[
						navPropertyBinding._attributes.Path
					] = currentTargetEntitySet;
				}
			});
		}
	});

	return outEntitySets;
}

function parseActions(actions: EDMX.Action[], namespace: string): Action[] {
	return actions.map(action => {
		const actionEntityType: string = `${ensureArray(action.Parameter)
			.filter(param => param._attributes.Name === action._attributes.EntitySetPath)
			.map(param => param._attributes.Type)}`;
		const isBound: boolean = action._attributes.IsBound === "true";
		let actionFQN: string = `${action._attributes.Name}()`;
		if (isBound) {
			actionFQN = `${namespace}.${action._attributes.Name}(${actionEntityType})`;
		}
		return {
			_type: "Action",
			name: action._attributes.Name,
			isBound: isBound,
			sourceType: actionEntityType,
			fullyQualifiedName: actionFQN,
			parameters: ensureArray(action.Parameter).map(param => {
				return {
					_type: "ActionParameter",
					fullyQualifiedName: `${actionFQN}/${param._attributes.Name}`,
					type: param._attributes.Type,
					isEntitySet: param._attributes.Name === action._attributes.EntitySetPath
				};
			}),
			returnType: action.ReturnType ? action.ReturnType._attributes.Type : ""
		};
	});
}

function parseFunctionImport(actions: EDMX.FunctionImport[], entitySets: EntitySet[], namespace: string): Action[] {
	return actions.map(action => {
		const targetEntitySet = entitySets.find(et => et.name === action._attributes.EntitySet);
		let actionFQN: string = `${namespace}/${action._attributes.Name}()`;
		return {
			_type: "Action",
			name: action._attributes.Name,
			isBound: false,
			sourceType: targetEntitySet ? targetEntitySet.entityTypeName : "",
			fullyQualifiedName: actionFQN,
			parameters: ensureArray(action.Parameter).map(param => {
				return {
					_type: "ActionParameter",
					fullyQualifiedName: `${actionFQN}/${param._attributes.Name}`,
					type: param._attributes.Type,
					isEntitySet: false
				};
			}),
			returnType: action._attributes.ReturnType ? action._attributes.ReturnType : ""
		};
	});
}

function parsePropertyValues(
	propertyValues: EDMX.PropertyValue[],
	currentTarget: string,
	annotationsLists: AnnotationList[]
): PropertyValue[] {
	return propertyValues.map(propertyValue => {
		const { Annotation, _attributes, ...properties } = propertyValue;
		const outPropertyValue: Partial<PropertyValue> = {};
		if (_attributes) {
			const attributeKey: keyof EDMX.InlineExpression | undefined = Object.keys(_attributes).find(
				keyName => keyName !== "Property"
			) as keyof EDMX.InlineExpression | undefined;
			outPropertyValue.name = _attributes.Property;
			let currentPropertyTarget = `${currentTarget}/${outPropertyValue.name}`;
			if (properties && Object.keys(properties).length > 0) {
				outPropertyValue.value = parseExpression(properties, currentPropertyTarget, annotationsLists);
			} else if (attributeKey) {
				outPropertyValue.value = parseInlineExpression(
					{ [attributeKey]: _attributes[attributeKey] },
					currentPropertyTarget,
					annotationsLists
				);
			}
			if (propertyValue.Annotation) {
				const propertyAnnotations = parseAnnotations(
					ensureArray(propertyValue.Annotation),
					currentPropertyTarget,
					annotationsLists
				);
				if (propertyAnnotations && propertyAnnotations.length > 0) {
					annotationsLists.push(createAnnotationList(currentPropertyTarget, propertyAnnotations));
				}
			}
		}
		return outPropertyValue as PropertyValue;
	});
}

function parseRecord(
	record: EDMX.RecordExpression,
	currentTarget: string,
	annotationsLists: AnnotationList[]
): AnnotationRecord {
	const recordAnnotations = parseAnnotations(ensureArray(record.Annotation), currentTarget, annotationsLists);
	if (recordAnnotations && recordAnnotations.length > 0) {
		annotationsLists.push(createAnnotationList(currentTarget, recordAnnotations));
	}
	return {
		type: record._attributes ? unalias(record._attributes.Type) : undefined,
		propertyValues: parsePropertyValues(ensureArray(record.PropertyValue), currentTarget, annotationsLists)
	};
}

/**
 * Type Guard for the type of the current collection
 * @param collection
 * @param propertyNameToCheck
 */
function isCollectionOfType<K>(collection: any, propertyNameToCheck: string): collection is K {
	return (collection as any)[propertyNameToCheck] != null;
}

function parseModelPath(
	propertyPath: EDMX.ModelPath,
	modelPathType: "AnnotationPath" | "PropertyPath" | "NavigationPropertyPath" | "Path"
): PropertyPathExpression | NavigationPropertyPathExpression | AnnotationPathExpression | PathExpression {
	switch (modelPathType) {
		case "NavigationPropertyPath":
			return { type: "NavigationPropertyPath", NavigationPropertyPath: propertyPath._text };
		case "PropertyPath":
			return { type: "PropertyPath", PropertyPath: propertyPath._text };
		case "AnnotationPath":
			return { type: "AnnotationPath", AnnotationPath: propertyPath._text };
		case "Path":
			return { type: "Path", Path: propertyPath._text };
	}
}

function parseCollection(
	collection: EDMX.CollectionExpression,
	currentTarget: string,
	annotationsLists: AnnotationList[]
):
	| AnnotationRecord[]
	| string[]
	| PropertyPathExpression[]
	| PathExpression[]
	| AnnotationPathExpression[]
	| NavigationPropertyPathExpression[] {
	if (isCollectionOfType<EDMX.RecordCollectionWrapper>(collection, "Record")) {
		const recordArray = ensureArray(collection.Record).map((record, recordIndex) =>
			parseRecord(record, currentTarget + "/" + recordIndex, annotationsLists)
		);
		(recordArray as any).type = "Record";
		return recordArray;
	} else if (isCollectionOfType<EDMX.PropertyPathCollectionWrapper>(collection, "PropertyPath")) {
		const propertyPathArray = ensureArray(collection.PropertyPath).map(
			propertyPath => parseModelPath(propertyPath, "PropertyPath") as PropertyPathExpression
		);
		(propertyPathArray as any).type = "PropertyPath";
		return propertyPathArray;
	} else if (isCollectionOfType<EDMX.NavigationPropertyPathCollectionWrapper>(collection, "NavigationPropertyPath")) {
		const navPropertyPathArray = ensureArray(collection.NavigationPropertyPath).map(
			navPropertyPath =>
				parseModelPath(navPropertyPath, "NavigationPropertyPath") as NavigationPropertyPathExpression
		);
		(navPropertyPathArray as any).type = "NavigationPropertyPath";
		return navPropertyPathArray;
	} else if (isCollectionOfType<EDMX.StringCollectionWrapper>(collection, "String")) {
		const stringArray = ensureArray(collection.String).map(stringValue => stringValue._text);
		(stringArray as any).type = "String";
		return stringArray;
	} else if (isCollectionOfType<EDMX.AnnotationPathCollectionWrapper>(collection, "AnnotationPath")) {
		const annotationPathArray = ensureArray(collection.AnnotationPath).map(
			annotationPath => parseModelPath(annotationPath, "AnnotationPath") as AnnotationPathExpression
		);
		(annotationPathArray as any).type = "AnnotationPath";
		return annotationPathArray;
	} else if (isCollectionOfType<EDMX.PathCollectionWrapper>(collection, "Path")) {
		const pathArray = ensureArray(collection.Path).map(
			pathDefinition => parseModelPath(pathDefinition, "Path") as PathExpression
		);
		(pathArray as any).type = "Path";
		return pathArray;
	} else if (Object.keys(collection).length === 0) {
		return [];
	} else {
		// TODO Full Coverage
		console.error(`Cannot parse ${JSON.stringify(collection)}, collection type is not supported`);
	}
	return [];
}

function parseApply(applyExpression: EDMX.ApplyExpression): Apply {
	return applyExpression;
}

/**
 * Type Guard for the type of the current expression
 * @param annotation
 * @param propertyNameToCheck
 */
function isExpressionOfType<K>(annotation: any, propertyNameToCheck: string): annotation is K {
	return (annotation as any)[propertyNameToCheck] != null;
}

function parseInlineExpression(
	expression: EDMX.InlineExpression,
	currentTarget: string,
	annotationsLists: AnnotationList[]
): Expression {
	const expressionKeys = Object.keys(expression);
	if (expressionKeys.length > 1) {
		throw new Error(`Too many expressions defined on a single object ${JSON.stringify(expression)}`);
	}
	const expressionKey = expressionKeys[0];
	switch (expressionKey) {
		case "String":
			return {
				type: "String",
				String: expression[expressionKey] as string
			};
		case "Bool":
			return {
				type: "Bool",
				Bool: expression.Bool === "true"
			};
		case "Decimal":
			return {
				type: "Decimal",
				Decimal: parseFloat(expression.Decimal as string)
			};
		case "Date":
			return {
				type: "Date",
				Date: expression.Date as string
			};
		case "Int":
			return {
				type: "Int",
				Int: parseInt(expression.Int as string)
			};
		case "Path":
			return {
				type: "Path",
				Path: expression.Path as string
			};
		case "PropertyPath":
			return {
				type: "PropertyPath",
				PropertyPath: expression.PropertyPath as string
			};
		case "AnnotationPath":
			return {
				type: "AnnotationPath",
				AnnotationPath: expression.AnnotationPath as string
			};
		case "NavigationPropertyPath":
			return {
				type: "NavigationPropertyPath",
				NavigationPropertyPath: expression.NavigationPropertyPath as string
			};
		case "EnumMember":
			return {
				type: "EnumMember",
				EnumMember: expression[expressionKey] as string
			};
		case "Collection":
			return {
				type: "Collection",
				Collection: parseCollection(
					expression.Collection as EDMX.CollectionExpression,
					currentTarget,
					annotationsLists
				)
			};
		case "Record":
			return {
				type: "Record",
				Record: parseRecord(expression.Record as EDMX.RecordExpression, currentTarget, annotationsLists)
			};
		case "Apply":
			return {
				type: "Apply",
				Apply: parseApply(expression.Apply)
			};
		default:
			console.error("Unsupported inline expression type " + expressionKey);
			return {
				type: "Unknown"
			};
	}
}

function parseExpression(
	expression: EDMX.Expression<{}>,
	currentTarget: string,
	annotationsLists: AnnotationList[]
): Expression {
	const expressionKeys = Object.keys(expression);
	if (expressionKeys.length > 1) {
		throw new Error(`Too many expressions defined on a single object ${JSON.stringify(expression)}`);
	}
	const expressionKey = expressionKeys[0];
	switch (expressionKey) {
		case "String":
			return {
				type: "String",
				String: (expression[expressionKey] as any)._text as string
			};
		case "Bool":
			return {
				type: "Bool",
				Bool: (expression.Bool as any)._text === "true"
			};
		case "Int":
			return {
				type: "Int",
				Int: parseInt((expression.Int as any)._text as string)
			};
		case "Decimal":
			return {
				type: "Decimal",
				Decimal: parseFloat((expression.Decimal as any)._text as string)
			};
		case "Path":
			return {
				type: "Path",
				Path: (expression.Path as EDMX.InstancePath)._text
			};
		case "PropertyPath":
			return {
				type: "PropertyPath",
				PropertyPath: (expression.PropertyPath as EDMX.ModelPath)._text
			};
		case "NavigationPropertyPath":
			return {
				type: "NavigationPropertyPath",
				NavigationPropertyPath: (expression.NavigationPropertyPath as EDMX.ModelPath)._text
			};
		case "AnnotationPath":
			return {
				type: "AnnotationPath",
				AnnotationPath: (expression.AnnotationPath as EDMX.ModelPath)._text
			};
		case "EnumMember":
			return {
				type: "EnumMember",
				EnumMember: (expression[expressionKey] as any)._text as string
			};
		case "Collection":
			return {
				type: "Collection",
				Collection: parseCollection(
					expression.Collection as EDMX.CollectionExpression,
					currentTarget,
					annotationsLists
				)
			};
		case "Record":
			return {
				type: "Record",
				Record: parseRecord(expression.Record as EDMX.RecordExpression, currentTarget, annotationsLists)
			};
		case "Apply":
			return {
				type: "Apply",
				Apply: parseApply(expression.Apply)
			};
		default:
			console.error("Unsupported expression type " + expressionKey);
			return {
				type: "Unknown"
			};
	}
}

function parseAnnotation(
	annotation: EDMX.Annotation,
	currentTarget: string,
	annotationsLists: AnnotationList[]
): Annotation {
	const { Term, Qualifier, ...others } = annotation._attributes;
	let outAnnotation: Partial<Annotation> = {
		term: unalias(Term),
		qualifier: Qualifier
	};
	let currentAnnotationTarget = `${currentTarget}@${unalias(Term)}`;
	if (Qualifier !== "" && Qualifier !== undefined) {
		currentAnnotationTarget += `#${Qualifier}`;
	}
	if (others && Object.keys(others).length > 0) {
		outAnnotation.value = parseInlineExpression(others, currentAnnotationTarget, annotationsLists);
	}
	if (annotation.Annotation) {
		const annotationAnnotations = parseAnnotations(
			ensureArray(annotation.Annotation),
			currentAnnotationTarget,
			annotationsLists
		);
		if (annotationAnnotations && annotationAnnotations.length > 0) {
			annotationsLists.push(createAnnotationList(currentAnnotationTarget, annotationAnnotations));
		}
	}
	const keys = Object.keys(annotation).filter(keyValue => keyValue !== "_attributes" && keyValue !== "Annotation");
	let isCollection = false;
	if (isExpressionOfType<EDMX.RecordWrapper>(annotation, "Record")) {
		outAnnotation.record = parseRecord(annotation.Record, currentAnnotationTarget, annotationsLists);
	} else if (isExpressionOfType<EDMX.CollectionWrapper>(annotation, "Collection")) {
		outAnnotation.collection = parseCollection(annotation.Collection, currentAnnotationTarget, annotationsLists);
	} else if (keys.length > 1) {
		// TODO Full Coverage
		console.error(`Cannot parse ${JSON.stringify(annotation)}, expression type is not supported`);
	}

	return outAnnotation as Annotation;
}

function parseAnnotations(
	annotations: EDMX.Annotation[],
	currentTarget: string,
	annotationsLists: AnnotationList[]
): Annotation[] {
	return annotations.map(annotation => parseAnnotation(annotation, currentTarget, annotationsLists));
}

function createAnnotationList(target: string, annotations: Annotation[]): AnnotationList {
	return {
		target: target,
		annotations: annotations
	};
}

function parseAnnotationLists(annotationLists: EDMX.AnnotationList[], annotationsLists: AnnotationList[]): void {
	annotationLists
		.filter(annotationList => annotationList._attributes !== undefined)
		.forEach(annotationList => {
			annotationsLists.push(
				createAnnotationList(
					annotationList._attributes.Target,
					parseAnnotations(
						ensureArray(annotationList.Annotation),
						annotationList._attributes.Target,
						annotationsLists
					)
				)
			);
		});
}

function parseSchema(edmSchema: EDMX.Schema, identification: string): Schema {
	const namespace = edmSchema._attributes.Namespace;
	const annotations: AnnotationList[] = [];
	const entityTypes = parseEntityTypes(ensureArray(edmSchema.EntityType), annotations, namespace);
	const complexTypes = parseComplexTypes(ensureArray(edmSchema.ComplexType), annotations, namespace);
	let entitySets: EntitySet[] = [];
	let associationSets: AssociationSet[] = [];
	let entityContainer: EntityContainer = {};
	let actions: Action[] = [];
	if (edmSchema.EntityContainer) {
		entitySets = parseEntitySets(
			ensureArray(edmSchema.EntityContainer.EntitySet),
			namespace,
			edmSchema.EntityContainer._attributes.Name,
			annotations
		);
		associationSets = parseAssociationSets(ensureArray(edmSchema.EntityContainer.AssociationSet), namespace);
		entityContainer = {
			name: edmSchema.EntityContainer._attributes.Name,
			fullyQualifiedName: `${namespace}.${edmSchema.EntityContainer._attributes.Name}`
		};
		actions = actions.concat(
			parseFunctionImport(
				ensureArray(edmSchema.EntityContainer.FunctionImport),
				entitySets,
				entityContainer.fullyQualifiedName as string
			)
		);
	}
	actions = actions.concat(parseActions(ensureArray(edmSchema.Action), namespace));
	// const actionImports = parseActionImports(ensureArray(edmSchema.EntityContainer.ActionImport), namespace);
	const associations = parseAssociations(ensureArray(edmSchema.Association), namespace);
	if (associationSets.length > 0)
		// V2 case
		entitySets.forEach(entitySet => {
			const entityType = entityTypes.find(
				entityType => entityType.fullyQualifiedName === entitySet.entityTypeName
			);
			entityType?.navigationProperties.forEach(navProp => {
				const v2NavProp: V2NavigationProperty = navProp as V2NavigationProperty;
				const associationSet = associationSets.find(
					assoc => assoc.fullyQualifiedName === v2NavProp.relationship
				);
				if (associationSet) {
					const associationEndEntitySets = associationSet.associationEnd.map(
						(associationEnd: AssociationSetEnd) => {
							return entitySets.find(entitySet => entitySet.name === associationEnd.entitySet);
						}
					);
					const targetEntitySet = associationEndEntitySets.find(
						associationEntitySet =>
							associationEntitySet?.fullyQualifiedName !== entitySet.fullyQualifiedName
					);
					if (targetEntitySet) {
						entitySet.navigationPropertyBinding[navProp.name] = targetEntitySet;
					}
				}
			});
		});

	parseAnnotationLists(ensureArray(edmSchema.Annotations), annotations);
	var annotationMap: { [id: string]: AnnotationList[] } = {};
	annotationMap[identification] = annotations;
	return {
		associations,
		annotations: annotationMap,
		entityContainer,
		namespace: namespace,
		entitySets,
		complexTypes,
		actions,
		entityTypes
	};
}

function parseReferences(references: EDMX.Reference[], schema: EDMX.Schema): Reference[] {
	const outReferences: Reference[] = references.reduce((referencesArray: Reference[], reference: EDMX.Reference) => {
		const includes = ensureArray(reference["edmx:Include"]);
		includes.forEach((include: EDMX.ReferenceInclude) => {
			referencesArray.push({
				uri: reference._attributes.Uri,
				alias: include._attributes.Alias,
				namespace: include._attributes.Namespace
			});
		});
		return referencesArray;
	}, []);
	if (schema && schema._attributes.Alias) {
		outReferences.push({
			uri: "",
			alias: schema._attributes.Alias,
			namespace: schema._attributes.Namespace
		});
	}
	return outReferences;
}

let referenceMap: Record<string, Reference> = {};

function unalias(aliasedValue: string | undefined): string | undefined {
	if (!aliasedValue) {
		return aliasedValue;
	}
	const [alias, value] = aliasedValue.split(".");
	const reference = referenceMap[alias];
	if (reference) {
		return `${reference.namespace}.${value}`;
	} else {
		// Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
		if (aliasedValue.indexOf("@") !== -1) {
			const [preAlias, postAlias] = aliasedValue.split("@");
			return `${preAlias}@${unalias(postAlias)}`;
		} else {
			return aliasedValue;
		}
	}
}

/**
 * Parse an edmx file and return a parsed Service Definition
 * @param xml {string} the original XML string
 * @param fileIdentification {string} a way to identify this file
 */
export function parseEDMX(xml: string, fileIdentification: string = "serviceFile"): ParserOutput {
	const jsonObj: EDMX.Edmx = xml2js(xml, { compact: true }) as EDMX.Edmx;

	const references = parseReferences(
		ensureArray(jsonObj["edmx:Edmx"]["edmx:Reference"]),
		jsonObj["edmx:Edmx"]["edmx:DataServices"].Schema
	);
	referenceMap = references.reduce((map: Record<string, Reference>, reference) => {
		map[reference.alias] = reference;
		return map;
	}, {});
	const edmxDocument: ParserOutput = new ParserOutputInstance(
		fileIdentification,
		jsonObj["edmx:Edmx"]._attributes.Version,
		parseSchema(jsonObj["edmx:Edmx"]["edmx:DataServices"].Schema, fileIdentification),
		references
	);

	return edmxDocument;
}
