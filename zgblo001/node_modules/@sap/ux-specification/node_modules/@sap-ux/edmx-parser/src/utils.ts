/**
 * Given an object that is either an array or a single element, make sure the output it always wrapped as an array
 * @param sourceObject an object or an array
 * @returns either the original array or the same element wrapped in an arrays
 */
import { AnnotationList, ParserOutput } from "@sap-ux/vocabularies-types";
import {
	Action,
	Association,
	EntityContainer,
	EntitySet,
	EntityType,
	Reference,
	Schema,
	ComplexType
} from "@sap-ux/vocabularies-types/dist/Parser";

export function ensureArray<T>(sourceObject: T | T[] | undefined): T[] {
	if (sourceObject === undefined || sourceObject === null) {
		return [];
	}
	if (Array.isArray(sourceObject)) {
		return sourceObject;
	} else {
		return [sourceObject];
	}
}

export class ParserOutputInstance implements ParserOutput {
	references: Reference[];
	schema: Schema;
	version: string;
	identification: string;

	constructor(fileIdentification: string, version: string, schema: Schema, references: Reference[]) {
		this.identification = fileIdentification;
		this.references = references;
		this.version = version;
		this.schema = schema;
	}

	unalias(aliasedValue: string): string {
		if (!aliasedValue) {
			return aliasedValue;
		}
		const [alias, value] = aliasedValue.split(".");
		const reference = this.references.find(reference => {
			return reference.alias === alias;
		});
		if (reference) {
			return `${reference.namespace}.${value}`;
		} else {
			// Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
			if (aliasedValue.indexOf("@") !== -1) {
				const [preAlias, postAlias] = aliasedValue.split("@");
				return `${preAlias}@${this.unalias(postAlias)}`;
			} else {
				return aliasedValue;
			}
		}
	}
}

export class MergedParserOutput implements ParserOutputInstance {
	get references(): Reference[] {
		return this._references;
	}

	get schema(): Schema {
		return {
			associations: this._associations,
			annotations: this._annotations,
			entityContainer: this._entityContainer,
			namespace: this._namespace,
			entitySets: this._entitySets,
			complexTypes: this._complexTypes,
			actions: this._actions,
			entityTypes: this._entityTypes
		};
	}

	version: string;
	identification: string;
	_references: Reference[] = [];
	_namespace: string;
	_parserOutput: ParserOutput[] = [];
	_annotations: { [id: string]: AnnotationList[] } = {};
	_associations: Association[] = [];
	_entitySets: EntitySet[] = [];
	_actions: Action[] = [];
	_entityContainer: EntityContainer = {};
	_entityTypes: EntityType[] = [];
	_complexTypes: ComplexType[] = [];

	constructor(initialParserOutput: ParserOutput) {
		this.identification = "mergedParserInstance";
		this.version = initialParserOutput.version;
		this._namespace = initialParserOutput.schema.namespace;
	}

	public addParserOutput(parserOutput: ParserOutput): void {
		this._parserOutput.push(parserOutput);
		this._references = this._references.concat(parserOutput.references);
		this._associations = this._associations.concat(parserOutput.schema.associations);
		this._annotations = Object.assign(this._annotations, parserOutput.schema.annotations);
		this._entitySets = this._entitySets.concat(parserOutput.schema.entitySets);
		this._actions = this._actions.concat(parserOutput.schema.actions);
		this._entityTypes = this._entityTypes.concat(parserOutput.schema.entityTypes);
		this._complexTypes = this._complexTypes.concat(parserOutput.schema.complexTypes);
		this._entityContainer = Object.assign(this._entityContainer, parserOutput.schema.entityContainer);
	}
	unalias(aliasedValue: string): string {
		if (!aliasedValue) {
			return aliasedValue;
		}
		const [alias, value] = aliasedValue.split(".");
		const reference = this.references.find(reference => {
			return reference.alias === alias;
		});
		if (reference) {
			return `${reference.namespace}.${value}`;
		} else {
			// Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
			if (aliasedValue.indexOf("@") !== -1) {
				const [preAlias, postAlias] = aliasedValue.split("@");
				return `${preAlias}@${this.unalias(postAlias)}`;
			} else {
				return aliasedValue;
			}
		}
	}
}
