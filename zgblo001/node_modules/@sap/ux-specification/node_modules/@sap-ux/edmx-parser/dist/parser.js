"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseEDMX = void 0;
const xml_js_1 = require("xml-js");
const utils_1 = require("./utils");
const Parser_1 = require("@sap-ux/vocabularies-types/dist/Parser");
const v2annotations_1 = require("./v2annotations");
const collectionRegexp = /Collection\(([^)]+)\)/;
// Type guards
function isV4NavProperty(navPropertyAttributes) {
    return (navPropertyAttributes.Type !== null &&
        navPropertyAttributes.Type !== undefined);
}
// Parser Methods
/**
 * Retrieves the name of the keys for that entity type
 * @param propertyRefs {EDMX.PropertyRef} property reference
 */
function getEntityTypeKeys(propertyRefs) {
    return propertyRefs.map(propertyRef => propertyRef._attributes.Name);
}
/**
 * Parse the EDMX.Property to retrieve the property
 * @param entityProperties
 * @param entityKeys
 * @param entityTypeFQN
 */
function parseProperties(entityProperties, entityKeys, entityTypeFQN, annotationLists) {
    return entityProperties.reduce((outObject, entityProperty) => {
        const edmProperty = {
            _type: "Property",
            name: entityProperty._attributes.Name,
            fullyQualifiedName: `${entityTypeFQN}/${entityProperty._attributes.Name}`,
            type: entityProperty._attributes.Type
        };
        if (entityProperty._attributes.MaxLength) {
            edmProperty.maxLength = parseInt(entityProperty._attributes.MaxLength);
        }
        if (entityProperty._attributes.Precision) {
            edmProperty.precision = parseInt(entityProperty._attributes.Precision);
        }
        if (entityProperty._attributes.Scale) {
            edmProperty.scale = parseInt(entityProperty._attributes.Scale);
        }
        if (entityProperty._attributes.Nullable) {
            edmProperty.nullable = entityProperty._attributes.Nullable !== "false";
        }
        if (entityProperty._attributes.DefaultValue) {
            switch (edmProperty.type) {
                case "Edm.Int16":
                case "Edm.Byte":
                case "Edm.Int32":
                case "Edm.Int64":
                    edmProperty.defaultValue = parseInt(entityProperty._attributes.DefaultValue);
                    break;
                case "Edm.Decimal":
                    edmProperty.defaultValue = parseFloat(entityProperty._attributes.DefaultValue);
                    break;
                case "Edm.Boolean":
                    edmProperty.defaultValue = entityProperty._attributes.DefaultValue === "true";
                    break;
                default:
                    edmProperty.defaultValue = entityProperty._attributes.DefaultValue;
                    break;
            }
        }
        outObject.entityProperties.push(edmProperty);
        if (entityKeys.indexOf(edmProperty.name) !== -1) {
            outObject.entityKeys.push(edmProperty);
        }
        const v2Annotations = v2annotations_1.convertV2Annotations(entityProperty._attributes, "Property", entityProperty._attributes.Name);
        if (v2Annotations.length > 0) {
            annotationLists.push(createAnnotationList(edmProperty.fullyQualifiedName, v2Annotations));
        }
        return outObject;
    }, { entityProperties: [], entityKeys: [] });
}
function parseReferentialConstraint(referentialConstraints, sourceTypeName, targetTypeName) {
    return referentialConstraints.reduce((outArray, refCon) => {
        outArray.push({
            sourceTypeName: sourceTypeName,
            sourceProperty: refCon._attributes.Property,
            targetTypeName: targetTypeName,
            targetProperty: refCon._attributes.ReferencedProperty
        });
        return outArray;
    }, []);
}
function parseNavigationProperties(navigationProperties, currentEntityType, entityTypeFQN, annotationLists) {
    return navigationProperties.reduce((outArray, navigationProperty) => {
        // V4
        const attributes = navigationProperty._attributes;
        if (isV4NavProperty(attributes)) {
            const matches = attributes.Type.match(collectionRegexp);
            const isCollection = matches !== null;
            const typeName = matches ? matches[1] : attributes.Type;
            outArray.push({
                _type: "NavigationProperty",
                name: attributes.Name,
                fullyQualifiedName: `${entityTypeFQN}/${attributes.Name}`,
                partner: attributes.Partner,
                containsTarget: attributes.ContainsTarget === "true",
                isCollection,
                targetTypeName: typeName,
                referentialConstraint: parseReferentialConstraint(utils_1.ensureArray(navigationProperty.ReferentialConstraint), currentEntityType._attributes.Name, typeName)
            });
        }
        else {
            // V2
            const { Relationship, ToRole, FromRole } = attributes;
            outArray.push({
                _type: "NavigationProperty",
                name: attributes.Name,
                fullyQualifiedName: `${entityTypeFQN}/${attributes.Name}`,
                relationship: Relationship,
                toRole: ToRole,
                fromRole: FromRole
            });
            const v2Annotations = v2annotations_1.convertV2Annotations(attributes, "Property", attributes.Name);
            if (v2Annotations.length > 0) {
                annotationLists.push(createAnnotationList(`${entityTypeFQN}/${attributes.Name}`, v2Annotations));
            }
        }
        return outArray;
    }, []);
}
/**
 * Parse the multiplicty string and return the corresponding enum
 * @param multiplicity the multiplicity string
 * @returns the enum value
 */
function getMultiplicityFromString(multiplicity) {
    switch (multiplicity) {
        case "1":
            return Parser_1.Multiplicity.One;
        case "0..1":
            return Parser_1.Multiplicity.ZeroOrOne;
        case "*":
            return Parser_1.Multiplicity.Many;
    }
    return Parser_1.Multiplicity.Unknown;
}
function parseAssociationSets(associations, namespace) {
    return associations.map(association => {
        const associationFQN = `${namespace}.${association._attributes.Name}`;
        const associationEnd = utils_1.ensureArray(association.End).map((endValue) => {
            return {
                entitySet: endValue._attributes.EntitySet,
                role: endValue._attributes.Role
            };
        });
        return {
            fullyQualifiedName: associationFQN,
            name: association._attributes.Name,
            association: association._attributes.Association,
            associationEnd: associationEnd
        };
    });
}
function parseAssociations(associations, namespace) {
    return associations.map(association => {
        const associationFQN = `${namespace}.${association._attributes.Name}`;
        const associationEnd = utils_1.ensureArray(association.End).map((endValue) => {
            return {
                type: endValue._attributes.Type,
                role: endValue._attributes.Role,
                multiplicity: getMultiplicityFromString(endValue._attributes.Multiplicity)
            };
        });
        return {
            fullyQualifiedName: associationFQN,
            name: association._attributes.Name,
            associationEnd: associationEnd
        };
    });
}
function parseEntityTypes(entityTypes, annotations, namespace) {
    return entityTypes.reduce((outArray, entityType) => {
        const entityKeyNames = getEntityTypeKeys(utils_1.ensureArray(entityType.Key.PropertyRef));
        const entityTypeFQN = `${namespace}.${entityType._attributes.Name}`;
        const { entityProperties, entityKeys } = parseProperties(utils_1.ensureArray(entityType.Property), entityKeyNames, entityTypeFQN, annotations);
        const navigationProperties = parseNavigationProperties(utils_1.ensureArray(entityType.NavigationProperty), entityType, entityTypeFQN, annotations);
        outArray.push({
            _type: "EntityType",
            name: entityType._attributes.Name,
            fullyQualifiedName: entityTypeFQN,
            keys: entityKeys,
            entityProperties,
            navigationProperties: navigationProperties
        });
        return outArray;
    }, []);
}
function parseComplexTypes(complexTypes, annotationLists, namespace) {
    return complexTypes.reduce((outArray, complexType) => {
        const complexTypeFQN = `${namespace}.${complexType._attributes.Name}`;
        const { entityProperties, entityKeys } = parseProperties(utils_1.ensureArray(complexType.Property), [], complexTypeFQN, annotationLists);
        const navigationProperties = parseNavigationProperties(utils_1.ensureArray(complexType.NavigationProperty), complexType, complexTypeFQN, annotationLists);
        outArray.push({
            _type: "ComplexType",
            name: complexType._attributes.Name,
            fullyQualifiedName: complexTypeFQN,
            properties: entityProperties,
            navigationProperties
        });
        return outArray;
    }, []);
}
function parseEntitySets(entitySets, namespace, entityContainerName, annotationLists) {
    const outEntitySets = entitySets.map(entitySet => {
        const outEntitySet = {
            _type: "EntitySet",
            name: entitySet._attributes.Name,
            entityTypeName: entitySet._attributes.EntityType,
            navigationPropertyBinding: {},
            fullyQualifiedName: `${namespace}.${entityContainerName}/${entitySet._attributes.Name}`
        };
        const v2Annotations = v2annotations_1.convertV2Annotations(entitySet._attributes, "EntitySet", entitySet._attributes.Name);
        if (v2Annotations.length > 0) {
            annotationLists.push(createAnnotationList(outEntitySet.fullyQualifiedName, v2Annotations));
        }
        return outEntitySet;
    });
    entitySets.forEach(entitySet => {
        const currentOutEntitySet = outEntitySets.find(outEntitySet => outEntitySet.name === entitySet._attributes.Name);
        if (currentOutEntitySet) {
            utils_1.ensureArray(entitySet.NavigationPropertyBinding).forEach(navPropertyBinding => {
                const currentTargetEntitySet = outEntitySets.find(outEntitySet => outEntitySet.name === navPropertyBinding._attributes.Target);
                if (currentTargetEntitySet) {
                    currentOutEntitySet.navigationPropertyBinding[navPropertyBinding._attributes.Path] = currentTargetEntitySet;
                }
            });
        }
    });
    return outEntitySets;
}
function parseActions(actions, namespace) {
    return actions.map(action => {
        const actionEntityType = `${utils_1.ensureArray(action.Parameter)
            .filter(param => param._attributes.Name === action._attributes.EntitySetPath)
            .map(param => param._attributes.Type)}`;
        const isBound = action._attributes.IsBound === "true";
        let actionFQN = `${action._attributes.Name}()`;
        if (isBound) {
            actionFQN = `${namespace}.${action._attributes.Name}(${actionEntityType})`;
        }
        return {
            _type: "Action",
            name: action._attributes.Name,
            isBound: isBound,
            sourceType: actionEntityType,
            fullyQualifiedName: actionFQN,
            parameters: utils_1.ensureArray(action.Parameter).map(param => {
                return {
                    _type: "ActionParameter",
                    fullyQualifiedName: `${actionFQN}/${param._attributes.Name}`,
                    type: param._attributes.Type,
                    isEntitySet: param._attributes.Name === action._attributes.EntitySetPath
                };
            }),
            returnType: action.ReturnType ? action.ReturnType._attributes.Type : ""
        };
    });
}
function parseFunctionImport(actions, entitySets, namespace) {
    return actions.map(action => {
        const targetEntitySet = entitySets.find(et => et.name === action._attributes.EntitySet);
        let actionFQN = `${namespace}/${action._attributes.Name}()`;
        return {
            _type: "Action",
            name: action._attributes.Name,
            isBound: false,
            sourceType: targetEntitySet ? targetEntitySet.entityTypeName : "",
            fullyQualifiedName: actionFQN,
            parameters: utils_1.ensureArray(action.Parameter).map(param => {
                return {
                    _type: "ActionParameter",
                    fullyQualifiedName: `${actionFQN}/${param._attributes.Name}`,
                    type: param._attributes.Type,
                    isEntitySet: false
                };
            }),
            returnType: action._attributes.ReturnType ? action._attributes.ReturnType : ""
        };
    });
}
function parsePropertyValues(propertyValues, currentTarget, annotationsLists) {
    return propertyValues.map(propertyValue => {
        const { Annotation, _attributes, ...properties } = propertyValue;
        const outPropertyValue = {};
        if (_attributes) {
            const attributeKey = Object.keys(_attributes).find(keyName => keyName !== "Property");
            outPropertyValue.name = _attributes.Property;
            let currentPropertyTarget = `${currentTarget}/${outPropertyValue.name}`;
            if (properties && Object.keys(properties).length > 0) {
                outPropertyValue.value = parseExpression(properties, currentPropertyTarget, annotationsLists);
            }
            else if (attributeKey) {
                outPropertyValue.value = parseInlineExpression({ [attributeKey]: _attributes[attributeKey] }, currentPropertyTarget, annotationsLists);
            }
            if (propertyValue.Annotation) {
                const propertyAnnotations = parseAnnotations(utils_1.ensureArray(propertyValue.Annotation), currentPropertyTarget, annotationsLists);
                if (propertyAnnotations && propertyAnnotations.length > 0) {
                    annotationsLists.push(createAnnotationList(currentPropertyTarget, propertyAnnotations));
                }
            }
        }
        return outPropertyValue;
    });
}
function parseRecord(record, currentTarget, annotationsLists) {
    const recordAnnotations = parseAnnotations(utils_1.ensureArray(record.Annotation), currentTarget, annotationsLists);
    if (recordAnnotations && recordAnnotations.length > 0) {
        annotationsLists.push(createAnnotationList(currentTarget, recordAnnotations));
    }
    return {
        type: record._attributes ? unalias(record._attributes.Type) : undefined,
        propertyValues: parsePropertyValues(utils_1.ensureArray(record.PropertyValue), currentTarget, annotationsLists)
    };
}
/**
 * Type Guard for the type of the current collection
 * @param collection
 * @param propertyNameToCheck
 */
function isCollectionOfType(collection, propertyNameToCheck) {
    return collection[propertyNameToCheck] != null;
}
function parseModelPath(propertyPath, modelPathType) {
    switch (modelPathType) {
        case "NavigationPropertyPath":
            return { type: "NavigationPropertyPath", NavigationPropertyPath: propertyPath._text };
        case "PropertyPath":
            return { type: "PropertyPath", PropertyPath: propertyPath._text };
        case "AnnotationPath":
            return { type: "AnnotationPath", AnnotationPath: propertyPath._text };
        case "Path":
            return { type: "Path", Path: propertyPath._text };
    }
}
function parseCollection(collection, currentTarget, annotationsLists) {
    if (isCollectionOfType(collection, "Record")) {
        const recordArray = utils_1.ensureArray(collection.Record).map((record, recordIndex) => parseRecord(record, currentTarget + "/" + recordIndex, annotationsLists));
        recordArray.type = "Record";
        return recordArray;
    }
    else if (isCollectionOfType(collection, "PropertyPath")) {
        const propertyPathArray = utils_1.ensureArray(collection.PropertyPath).map(propertyPath => parseModelPath(propertyPath, "PropertyPath"));
        propertyPathArray.type = "PropertyPath";
        return propertyPathArray;
    }
    else if (isCollectionOfType(collection, "NavigationPropertyPath")) {
        const navPropertyPathArray = utils_1.ensureArray(collection.NavigationPropertyPath).map(navPropertyPath => parseModelPath(navPropertyPath, "NavigationPropertyPath"));
        navPropertyPathArray.type = "NavigationPropertyPath";
        return navPropertyPathArray;
    }
    else if (isCollectionOfType(collection, "String")) {
        const stringArray = utils_1.ensureArray(collection.String).map(stringValue => stringValue._text);
        stringArray.type = "String";
        return stringArray;
    }
    else if (isCollectionOfType(collection, "AnnotationPath")) {
        const annotationPathArray = utils_1.ensureArray(collection.AnnotationPath).map(annotationPath => parseModelPath(annotationPath, "AnnotationPath"));
        annotationPathArray.type = "AnnotationPath";
        return annotationPathArray;
    }
    else if (isCollectionOfType(collection, "Path")) {
        const pathArray = utils_1.ensureArray(collection.Path).map(pathDefinition => parseModelPath(pathDefinition, "Path"));
        pathArray.type = "Path";
        return pathArray;
    }
    else if (Object.keys(collection).length === 0) {
        return [];
    }
    else {
        // TODO Full Coverage
        console.error(`Cannot parse ${JSON.stringify(collection)}, collection type is not supported`);
    }
    return [];
}
function parseApply(applyExpression) {
    return applyExpression;
}
/**
 * Type Guard for the type of the current expression
 * @param annotation
 * @param propertyNameToCheck
 */
function isExpressionOfType(annotation, propertyNameToCheck) {
    return annotation[propertyNameToCheck] != null;
}
function parseInlineExpression(expression, currentTarget, annotationsLists) {
    const expressionKeys = Object.keys(expression);
    if (expressionKeys.length > 1) {
        throw new Error(`Too many expressions defined on a single object ${JSON.stringify(expression)}`);
    }
    const expressionKey = expressionKeys[0];
    switch (expressionKey) {
        case "String":
            return {
                type: "String",
                String: expression[expressionKey]
            };
        case "Bool":
            return {
                type: "Bool",
                Bool: expression.Bool === "true"
            };
        case "Decimal":
            return {
                type: "Decimal",
                Decimal: parseFloat(expression.Decimal)
            };
        case "Date":
            return {
                type: "Date",
                Date: expression.Date
            };
        case "Int":
            return {
                type: "Int",
                Int: parseInt(expression.Int)
            };
        case "Path":
            return {
                type: "Path",
                Path: expression.Path
            };
        case "PropertyPath":
            return {
                type: "PropertyPath",
                PropertyPath: expression.PropertyPath
            };
        case "AnnotationPath":
            return {
                type: "AnnotationPath",
                AnnotationPath: expression.AnnotationPath
            };
        case "NavigationPropertyPath":
            return {
                type: "NavigationPropertyPath",
                NavigationPropertyPath: expression.NavigationPropertyPath
            };
        case "EnumMember":
            return {
                type: "EnumMember",
                EnumMember: expression[expressionKey]
            };
        case "Collection":
            return {
                type: "Collection",
                Collection: parseCollection(expression.Collection, currentTarget, annotationsLists)
            };
        case "Record":
            return {
                type: "Record",
                Record: parseRecord(expression.Record, currentTarget, annotationsLists)
            };
        case "Apply":
            return {
                type: "Apply",
                Apply: parseApply(expression.Apply)
            };
        default:
            console.error("Unsupported inline expression type " + expressionKey);
            return {
                type: "Unknown"
            };
    }
}
function parseExpression(expression, currentTarget, annotationsLists) {
    const expressionKeys = Object.keys(expression);
    if (expressionKeys.length > 1) {
        throw new Error(`Too many expressions defined on a single object ${JSON.stringify(expression)}`);
    }
    const expressionKey = expressionKeys[0];
    switch (expressionKey) {
        case "String":
            return {
                type: "String",
                String: expression[expressionKey]._text
            };
        case "Bool":
            return {
                type: "Bool",
                Bool: expression.Bool._text === "true"
            };
        case "Int":
            return {
                type: "Int",
                Int: parseInt(expression.Int._text)
            };
        case "Decimal":
            return {
                type: "Decimal",
                Decimal: parseFloat(expression.Decimal._text)
            };
        case "Path":
            return {
                type: "Path",
                Path: expression.Path._text
            };
        case "PropertyPath":
            return {
                type: "PropertyPath",
                PropertyPath: expression.PropertyPath._text
            };
        case "NavigationPropertyPath":
            return {
                type: "NavigationPropertyPath",
                NavigationPropertyPath: expression.NavigationPropertyPath._text
            };
        case "AnnotationPath":
            return {
                type: "AnnotationPath",
                AnnotationPath: expression.AnnotationPath._text
            };
        case "EnumMember":
            return {
                type: "EnumMember",
                EnumMember: expression[expressionKey]._text
            };
        case "Collection":
            return {
                type: "Collection",
                Collection: parseCollection(expression.Collection, currentTarget, annotationsLists)
            };
        case "Record":
            return {
                type: "Record",
                Record: parseRecord(expression.Record, currentTarget, annotationsLists)
            };
        case "Apply":
            return {
                type: "Apply",
                Apply: parseApply(expression.Apply)
            };
        default:
            console.error("Unsupported expression type " + expressionKey);
            return {
                type: "Unknown"
            };
    }
}
function parseAnnotation(annotation, currentTarget, annotationsLists) {
    const { Term, Qualifier, ...others } = annotation._attributes;
    let outAnnotation = {
        term: unalias(Term),
        qualifier: Qualifier
    };
    let currentAnnotationTarget = `${currentTarget}@${unalias(Term)}`;
    if (Qualifier !== "" && Qualifier !== undefined) {
        currentAnnotationTarget += `#${Qualifier}`;
    }
    if (others && Object.keys(others).length > 0) {
        outAnnotation.value = parseInlineExpression(others, currentAnnotationTarget, annotationsLists);
    }
    if (annotation.Annotation) {
        const annotationAnnotations = parseAnnotations(utils_1.ensureArray(annotation.Annotation), currentAnnotationTarget, annotationsLists);
        if (annotationAnnotations && annotationAnnotations.length > 0) {
            annotationsLists.push(createAnnotationList(currentAnnotationTarget, annotationAnnotations));
        }
    }
    const keys = Object.keys(annotation).filter(keyValue => keyValue !== "_attributes" && keyValue !== "Annotation");
    let isCollection = false;
    if (isExpressionOfType(annotation, "Record")) {
        outAnnotation.record = parseRecord(annotation.Record, currentAnnotationTarget, annotationsLists);
    }
    else if (isExpressionOfType(annotation, "Collection")) {
        outAnnotation.collection = parseCollection(annotation.Collection, currentAnnotationTarget, annotationsLists);
    }
    else if (keys.length > 1) {
        // TODO Full Coverage
        console.error(`Cannot parse ${JSON.stringify(annotation)}, expression type is not supported`);
    }
    return outAnnotation;
}
function parseAnnotations(annotations, currentTarget, annotationsLists) {
    return annotations.map(annotation => parseAnnotation(annotation, currentTarget, annotationsLists));
}
function createAnnotationList(target, annotations) {
    return {
        target: target,
        annotations: annotations
    };
}
function parseAnnotationLists(annotationLists, annotationsLists) {
    annotationLists
        .filter(annotationList => annotationList._attributes !== undefined)
        .forEach(annotationList => {
        annotationsLists.push(createAnnotationList(annotationList._attributes.Target, parseAnnotations(utils_1.ensureArray(annotationList.Annotation), annotationList._attributes.Target, annotationsLists)));
    });
}
function parseSchema(edmSchema, identification) {
    const namespace = edmSchema._attributes.Namespace;
    const annotations = [];
    const entityTypes = parseEntityTypes(utils_1.ensureArray(edmSchema.EntityType), annotations, namespace);
    const complexTypes = parseComplexTypes(utils_1.ensureArray(edmSchema.ComplexType), annotations, namespace);
    let entitySets = [];
    let associationSets = [];
    let entityContainer = {};
    let actions = [];
    if (edmSchema.EntityContainer) {
        entitySets = parseEntitySets(utils_1.ensureArray(edmSchema.EntityContainer.EntitySet), namespace, edmSchema.EntityContainer._attributes.Name, annotations);
        associationSets = parseAssociationSets(utils_1.ensureArray(edmSchema.EntityContainer.AssociationSet), namespace);
        entityContainer = {
            name: edmSchema.EntityContainer._attributes.Name,
            fullyQualifiedName: `${namespace}.${edmSchema.EntityContainer._attributes.Name}`
        };
        actions = actions.concat(parseFunctionImport(utils_1.ensureArray(edmSchema.EntityContainer.FunctionImport), entitySets, entityContainer.fullyQualifiedName));
    }
    actions = actions.concat(parseActions(utils_1.ensureArray(edmSchema.Action), namespace));
    // const actionImports = parseActionImports(ensureArray(edmSchema.EntityContainer.ActionImport), namespace);
    const associations = parseAssociations(utils_1.ensureArray(edmSchema.Association), namespace);
    if (associationSets.length > 0)
        // V2 case
        entitySets.forEach(entitySet => {
            const entityType = entityTypes.find(entityType => entityType.fullyQualifiedName === entitySet.entityTypeName);
            entityType === null || entityType === void 0 ? void 0 : entityType.navigationProperties.forEach(navProp => {
                const v2NavProp = navProp;
                const associationSet = associationSets.find(assoc => assoc.fullyQualifiedName === v2NavProp.relationship);
                if (associationSet) {
                    const associationEndEntitySets = associationSet.associationEnd.map((associationEnd) => {
                        return entitySets.find(entitySet => entitySet.name === associationEnd.entitySet);
                    });
                    const targetEntitySet = associationEndEntitySets.find(associationEntitySet => (associationEntitySet === null || associationEntitySet === void 0 ? void 0 : associationEntitySet.fullyQualifiedName) !== entitySet.fullyQualifiedName);
                    if (targetEntitySet) {
                        entitySet.navigationPropertyBinding[navProp.name] = targetEntitySet;
                    }
                }
            });
        });
    parseAnnotationLists(utils_1.ensureArray(edmSchema.Annotations), annotations);
    var annotationMap = {};
    annotationMap[identification] = annotations;
    return {
        associations,
        annotations: annotationMap,
        entityContainer,
        namespace: namespace,
        entitySets,
        complexTypes,
        actions,
        entityTypes
    };
}
function parseReferences(references, schema) {
    const outReferences = references.reduce((referencesArray, reference) => {
        const includes = utils_1.ensureArray(reference["edmx:Include"]);
        includes.forEach((include) => {
            referencesArray.push({
                uri: reference._attributes.Uri,
                alias: include._attributes.Alias,
                namespace: include._attributes.Namespace
            });
        });
        return referencesArray;
    }, []);
    if (schema && schema._attributes.Alias) {
        outReferences.push({
            uri: "",
            alias: schema._attributes.Alias,
            namespace: schema._attributes.Namespace
        });
    }
    return outReferences;
}
let referenceMap = {};
function unalias(aliasedValue) {
    if (!aliasedValue) {
        return aliasedValue;
    }
    const [alias, value] = aliasedValue.split(".");
    const reference = referenceMap[alias];
    if (reference) {
        return `${reference.namespace}.${value}`;
    }
    else {
        // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
        if (aliasedValue.indexOf("@") !== -1) {
            const [preAlias, postAlias] = aliasedValue.split("@");
            return `${preAlias}@${unalias(postAlias)}`;
        }
        else {
            return aliasedValue;
        }
    }
}
/**
 * Parse an edmx file and return a parsed Service Definition
 * @param xml {string} the original XML string
 * @param fileIdentification {string} a way to identify this file
 */
function parseEDMX(xml, fileIdentification = "serviceFile") {
    const jsonObj = xml_js_1.xml2js(xml, { compact: true });
    const references = parseReferences(utils_1.ensureArray(jsonObj["edmx:Edmx"]["edmx:Reference"]), jsonObj["edmx:Edmx"]["edmx:DataServices"].Schema);
    referenceMap = references.reduce((map, reference) => {
        map[reference.alias] = reference;
        return map;
    }, {});
    const edmxDocument = new utils_1.ParserOutputInstance(fileIdentification, jsonObj["edmx:Edmx"]._attributes.Version, parseSchema(jsonObj["edmx:Edmx"]["edmx:DataServices"].Schema, fileIdentification), references);
    return edmxDocument;
}
exports.parseEDMX = parseEDMX;
