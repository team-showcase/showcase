"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergedParserOutput = exports.ParserOutputInstance = exports.ensureArray = void 0;
function ensureArray(sourceObject) {
    if (sourceObject === undefined || sourceObject === null) {
        return [];
    }
    if (Array.isArray(sourceObject)) {
        return sourceObject;
    }
    else {
        return [sourceObject];
    }
}
exports.ensureArray = ensureArray;
class ParserOutputInstance {
    constructor(fileIdentification, version, schema, references) {
        this.identification = fileIdentification;
        this.references = references;
        this.version = version;
        this.schema = schema;
    }
    unalias(aliasedValue) {
        if (!aliasedValue) {
            return aliasedValue;
        }
        const [alias, value] = aliasedValue.split(".");
        const reference = this.references.find(reference => {
            return reference.alias === alias;
        });
        if (reference) {
            return `${reference.namespace}.${value}`;
        }
        else {
            // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
            if (aliasedValue.indexOf("@") !== -1) {
                const [preAlias, postAlias] = aliasedValue.split("@");
                return `${preAlias}@${this.unalias(postAlias)}`;
            }
            else {
                return aliasedValue;
            }
        }
    }
}
exports.ParserOutputInstance = ParserOutputInstance;
class MergedParserOutput {
    constructor(initialParserOutput) {
        this._references = [];
        this._parserOutput = [];
        this._annotations = {};
        this._associations = [];
        this._entitySets = [];
        this._actions = [];
        this._entityContainer = {};
        this._entityTypes = [];
        this._complexTypes = [];
        this.identification = "mergedParserInstance";
        this.version = initialParserOutput.version;
        this._namespace = initialParserOutput.schema.namespace;
    }
    get references() {
        return this._references;
    }
    get schema() {
        return {
            associations: this._associations,
            annotations: this._annotations,
            entityContainer: this._entityContainer,
            namespace: this._namespace,
            entitySets: this._entitySets,
            complexTypes: this._complexTypes,
            actions: this._actions,
            entityTypes: this._entityTypes
        };
    }
    addParserOutput(parserOutput) {
        this._parserOutput.push(parserOutput);
        this._references = this._references.concat(parserOutput.references);
        this._associations = this._associations.concat(parserOutput.schema.associations);
        this._annotations = Object.assign(this._annotations, parserOutput.schema.annotations);
        this._entitySets = this._entitySets.concat(parserOutput.schema.entitySets);
        this._actions = this._actions.concat(parserOutput.schema.actions);
        this._entityTypes = this._entityTypes.concat(parserOutput.schema.entityTypes);
        this._complexTypes = this._complexTypes.concat(parserOutput.schema.complexTypes);
        this._entityContainer = Object.assign(this._entityContainer, parserOutput.schema.entityContainer);
    }
    unalias(aliasedValue) {
        if (!aliasedValue) {
            return aliasedValue;
        }
        const [alias, value] = aliasedValue.split(".");
        const reference = this.references.find(reference => {
            return reference.alias === alias;
        });
        if (reference) {
            return `${reference.namespace}.${value}`;
        }
        else {
            // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
            if (aliasedValue.indexOf("@") !== -1) {
                const [preAlias, postAlias] = aliasedValue.split("@");
                return `${preAlias}@${this.unalias(postAlias)}`;
            }
            else {
                return aliasedValue;
            }
        }
    }
}
exports.MergedParserOutput = MergedParserOutput;
