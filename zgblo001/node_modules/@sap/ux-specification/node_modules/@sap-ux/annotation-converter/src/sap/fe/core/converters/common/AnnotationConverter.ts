import {
	Annotation as EdmAnnotation,
	AnnotationList,
	AnnotationRecord,
	AnnotationTerm,
	ConverterOutput,
	Expression,
	ParserOutput,
	PathExpression,
	PropertyPath,
	PropertyValue,
	AnnotationPathExpression,
	NavigationPropertyPathExpression,
	PropertyPathExpression
} from "@sap-ux/vocabularies-types";
import {
	Association,
	GenericNavigationProperty,
	Reference,
	Property as ParserProperty,
	EntityType as ParserEntityType,
	ComplexType as ParserComplexType,
	V2NavigationProperty,
	V4NavigationProperty
} from "@sap-ux/vocabularies-types/dist/Parser";
import {
	Annotation,
	EntityType,
	ComplexType,
	Action,
	EntitySet,
	Property,
	NavigationProperty
} from "@sap-ux/vocabularies-types/dist/Converter";

class Path {
	path: string;
	$target: string;
	type: string;

	constructor(pathExpression: PathExpression, targetName: string) {
		this.path = pathExpression.Path;
		this.type = "Path";
		this.$target = targetName;
	}
}

export const defaultReferences: ReferencesWithMap = [
	{ alias: "Capabilities", namespace: "Org.OData.Capabilities.V1", uri: "" },
	{ alias: "Aggregation", namespace: "Org.OData.Aggregation.V1", uri: "" },
	{ alias: "Validation", namespace: "Org.OData.Validation.V1", uri: "" },
	{ namespace: "Org.OData.Core.V1", alias: "Core", uri: "" },
	{ namespace: "Org.OData.Measures.V1", alias: "Measures", uri: "" },
	{ namespace: "com.sap.vocabularies.Common.v1", alias: "Common", uri: "" },
	{ namespace: "com.sap.vocabularies.UI.v1", alias: "UI", uri: "" },
	{ namespace: "com.sap.vocabularies.Session.v1", alias: "Session", uri: "" },
	{ namespace: "com.sap.vocabularies.Analytics.v1", alias: "Analytics", uri: "" },
	{ namespace: "com.sap.vocabularies.CodeList.v1", alias: "CodeList", uri: "" },
	{ namespace: "com.sap.vocabularies.PersonalData.v1", alias: "PersonalData", uri: "" },
	{ namespace: "com.sap.vocabularies.Communication.v1", alias: "Communication", uri: "" },
	{ namespace: "com.sap.vocabularies.HTML5.v1", alias: "HTML5", uri: "" }
];

type ReferencesWithMap = Reference[] & {
	referenceMap?: Record<string, Reference>;
	reverseReferenceMap?: Record<string, Reference>;
};

function alias(references: ReferencesWithMap, unaliasedValue: string): string {
	if (!references.reverseReferenceMap) {
		references.reverseReferenceMap = references.reduce((map: Record<string, Reference>, reference) => {
			map[reference.namespace] = reference;
			return map;
		}, {});
	}
	if (!unaliasedValue) {
		return unaliasedValue;
	}
	const lastDotIndex = unaliasedValue.lastIndexOf(".");
	const namespace = unaliasedValue.substr(0, lastDotIndex);
	const value = unaliasedValue.substr(lastDotIndex + 1);
	const reference = references.reverseReferenceMap[namespace];
	if (reference) {
		return `${reference.alias}.${value}`;
	} else {
		// Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
		if (unaliasedValue.indexOf("@") !== -1) {
			const [preAlias, postAlias] = unaliasedValue.split("@");
			return `${preAlias}@${alias(references, postAlias)}`;
		} else {
			return unaliasedValue;
		}
	}
}

function unalias(references: ReferencesWithMap, aliasedValue: string | undefined): string | undefined {
	if (!references.referenceMap) {
		references.referenceMap = references.reduce((map: Record<string, Reference>, reference) => {
			map[reference.alias] = reference;
			return map;
		}, {});
	}
	if (!aliasedValue) {
		return aliasedValue;
	}
	const [alias, value] = aliasedValue.split(".");
	const reference = references.referenceMap[alias];
	if (reference) {
		return `${reference.namespace}.${value}`;
	} else {
		// Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
		if (aliasedValue.indexOf("@") !== -1) {
			const [preAlias, postAlias] = aliasedValue.split("@");
			return `${preAlias}@${unalias(references, postAlias)}`;
		} else {
			return aliasedValue;
		}
	}
}

function buildObjectMap(parserOutput: ParserOutput): Record<string, any> {
	const objectMap: any = {};
	if (parserOutput.schema.entityContainer && parserOutput.schema.entityContainer.fullyQualifiedName) {
		objectMap[parserOutput.schema.entityContainer.fullyQualifiedName] = parserOutput.schema.entityContainer;
	}
	parserOutput.schema.entitySets.forEach(entitySet => {
		objectMap[entitySet.fullyQualifiedName] = entitySet;
	});
	parserOutput.schema.actions.forEach(action => {
		objectMap[action.fullyQualifiedName] = action;
		objectMap[action.fullyQualifiedName.split("(")[0]] = action;
		action.parameters.forEach(parameter => {
			objectMap[parameter.fullyQualifiedName] = parameter;
		});
	});
	parserOutput.schema.complexTypes.forEach(complexType => {
		objectMap[complexType.fullyQualifiedName] = complexType;
		complexType.properties.forEach(property => {
			objectMap[property.fullyQualifiedName] = property;
		});
	});
	parserOutput.schema.entityTypes.forEach(entityType => {
		objectMap[entityType.fullyQualifiedName] = entityType;
		entityType.entityProperties.forEach(property => {
			objectMap[property.fullyQualifiedName] = property;
			if (property.type.indexOf("Edm") === -1) {
				// Handle complex types
				const complexTypeDefinition = objectMap[property.type] as ComplexType;
				if (complexTypeDefinition && complexTypeDefinition.properties) {
					complexTypeDefinition.properties.forEach(complexTypeProp => {
						const complexTypePropTarget: ParserProperty = Object.assign(complexTypeProp, {
							_type: "Property",
							fullyQualifiedName: property.fullyQualifiedName + "/" + complexTypeProp.name
						});
						objectMap[complexTypePropTarget.fullyQualifiedName] = complexTypePropTarget;
					});
				}
			}
		});
		entityType.navigationProperties.forEach(navProperty => {
			objectMap[navProperty.fullyQualifiedName] = navProperty;
		});
	});

	Object.keys(parserOutput.schema.annotations).forEach(annotationSource => {
		parserOutput.schema.annotations[annotationSource].forEach(annotationList => {
			const currentTargetName = unalias(parserOutput.references, annotationList.target);
			annotationList.annotations.forEach(annotation => {
				let annotationFQN = `${currentTargetName}@${unalias(parserOutput.references, annotation.term)}`;
				if (annotation.qualifier) {
					annotationFQN += `#${annotation.qualifier}`;
				}
				objectMap[annotationFQN] = annotation;
				(annotation as Annotation).fullyQualifiedName = annotationFQN;
			});
		});
	});
	return objectMap;
}

function combinePath(currentTarget: string, path: string): string {
	if (path.startsWith("@")) {
		return currentTarget + unalias(defaultReferences, path);
	} else {
		return currentTarget + "/" + path;
	}
}

function resolveTarget(
	objectMap: any,
	currentTarget: any,
	path: string,
	pathOnly: boolean = false,
	includeVisitedObjects: boolean = false
) {
	if (!path) {
		return undefined;
	}
	const aVisitedObjects: any[] = [];
	path = combinePath(currentTarget.fullyQualifiedName, path);

	const pathSplit = path.split("/");
	let currentPath = path;
	const target = pathSplit.reduce((currentValue: any, pathPart) => {
		if (pathPart.length === 0) {
			return currentValue;
		}
		if (includeVisitedObjects && currentValue !== null) {
			aVisitedObjects.push(currentValue);
		}
		if (!currentValue) {
			currentPath = pathPart;
		} else if (currentValue._type === "EntitySet" && currentValue.entityType) {
			currentPath = combinePath(currentValue.entityTypeName, pathPart);
		} else if (currentValue._type === "NavigationProperty" && currentValue.targetTypeName) {
			currentPath = combinePath(currentValue.targetTypeName, pathPart);
		} else if (currentValue._type === "NavigationProperty" && currentValue.targetType) {
			currentPath = combinePath(currentValue.targetType.fullyQualifiedName, pathPart);
		} else if (currentValue._type === "Property") {
			if (currentValue.type.indexOf("Edm") === -1) {
				// This is a complex type
				currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
			} else {
				currentPath = combinePath(
					currentTarget.fullyQualifiedName.substr(0, currentTarget.fullyQualifiedName.lastIndexOf("/")),
					pathPart
				);
			}
		} else if (currentValue._type === "Action" && currentValue.isBound) {
			currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
			if (!objectMap[currentPath]) {
				currentPath = combinePath(currentValue.sourceType, pathPart);
			}
		} else if (currentValue._type === "ActionParameter" && currentValue.isEntitySet) {
			currentPath = combinePath(currentValue.type, pathPart);
		} else if (currentValue._type === "ActionParameter" && !currentValue.isEntitySet) {
			currentPath = combinePath(
				currentTarget.fullyQualifiedName.substr(0, currentTarget.fullyQualifiedName.lastIndexOf("/")),
				pathPart
			);
			if (!objectMap[currentPath]) {
				let lastIdx = currentTarget.fullyQualifiedName.lastIndexOf("/");
				if (lastIdx === -1) {
					lastIdx = currentTarget.fullyQualifiedName.length;
				}
				currentPath = combinePath(
					(objectMap[currentTarget.fullyQualifiedName.substr(0, lastIdx)] as Action).sourceType,
					pathPart
				);
			}
		} else {
			currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
			if (currentValue[pathPart] !== undefined) {
				return currentValue[pathPart];
			} else if (pathPart === "$AnnotationPath" && currentValue.$target) {
				return currentValue.$target;
			} else if (currentValue.hasOwnProperty("$Type")) {
				// This is now an annotation value
				const entityType = objectMap[currentValue.fullyQualifiedName.split("@")[0]];
				if (entityType) {
					currentPath = combinePath(entityType.fullyQualifiedName, pathPart);
				}
			}
		}
		return objectMap[currentPath];
	}, null);
	if (!target) {
		ANNOTATION_ERRORS.push({ message: "Unable to resolve the path expression " + path });
		// console.log("Missing target " + path);
	}
	if (pathOnly) {
		return currentPath;
	}
	if (includeVisitedObjects) {
		return {
			visitedObjects: aVisitedObjects,
			target: target
		};
	}
	return target;
}

function isAnnotationPath(pathStr: string): boolean {
	return pathStr.indexOf("@") !== -1;
}

function parseValue(
	propertyValue: Expression,
	valueFQN: string,
	parserOutput: ParserOutput,
	currentTarget: any,
	objectMap: any,
	toResolve: Resolveable[],
	annotationSource: string,
	unresolvedAnnotations: AnnotationList[]
) {
	if (propertyValue === undefined) {
		return undefined;
	}
	switch (propertyValue.type) {
		case "String":
			return propertyValue.String;
		case "Int":
			return propertyValue.Int;
		case "Bool":
			return propertyValue.Bool;
		case "Decimal":
			return propertyValue.Decimal;
		case "Date":
			return propertyValue.Date;
		case "EnumMember":
			return alias(parserOutput.references, propertyValue.EnumMember);
		case "PropertyPath":
			return {
				type: "PropertyPath",
				value: propertyValue.PropertyPath,
				fullyQualifiedName: valueFQN,
				$target: resolveTarget(objectMap, currentTarget, propertyValue.PropertyPath)
			};
		case "NavigationPropertyPath":
			return {
				type: "NavigationPropertyPath",
				value: propertyValue.NavigationPropertyPath,
				fullyQualifiedName: valueFQN,
				$target: resolveTarget(objectMap, currentTarget, propertyValue.NavigationPropertyPath)
			};
		case "AnnotationPath":
			const annotationTarget = resolveTarget(
				objectMap,
				currentTarget,
				unalias(parserOutput.references, propertyValue.AnnotationPath) as string,
				true
			);
			const annotationPath = {
				type: "AnnotationPath",
				value: propertyValue.AnnotationPath,
				fullyQualifiedName: valueFQN,
				$target: annotationTarget
			};
			toResolve.push(annotationPath);
			return annotationPath;
		case "Path":
			if (isAnnotationPath(propertyValue.Path)) {
				// If it's an anntoation that we can resolve, resolve it !
				const $target = resolveTarget(objectMap, currentTarget, propertyValue.Path);
				if ($target) {
					return $target;
				}
			}
			const $target = resolveTarget(objectMap, currentTarget, propertyValue.Path, true);
			const path = new Path(propertyValue, $target);
			toResolve.push(path);
			return path;

		case "Record":
			return parseRecord(
				propertyValue.Record,
				valueFQN,
				parserOutput,
				currentTarget,
				objectMap,
				toResolve,
				annotationSource,
				unresolvedAnnotations
			);
		case "Collection":
			return parseCollection(
				propertyValue.Collection,
				valueFQN,
				parserOutput,
				currentTarget,
				objectMap,
				toResolve,
				annotationSource,
				unresolvedAnnotations
			);
		case "Apply":
		case "If":
			return propertyValue;
	}
}

function parseRecord(
	recordDefinition: AnnotationRecord,
	currentFQN: string,
	parserOutput: ParserOutput,
	currentTarget: any,
	objectMap: any,
	toResolve: Resolveable[],
	annotationSource: string,
	unresolvedAnnotations: AnnotationList[]
) {
	const annotationTerm: any = {
		$Type: unalias(parserOutput.references, recordDefinition.type),
		fullyQualifiedName: currentFQN
	};
	const annotationContent: any = {};
	if (recordDefinition.annotations && Array.isArray(recordDefinition.annotations)) {
		const subAnnotationList = {
			target: currentFQN,
			annotations: recordDefinition.annotations,
			__source: annotationSource
		};
		unresolvedAnnotations.push(subAnnotationList);
	}
	recordDefinition.propertyValues.forEach((propertyValue: PropertyValue) => {
		annotationContent[propertyValue.name] = parseValue(
			propertyValue.value,
			`${currentFQN}/${propertyValue.name}`,
			parserOutput,
			currentTarget,
			objectMap,
			toResolve,
			annotationSource,
			unresolvedAnnotations
		);
		if (propertyValue.annotations && Array.isArray(propertyValue.annotations)) {
			const subAnnotationList = {
				target: `${currentFQN}/${propertyValue.name}`,
				annotations: propertyValue.annotations,
				__source: annotationSource
			};
			unresolvedAnnotations.push(subAnnotationList);
		}
		if (
			annotationContent.hasOwnProperty("Action") &&
			(annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" ||
				annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldWithAction")
		) {
			if (currentTarget.actions) {
				annotationContent.ActionTarget =
					currentTarget.actions[annotationContent.Action] || objectMap[annotationContent.Action];
				if (!annotationContent.ActionTarget) {
					// Add to diagnostics debugger;
					ANNOTATION_ERRORS.push({
						message:
							"Unable to resolve the action " +
							annotationContent.Action +
							" defined for " +
							annotationTerm.fullyQualifiedName
					});
				}
			}
		}
	});
	return Object.assign(annotationTerm, annotationContent);
}

export type CollectionType =
	| "PropertyPath"
	| "Path"
	| "AnnotationPath"
	| "NavigationPropertyPath"
	| "Record"
	| "String"
	| "EmptyCollection";

function getOrInferCollectionType(collectionDefinition: any[]): CollectionType {
	let type: CollectionType = (collectionDefinition as any).type;
	if (type === undefined && collectionDefinition.length > 0) {
		const firstColItem = collectionDefinition[0];
		if (firstColItem.hasOwnProperty("PropertyPath")) {
			type = "PropertyPath";
		} else if (firstColItem.hasOwnProperty("Path")) {
			type = "Path";
		} else if (firstColItem.hasOwnProperty("AnnotationPath")) {
			type = "AnnotationPath";
		} else if (firstColItem.hasOwnProperty("NavigationPropertyPath")) {
			type = "NavigationPropertyPath";
		} else if (
			typeof firstColItem === "object" &&
			(firstColItem.hasOwnProperty("type") || firstColItem.hasOwnProperty("propertyValues"))
		) {
			type = "Record";
		} else if (typeof firstColItem === "string") {
			type = "String";
		}
	} else if (type === undefined) {
		type = "EmptyCollection";
	}
	return type;
}

function parseCollection(
	collectionDefinition: any[],
	parentFQN: string,
	parserOutput: ParserOutput,
	currentTarget: any,
	objectMap: any,
	toResolve: Resolveable[],
	annotationSource: string,
	unresolvedAnnotations: AnnotationList[]
) {
	const collectionDefinitionType = getOrInferCollectionType(collectionDefinition);
	switch (collectionDefinitionType) {
		case "PropertyPath":
			return collectionDefinition.map((propertyPath, propertyIdx) => {
				return {
					type: "PropertyPath",
					value: propertyPath.PropertyPath,
					fullyQualifiedName: `${parentFQN}/${propertyIdx}`,
					$target: resolveTarget(objectMap, currentTarget, propertyPath.PropertyPath)
				};
			});
		case "Path":
			return collectionDefinition.map(pathValue => {
				if (isAnnotationPath(pathValue.Path)) {
					// If it's an anntoation that we can resolve, resolve it !
					const $target = resolveTarget(objectMap, currentTarget, pathValue.Path);
					if ($target) {
						return $target;
					}
				}
				const $target = resolveTarget(objectMap, currentTarget, pathValue.Path, true);
				const path = new Path(pathValue, $target);
				toResolve.push(path);
				return path;
			});
		case "AnnotationPath":
			return collectionDefinition.map((annotationPath, annotationIdx) => {
				const annotationTarget = resolveTarget(objectMap, currentTarget, annotationPath.AnnotationPath, true);
				const annotationCollectionElement = {
					type: "AnnotationPath",
					value: annotationPath.AnnotationPath,
					fullyQualifiedName: `${parentFQN}/${annotationIdx}`,
					$target: annotationTarget
				};
				toResolve.push(annotationCollectionElement);
				return annotationCollectionElement;
			});
		case "NavigationPropertyPath":
			return collectionDefinition.map((navPropertyPath, navPropIdx) => {
				return {
					type: "NavigationPropertyPath",
					value: navPropertyPath.NavigationPropertyPath,
					fullyQualifiedName: `${parentFQN}/${navPropIdx}`,
					$target: resolveTarget(objectMap, currentTarget, navPropertyPath.NavigationPropertyPath)
				};
			});
		case "Record":
			return collectionDefinition.map((recordDefinition, recordIdx) => {
				return parseRecord(
					recordDefinition,
					`${parentFQN}/${recordIdx}`,
					parserOutput,
					currentTarget,
					objectMap,
					toResolve,
					annotationSource,
					unresolvedAnnotations
				);
			});
		case "String":
			return collectionDefinition.map(stringValue => {
				return stringValue;
			});
		default:
			if (collectionDefinition.length === 0) {
				return [];
			}
			throw new Error("Unsupported case");
	}
}

type Resolveable = {
	$target: string;
	targetString?: string;
};

function convertAnnotation(
	annotation: Annotation,
	parserOutput: ParserOutput,
	currentTarget: any,
	objectMap: any,
	toResolve: Resolveable[],
	annotationSource: string,
	unresolvedAnnotations: AnnotationList[]
): any {
	if (annotation.record) {
		const annotationTerm: any = {
			$Type: unalias(parserOutput.references, annotation.record.type),
			fullyQualifiedName: annotation.fullyQualifiedName,
			qualifier: annotation.qualifier
		};
		const annotationContent: any = {};
		annotation.record.propertyValues.forEach((propertyValue: PropertyValue) => {
			annotationContent[propertyValue.name] = parseValue(
				propertyValue.value,
				`${annotation.fullyQualifiedName}/${propertyValue.name}`,
				parserOutput,
				currentTarget,
				objectMap,
				toResolve,
				annotationSource,
				unresolvedAnnotations
			);
			if (
				annotationContent.hasOwnProperty("Action") &&
				(!annotation.record ||
					annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" ||
					annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldWithAction")
			) {
				if (currentTarget.actions) {
					annotationContent.ActionTarget =
						currentTarget.actions[annotationContent.Action] || objectMap[annotationContent.Action];
					if (!annotationContent.ActionTarget) {
						ANNOTATION_ERRORS.push({
							message:
								"Unable to resolve the action " +
								annotationContent.Action +
								" defined for " +
								annotation.fullyQualifiedName
						});
						// Add to diagnostics
						// debugger;
					}
				}
			}
		});
		return Object.assign(annotationTerm, annotationContent);
	} else if (annotation.collection === undefined) {
		if (annotation.value) {
			return parseValue(
				annotation.value,
				annotation.fullyQualifiedName,
				parserOutput,
				currentTarget,
				objectMap,
				toResolve,
				annotationSource,
				unresolvedAnnotations
			);
		} else {
			return true;
		}
	} else if (annotation.collection) {
		const collection: any = parseCollection(
			annotation.collection,
			annotation.fullyQualifiedName,
			parserOutput,
			currentTarget,
			objectMap,
			toResolve,
			annotationSource,
			unresolvedAnnotations
		);
		collection.fullyQualifiedName = annotation.fullyQualifiedName;
		return collection;
	} else {
		throw new Error("Unsupported case");
	}
}

function createResolvePathFn(entityType: EntityType, objectMap: Record<string, any>) {
	return function(relativePath: string, includeVisitedObjects: boolean): any {
		return resolveTarget(objectMap, entityType, relativePath, false, includeVisitedObjects);
	};
}

function resolveNavigationProperties(
	entityTypes: ParserEntityType[],
	associations: Association[],
	objectMap: Record<string, any>
): void {
	entityTypes.forEach(entityType => {
		entityType.navigationProperties = entityType.navigationProperties.map(navProp => {
			const outNavProp: Partial<NavigationProperty> = {
				_type: "NavigationProperty",
				name: navProp.name,
				fullyQualifiedName: navProp.fullyQualifiedName,
				partner: (navProp as any).hasOwnProperty("partner") ? (navProp as any).partner : undefined,
				// targetTypeName: FullyQualifiedName;
				// targetType: EntityType;
				isCollection: (navProp as any).hasOwnProperty("isCollection") ? (navProp as any).isCollection : false,
				containsTarget: (navProp as any).hasOwnProperty("containsTarget")
					? (navProp as any).containsTarget
					: false,
				referentialConstraint: (navProp as any).referentialConstraint
					? (navProp as any).referentialConstraint
					: []
			};
			if ((navProp as GenericNavigationProperty).targetTypeName) {
				outNavProp.targetType = objectMap[(navProp as V4NavigationProperty).targetTypeName];
			} else if ((navProp as V2NavigationProperty).relationship) {
				const targetAssociation = associations.find(
					association => association.fullyQualifiedName === (navProp as V2NavigationProperty).relationship
				);
				if (targetAssociation) {
					const associationEnd = targetAssociation.associationEnd.find(
						end => end.role === (navProp as V2NavigationProperty).toRole
					);
					if (associationEnd) {
						outNavProp.targetType = objectMap[associationEnd.type];
						outNavProp.isCollection = associationEnd.multiplicity === "*";
					}
				}
			}
			if (outNavProp.targetType) {
				outNavProp.targetTypeName = outNavProp.targetType.fullyQualifiedName;
			}
			const outNavPropReq = outNavProp as NavigationProperty;
			objectMap[outNavPropReq.fullyQualifiedName] = outNavPropReq;
			return outNavPropReq;
		});
		(entityType as EntityType).resolvePath = createResolvePathFn(entityType as EntityType, objectMap);
	});
}

function linkActionsToEntityType(namespace: string, actions: Action[], objectMap: Record<string, any>): void {
	actions.forEach(action => {
		if (action.isBound) {
			const sourceEntityType = objectMap[action.sourceType];
			action.sourceEntityType = sourceEntityType;
			if (sourceEntityType) {
				if (!sourceEntityType.actions) {
					sourceEntityType.actions = {};
				}
				sourceEntityType.actions[action.name] = action;
				sourceEntityType.actions[`${namespace}.${action.name}`] = action;
			}
			action.returnEntityType = objectMap[action.returnType];
		}
	});
}

function linkEntityTypeToEntitySet(entitySets: EntitySet[], objectMap: Record<string, any>): void {
	entitySets.forEach(entitySet => {
		entitySet.entityType = objectMap[entitySet.entityTypeName];
		if (!entitySet.annotations) {
			entitySet.annotations = {};
		}
		if (!entitySet.entityType.annotations) {
			entitySet.entityType.annotations = {};
		}
		entitySet.entityType.keys.forEach((keyProp: Property) => {
			keyProp.isKey = true;
		});
	});
}

function linkPropertiesToComplexTypes(entityTypes: EntityType[], objectMap: Record<string, any>) {
	entityTypes.forEach(entityType => {
		entityType.entityProperties.forEach(entityProperty => {
			if (entityProperty.type.indexOf("Edm") === -1) {
				const complexType = objectMap[entityProperty.type] as ComplexType;
				if (complexType) {
					(entityProperty as Property).targetType = complexType;
				}
			}
		});
	});
}

function prepareComplexTypes(
	complexTypes: ParserComplexType[],
	associations: Association[],
	objectMap: Record<string, any>
) {
	complexTypes.forEach(complexType => {
		(complexType as ComplexType).annotations = {};
		complexType.properties.forEach(property => {
			if (!(property as Property).annotations) {
				(property as Property).annotations = {};
			}
		});
		complexType.navigationProperties = complexType.navigationProperties.map(navProp => {
			if (!(navProp as NavigationProperty).annotations) {
				(navProp as NavigationProperty).annotations = {};
			}
			const outNavProp: Partial<NavigationProperty> = {
				_type: "NavigationProperty",
				name: navProp.name,
				fullyQualifiedName: navProp.fullyQualifiedName,
				partner: (navProp as any).hasOwnProperty("partner") ? (navProp as any).partner : undefined,
				// targetTypeName: FullyQualifiedName;
				// targetType: EntityType;
				isCollection: (navProp as any).hasOwnProperty("isCollection") ? (navProp as any).isCollection : false,
				containsTarget: (navProp as any).hasOwnProperty("containsTarget")
					? (navProp as any).containsTarget
					: false,
				referentialConstraint: (navProp as any).referentialConstraint
					? (navProp as any).referentialConstraint
					: []
			};
			if ((navProp as GenericNavigationProperty).targetTypeName) {
				outNavProp.targetType = objectMap[(navProp as V4NavigationProperty).targetTypeName];
			} else if ((navProp as V2NavigationProperty).relationship) {
				const targetAssociation = associations.find(
					association => association.fullyQualifiedName === (navProp as V2NavigationProperty).relationship
				);
				if (targetAssociation) {
					const associationEnd = targetAssociation.associationEnd.find(
						end => end.role === (navProp as V2NavigationProperty).toRole
					);
					if (associationEnd) {
						outNavProp.targetType = objectMap[associationEnd.type];
						outNavProp.isCollection = associationEnd.multiplicity === "*";
					}
				}
			}
			if (outNavProp.targetType) {
				outNavProp.targetTypeName = outNavProp.targetType.fullyQualifiedName;
			}
			const outNavPropReq = outNavProp as NavigationProperty;
			objectMap[outNavPropReq.fullyQualifiedName] = outNavPropReq;
			return outNavPropReq;
		});
	});
}

function splitTerm(references: ReferencesWithMap, termValue: string) {
	const aliasedTerm = alias(references, termValue);
	const lastDot = aliasedTerm.lastIndexOf(".");
	let termAlias = aliasedTerm.substr(0, lastDot);
	let term = aliasedTerm.substr(lastDot + 1);
	return [termAlias, term];
}

let ANNOTATION_ERRORS: { message: string }[] = [];
export function convertTypes(parserOutput: ParserOutput): ConverterOutput {
	ANNOTATION_ERRORS = [];
	const objectMap = buildObjectMap(parserOutput);
	resolveNavigationProperties(
		parserOutput.schema.entityTypes as EntityType[],
		parserOutput.schema.associations,
		objectMap
	);
	linkActionsToEntityType(parserOutput.schema.namespace, parserOutput.schema.actions as Action[], objectMap);
	linkEntityTypeToEntitySet(parserOutput.schema.entitySets as EntitySet[], objectMap);
	linkPropertiesToComplexTypes(parserOutput.schema.entityTypes as EntityType[], objectMap);
	prepareComplexTypes(parserOutput.schema.complexTypes as ComplexType[], parserOutput.schema.associations, objectMap);
	const toResolve: Resolveable[] = [];
	const unresolvedAnnotations: AnnotationList[] = [];
	Object.keys(parserOutput.schema.annotations).forEach(annotationSource => {
		parserOutput.schema.annotations[annotationSource].forEach(annotationList => {
			const currentTargetName = unalias(parserOutput.references, annotationList.target) as string;
			const currentTarget = objectMap[currentTargetName];
			if (!currentTarget) {
				if (currentTargetName.indexOf("@") !== -1) {
					(annotationList as any).__source = annotationSource;
					unresolvedAnnotations.push(annotationList);
				}
			} else if (typeof currentTarget === "object") {
				if (!currentTarget.annotations) {
					currentTarget.annotations = {};
				}
				annotationList.annotations.forEach(annotation => {
					const [vocAlias, vocTerm] = splitTerm(defaultReferences, annotation.term);
					if (!currentTarget.annotations[vocAlias]) {
						currentTarget.annotations[vocAlias] = {};
					}
					if (!currentTarget.annotations._annotations) {
						currentTarget.annotations._annotations = {};
					}

					const vocTermWithQualifier = `${vocTerm}${annotation.qualifier ? `#${annotation.qualifier}` : ""}`;
					currentTarget.annotations[vocAlias][vocTermWithQualifier] = convertAnnotation(
						annotation as Annotation,
						parserOutput,
						currentTarget,
						objectMap,
						toResolve,
						annotationSource,
						unresolvedAnnotations
					);
					if (
						currentTarget.annotations[vocAlias][vocTermWithQualifier] !== null &&
						typeof currentTarget.annotations[vocAlias][vocTermWithQualifier] === "object"
					) {
						currentTarget.annotations[vocAlias][vocTermWithQualifier].term = unalias(
							defaultReferences,
							`${vocAlias}.${vocTerm}`
						);
						currentTarget.annotations[vocAlias][vocTermWithQualifier].qualifier = annotation.qualifier;
						currentTarget.annotations[vocAlias][vocTermWithQualifier].__source = annotationSource;
					}
					const annotationTarget = `${currentTargetName}@${unalias(
						defaultReferences,
						vocAlias + "." + vocTermWithQualifier
					)}`;
					if (annotation.annotations && Array.isArray(annotation.annotations)) {
						const subAnnotationList = {
							target: annotationTarget,
							annotations: annotation.annotations,
							__source: annotationSource
						};
						unresolvedAnnotations.push(subAnnotationList);
					}
					currentTarget.annotations._annotations[`${vocAlias}.${vocTermWithQualifier}`] =
						currentTarget.annotations[vocAlias][vocTermWithQualifier];
					objectMap[annotationTarget] = currentTarget.annotations[vocAlias][vocTermWithQualifier];
				});
			}
		});
	});
	const extraUnresolvedAnnotations: AnnotationList[] = [];
	unresolvedAnnotations.forEach(annotationList => {
		const currentTargetName = unalias(parserOutput.references, annotationList.target) as string;
		let [baseObj, annotationPart] = currentTargetName.split("@");
		const targetSplit = annotationPart.split("/");
		baseObj = baseObj + "@" + targetSplit[0];
		const currentTarget = targetSplit.slice(1).reduce((currentObj, path) => {
			if (!currentObj) {
				return null;
			}
			return currentObj[path];
		}, objectMap[baseObj]);
		if (!currentTarget) {
			ANNOTATION_ERRORS.push({
				message: "The following annotation target was not found on the service " + currentTargetName
			});
			// console.log("Missing target again " + currentTargetName);
		} else if (typeof currentTarget === "object") {
			if (!currentTarget.annotations) {
				currentTarget.annotations = {};
			}
			annotationList.annotations.forEach(annotation => {
				const [vocAlias, vocTerm] = splitTerm(defaultReferences, annotation.term);
				if (!currentTarget.annotations[vocAlias]) {
					currentTarget.annotations[vocAlias] = {};
				}
				if (!currentTarget.annotations._annotations) {
					currentTarget.annotations._annotations = {};
				}

				const vocTermWithQualifier = `${vocTerm}${annotation.qualifier ? `#${annotation.qualifier}` : ""}`;
				currentTarget.annotations[vocAlias][vocTermWithQualifier] = convertAnnotation(
					annotation as Annotation,
					parserOutput,
					currentTarget,
					objectMap,
					toResolve,
					(annotationList as any).__source,
					extraUnresolvedAnnotations
				);
				if (
					currentTarget.annotations[vocAlias][vocTermWithQualifier] !== null &&
					typeof currentTarget.annotations[vocAlias][vocTermWithQualifier] === "object"
				) {
					currentTarget.annotations[vocAlias][vocTermWithQualifier].term = unalias(
						defaultReferences,
						`${vocAlias}.${vocTerm}`
					);
					currentTarget.annotations[vocAlias][vocTermWithQualifier].qualifier = annotation.qualifier;
					currentTarget.annotations[vocAlias][
						vocTermWithQualifier
					].__source = (annotationList as any).__source;
				}
				currentTarget.annotations._annotations[`${vocAlias}.${vocTermWithQualifier}`] =
					currentTarget.annotations[vocAlias][vocTermWithQualifier];
				objectMap[`${currentTargetName}@${unalias(defaultReferences, vocAlias + "." + vocTermWithQualifier)}`] =
					currentTarget.annotations[vocAlias][vocTermWithQualifier];
			});
		}
	});
	toResolve.forEach(resolveable => {
		const targetStr = resolveable.$target;
		resolveable.$target = objectMap[targetStr];
		if (!resolveable.$target) {
			resolveable.targetString = targetStr;
			ANNOTATION_ERRORS.push({ message: "Unable to resolve the path expression " + targetStr });
		}
	});
	(parserOutput as any).entitySets = parserOutput.schema.entitySets;

	return {
		version: parserOutput.version,
		annotations: parserOutput.schema.annotations,
		namespace: parserOutput.schema.namespace,
		actions: parserOutput.schema.actions as Action[],
		entitySets: parserOutput.schema.entitySets as EntitySet[],
		entityTypes: parserOutput.schema.entityTypes as EntityType[],
		complexTypes: parserOutput.schema.complexTypes as ComplexType[],
		references: defaultReferences,
		diagnostics: ANNOTATION_ERRORS.concat()
	};
}

function revertValueToGenericType(references: Reference[], value: any): Expression | undefined {
	let result: Expression | undefined;
	if (typeof value === "string") {
		const valueMatches = value.match(/(\w+)\.\w+\/.*/);
		if (valueMatches && references.find(ref => ref.alias === valueMatches[1])) {
			result = {
				type: "EnumMember",
				EnumMember: value
			};
		} else {
			result = {
				type: "String",
				String: value
			};
		}
	} else if (Array.isArray(value)) {
		result = {
			type: "Collection",
			Collection: value.map(anno => revertCollectionItemToGenericType(references, anno)) as any[]
		};
	} else if (typeof value === "boolean") {
		result = {
			type: "Bool",
			Bool: value
		};
	} else if (typeof value === "number") {
		if (value.toString() === value.toFixed()) {
			result = {
				type: "Int",
				Int: value
			};
		} else {
			result = {
				type: "Decimal",
				Decimal: value
			};
		}
	} else if (typeof value === "object" && value.isDecimal && value.isDecimal()) {
		result = {
			type: "Decimal",
			Decimal: value.valueOf()
		};
	} else if (value.type === "Path") {
		result = {
			type: "Path",
			Path: value.path
		};
	} else if (value.type === "AnnotationPath") {
		result = {
			type: "AnnotationPath",
			AnnotationPath: value.value
		};
	} else if (value.type === "PropertyPath") {
		result = {
			type: "PropertyPath",
			PropertyPath: value.value
		};
	} else if (value.type === "NavigationPropertyPath") {
		result = {
			type: "NavigationPropertyPath",
			NavigationPropertyPath: value.value
		};
	} else if (Object.prototype.hasOwnProperty.call(value, "$Type")) {
		result = {
			type: "Record",
			Record: revertCollectionItemToGenericType(references, value) as AnnotationRecord
		};
	}
	return result;
}

function revertCollectionItemToGenericType(
	references: Reference[],
	collectionItem: any
):
	| AnnotationRecord
	| string
	| PropertyPathExpression
	| PathExpression
	| NavigationPropertyPathExpression
	| AnnotationPathExpression
	| undefined {
	if (typeof collectionItem === "string") {
		return collectionItem;
	} else if (typeof collectionItem === "object") {
		if (collectionItem.hasOwnProperty("$Type")) {
			// Annotation Record
			const outItem: AnnotationRecord = {
				type: collectionItem.$Type,
				propertyValues: [] as any[]
			};
			// Could validate keys and type based on $Type
			Object.keys(collectionItem).forEach(collectionKey => {
				if (
					collectionKey !== "$Type" &&
					collectionKey !== "term" &&
					collectionKey !== "__source" &&
					collectionKey !== "qualifier" &&
					collectionKey !== "ActionTarget" &&
					collectionKey !== "fullyQualifiedName" &&
					collectionKey !== "annotations"
				) {
					const value = collectionItem[collectionKey];
					outItem.propertyValues.push({
						name: collectionKey,
						value: revertValueToGenericType(references, value) as Expression
					});
				} else if (collectionKey === "annotations") {
					const annotations = collectionItem[collectionKey];
					outItem.annotations = [];
					Object.keys(annotations)
						.filter(key => key !== "_annotations")
						.forEach(key => {
							Object.keys(annotations[key]).forEach(term => {
								const parsedAnnotation = revertTermToGenericType(references, annotations[key][term]);
								if (!parsedAnnotation.term) {
									const unaliasedTerm = unalias(references, `${key}.${term}`);
									if (unaliasedTerm) {
										const qualifiedSplit = unaliasedTerm.split("#");
										parsedAnnotation.term = qualifiedSplit[0];
										if (qualifiedSplit.length > 1) {
											parsedAnnotation.qualifier = qualifiedSplit[1];
										}
									}
								}
								outItem.annotations?.push(parsedAnnotation);
							});
						});
				}
			});
			return outItem;
		} else if (collectionItem.type === "PropertyPath") {
			return {
				type: "PropertyPath",
				PropertyPath: collectionItem.value
			};
		} else if (collectionItem.type === "AnnotationPath") {
			return {
				type: "AnnotationPath",
				AnnotationPath: collectionItem.value
			};
		}
	}
}

export function revertTermToGenericType(references: Reference[], annotation: AnnotationTerm<any>): EdmAnnotation {
	const baseAnnotation = {
		term: annotation.term,
		qualifier: annotation.qualifier
	};
	if (Array.isArray(annotation)) {
		// Collection
		return {
			...baseAnnotation,
			collection: annotation.map(anno => revertCollectionItemToGenericType(references, anno)) as any[]
		};
	} else if (annotation.hasOwnProperty("$Type")) {
		return { ...baseAnnotation, record: revertCollectionItemToGenericType(references, annotation) as any };
	} else {
		return { ...baseAnnotation, value: revertValueToGenericType(references, annotation) };
	}
}
