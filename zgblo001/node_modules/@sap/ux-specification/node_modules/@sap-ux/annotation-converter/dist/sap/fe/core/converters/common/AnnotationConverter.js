"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.revertTermToGenericType = exports.convertTypes = exports.defaultReferences = void 0;
var Path = /** @class */ (function () {
    function Path(pathExpression, targetName) {
        this.path = pathExpression.Path;
        this.type = "Path";
        this.$target = targetName;
    }
    return Path;
}());
exports.defaultReferences = [
    { alias: "Capabilities", namespace: "Org.OData.Capabilities.V1", uri: "" },
    { alias: "Aggregation", namespace: "Org.OData.Aggregation.V1", uri: "" },
    { alias: "Validation", namespace: "Org.OData.Validation.V1", uri: "" },
    { namespace: "Org.OData.Core.V1", alias: "Core", uri: "" },
    { namespace: "Org.OData.Measures.V1", alias: "Measures", uri: "" },
    { namespace: "com.sap.vocabularies.Common.v1", alias: "Common", uri: "" },
    { namespace: "com.sap.vocabularies.UI.v1", alias: "UI", uri: "" },
    { namespace: "com.sap.vocabularies.Session.v1", alias: "Session", uri: "" },
    { namespace: "com.sap.vocabularies.Analytics.v1", alias: "Analytics", uri: "" },
    { namespace: "com.sap.vocabularies.CodeList.v1", alias: "CodeList", uri: "" },
    { namespace: "com.sap.vocabularies.PersonalData.v1", alias: "PersonalData", uri: "" },
    { namespace: "com.sap.vocabularies.Communication.v1", alias: "Communication", uri: "" },
    { namespace: "com.sap.vocabularies.HTML5.v1", alias: "HTML5", uri: "" }
];
function alias(references, unaliasedValue) {
    if (!references.reverseReferenceMap) {
        references.reverseReferenceMap = references.reduce(function (map, reference) {
            map[reference.namespace] = reference;
            return map;
        }, {});
    }
    if (!unaliasedValue) {
        return unaliasedValue;
    }
    var lastDotIndex = unaliasedValue.lastIndexOf(".");
    var namespace = unaliasedValue.substr(0, lastDotIndex);
    var value = unaliasedValue.substr(lastDotIndex + 1);
    var reference = references.reverseReferenceMap[namespace];
    if (reference) {
        return reference.alias + "." + value;
    }
    else {
        // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
        if (unaliasedValue.indexOf("@") !== -1) {
            var _a = unaliasedValue.split("@"), preAlias = _a[0], postAlias = _a[1];
            return preAlias + "@" + alias(references, postAlias);
        }
        else {
            return unaliasedValue;
        }
    }
}
function unalias(references, aliasedValue) {
    if (!references.referenceMap) {
        references.referenceMap = references.reduce(function (map, reference) {
            map[reference.alias] = reference;
            return map;
        }, {});
    }
    if (!aliasedValue) {
        return aliasedValue;
    }
    var _a = aliasedValue.split("."), alias = _a[0], value = _a[1];
    var reference = references.referenceMap[alias];
    if (reference) {
        return reference.namespace + "." + value;
    }
    else {
        // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
        if (aliasedValue.indexOf("@") !== -1) {
            var _b = aliasedValue.split("@"), preAlias = _b[0], postAlias = _b[1];
            return preAlias + "@" + unalias(references, postAlias);
        }
        else {
            return aliasedValue;
        }
    }
}
function buildObjectMap(parserOutput) {
    var objectMap = {};
    if (parserOutput.schema.entityContainer && parserOutput.schema.entityContainer.fullyQualifiedName) {
        objectMap[parserOutput.schema.entityContainer.fullyQualifiedName] = parserOutput.schema.entityContainer;
    }
    parserOutput.schema.entitySets.forEach(function (entitySet) {
        objectMap[entitySet.fullyQualifiedName] = entitySet;
    });
    parserOutput.schema.actions.forEach(function (action) {
        objectMap[action.fullyQualifiedName] = action;
        objectMap[action.fullyQualifiedName.split("(")[0]] = action;
        action.parameters.forEach(function (parameter) {
            objectMap[parameter.fullyQualifiedName] = parameter;
        });
    });
    parserOutput.schema.complexTypes.forEach(function (complexType) {
        objectMap[complexType.fullyQualifiedName] = complexType;
        complexType.properties.forEach(function (property) {
            objectMap[property.fullyQualifiedName] = property;
        });
    });
    parserOutput.schema.entityTypes.forEach(function (entityType) {
        objectMap[entityType.fullyQualifiedName] = entityType;
        entityType.entityProperties.forEach(function (property) {
            objectMap[property.fullyQualifiedName] = property;
            if (property.type.indexOf("Edm") === -1) {
                // Handle complex types
                var complexTypeDefinition = objectMap[property.type];
                if (complexTypeDefinition && complexTypeDefinition.properties) {
                    complexTypeDefinition.properties.forEach(function (complexTypeProp) {
                        var complexTypePropTarget = Object.assign(complexTypeProp, {
                            _type: "Property",
                            fullyQualifiedName: property.fullyQualifiedName + "/" + complexTypeProp.name
                        });
                        objectMap[complexTypePropTarget.fullyQualifiedName] = complexTypePropTarget;
                    });
                }
            }
        });
        entityType.navigationProperties.forEach(function (navProperty) {
            objectMap[navProperty.fullyQualifiedName] = navProperty;
        });
    });
    Object.keys(parserOutput.schema.annotations).forEach(function (annotationSource) {
        parserOutput.schema.annotations[annotationSource].forEach(function (annotationList) {
            var currentTargetName = unalias(parserOutput.references, annotationList.target);
            annotationList.annotations.forEach(function (annotation) {
                var annotationFQN = currentTargetName + "@" + unalias(parserOutput.references, annotation.term);
                if (annotation.qualifier) {
                    annotationFQN += "#" + annotation.qualifier;
                }
                objectMap[annotationFQN] = annotation;
                annotation.fullyQualifiedName = annotationFQN;
            });
        });
    });
    return objectMap;
}
function combinePath(currentTarget, path) {
    if (path.startsWith("@")) {
        return currentTarget + unalias(exports.defaultReferences, path);
    }
    else {
        return currentTarget + "/" + path;
    }
}
function resolveTarget(objectMap, currentTarget, path, pathOnly, includeVisitedObjects) {
    if (pathOnly === void 0) { pathOnly = false; }
    if (includeVisitedObjects === void 0) { includeVisitedObjects = false; }
    if (!path) {
        return undefined;
    }
    var aVisitedObjects = [];
    path = combinePath(currentTarget.fullyQualifiedName, path);
    var pathSplit = path.split("/");
    var currentPath = path;
    var target = pathSplit.reduce(function (currentValue, pathPart) {
        if (pathPart.length === 0) {
            return currentValue;
        }
        if (includeVisitedObjects && currentValue !== null) {
            aVisitedObjects.push(currentValue);
        }
        if (!currentValue) {
            currentPath = pathPart;
        }
        else if (currentValue._type === "EntitySet" && currentValue.entityType) {
            currentPath = combinePath(currentValue.entityTypeName, pathPart);
        }
        else if (currentValue._type === "NavigationProperty" && currentValue.targetTypeName) {
            currentPath = combinePath(currentValue.targetTypeName, pathPart);
        }
        else if (currentValue._type === "NavigationProperty" && currentValue.targetType) {
            currentPath = combinePath(currentValue.targetType.fullyQualifiedName, pathPart);
        }
        else if (currentValue._type === "Property") {
            if (currentValue.type.indexOf("Edm") === -1) {
                // This is a complex type
                currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
            }
            else {
                currentPath = combinePath(currentTarget.fullyQualifiedName.substr(0, currentTarget.fullyQualifiedName.lastIndexOf("/")), pathPart);
            }
        }
        else if (currentValue._type === "Action" && currentValue.isBound) {
            currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
            if (!objectMap[currentPath]) {
                currentPath = combinePath(currentValue.sourceType, pathPart);
            }
        }
        else if (currentValue._type === "ActionParameter" && currentValue.isEntitySet) {
            currentPath = combinePath(currentValue.type, pathPart);
        }
        else if (currentValue._type === "ActionParameter" && !currentValue.isEntitySet) {
            currentPath = combinePath(currentTarget.fullyQualifiedName.substr(0, currentTarget.fullyQualifiedName.lastIndexOf("/")), pathPart);
            if (!objectMap[currentPath]) {
                var lastIdx = currentTarget.fullyQualifiedName.lastIndexOf("/");
                if (lastIdx === -1) {
                    lastIdx = currentTarget.fullyQualifiedName.length;
                }
                currentPath = combinePath(objectMap[currentTarget.fullyQualifiedName.substr(0, lastIdx)].sourceType, pathPart);
            }
        }
        else {
            currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
            if (currentValue[pathPart] !== undefined) {
                return currentValue[pathPart];
            }
            else if (pathPart === "$AnnotationPath" && currentValue.$target) {
                return currentValue.$target;
            }
            else if (currentValue.hasOwnProperty("$Type")) {
                // This is now an annotation value
                var entityType = objectMap[currentValue.fullyQualifiedName.split("@")[0]];
                if (entityType) {
                    currentPath = combinePath(entityType.fullyQualifiedName, pathPart);
                }
            }
        }
        return objectMap[currentPath];
    }, null);
    if (!target) {
        ANNOTATION_ERRORS.push({ message: "Unable to resolve the path expression " + path });
        // console.log("Missing target " + path);
    }
    if (pathOnly) {
        return currentPath;
    }
    if (includeVisitedObjects) {
        return {
            visitedObjects: aVisitedObjects,
            target: target
        };
    }
    return target;
}
function isAnnotationPath(pathStr) {
    return pathStr.indexOf("@") !== -1;
}
function parseValue(propertyValue, valueFQN, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations) {
    if (propertyValue === undefined) {
        return undefined;
    }
    switch (propertyValue.type) {
        case "String":
            return propertyValue.String;
        case "Int":
            return propertyValue.Int;
        case "Bool":
            return propertyValue.Bool;
        case "Decimal":
            return propertyValue.Decimal;
        case "Date":
            return propertyValue.Date;
        case "EnumMember":
            return alias(parserOutput.references, propertyValue.EnumMember);
        case "PropertyPath":
            return {
                type: "PropertyPath",
                value: propertyValue.PropertyPath,
                fullyQualifiedName: valueFQN,
                $target: resolveTarget(objectMap, currentTarget, propertyValue.PropertyPath)
            };
        case "NavigationPropertyPath":
            return {
                type: "NavigationPropertyPath",
                value: propertyValue.NavigationPropertyPath,
                fullyQualifiedName: valueFQN,
                $target: resolveTarget(objectMap, currentTarget, propertyValue.NavigationPropertyPath)
            };
        case "AnnotationPath":
            var annotationTarget = resolveTarget(objectMap, currentTarget, unalias(parserOutput.references, propertyValue.AnnotationPath), true);
            var annotationPath = {
                type: "AnnotationPath",
                value: propertyValue.AnnotationPath,
                fullyQualifiedName: valueFQN,
                $target: annotationTarget
            };
            toResolve.push(annotationPath);
            return annotationPath;
        case "Path":
            if (isAnnotationPath(propertyValue.Path)) {
                // If it's an anntoation that we can resolve, resolve it !
                var $target_1 = resolveTarget(objectMap, currentTarget, propertyValue.Path);
                if ($target_1) {
                    return $target_1;
                }
            }
            var $target = resolveTarget(objectMap, currentTarget, propertyValue.Path, true);
            var path = new Path(propertyValue, $target);
            toResolve.push(path);
            return path;
        case "Record":
            return parseRecord(propertyValue.Record, valueFQN, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations);
        case "Collection":
            return parseCollection(propertyValue.Collection, valueFQN, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations);
        case "Apply":
        case "If":
            return propertyValue;
    }
}
function parseRecord(recordDefinition, currentFQN, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations) {
    var annotationTerm = {
        $Type: unalias(parserOutput.references, recordDefinition.type),
        fullyQualifiedName: currentFQN
    };
    var annotationContent = {};
    if (recordDefinition.annotations && Array.isArray(recordDefinition.annotations)) {
        var subAnnotationList = {
            target: currentFQN,
            annotations: recordDefinition.annotations,
            __source: annotationSource
        };
        unresolvedAnnotations.push(subAnnotationList);
    }
    recordDefinition.propertyValues.forEach(function (propertyValue) {
        annotationContent[propertyValue.name] = parseValue(propertyValue.value, currentFQN + "/" + propertyValue.name, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations);
        if (propertyValue.annotations && Array.isArray(propertyValue.annotations)) {
            var subAnnotationList = {
                target: currentFQN + "/" + propertyValue.name,
                annotations: propertyValue.annotations,
                __source: annotationSource
            };
            unresolvedAnnotations.push(subAnnotationList);
        }
        if (annotationContent.hasOwnProperty("Action") &&
            (annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" ||
                annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldWithAction")) {
            if (currentTarget.actions) {
                annotationContent.ActionTarget =
                    currentTarget.actions[annotationContent.Action] || objectMap[annotationContent.Action];
                if (!annotationContent.ActionTarget) {
                    // Add to diagnostics debugger;
                    ANNOTATION_ERRORS.push({
                        message: "Unable to resolve the action " +
                            annotationContent.Action +
                            " defined for " +
                            annotationTerm.fullyQualifiedName
                    });
                }
            }
        }
    });
    return Object.assign(annotationTerm, annotationContent);
}
function getOrInferCollectionType(collectionDefinition) {
    var type = collectionDefinition.type;
    if (type === undefined && collectionDefinition.length > 0) {
        var firstColItem = collectionDefinition[0];
        if (firstColItem.hasOwnProperty("PropertyPath")) {
            type = "PropertyPath";
        }
        else if (firstColItem.hasOwnProperty("Path")) {
            type = "Path";
        }
        else if (firstColItem.hasOwnProperty("AnnotationPath")) {
            type = "AnnotationPath";
        }
        else if (firstColItem.hasOwnProperty("NavigationPropertyPath")) {
            type = "NavigationPropertyPath";
        }
        else if (typeof firstColItem === "object" &&
            (firstColItem.hasOwnProperty("type") || firstColItem.hasOwnProperty("propertyValues"))) {
            type = "Record";
        }
        else if (typeof firstColItem === "string") {
            type = "String";
        }
    }
    else if (type === undefined) {
        type = "EmptyCollection";
    }
    return type;
}
function parseCollection(collectionDefinition, parentFQN, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations) {
    var collectionDefinitionType = getOrInferCollectionType(collectionDefinition);
    switch (collectionDefinitionType) {
        case "PropertyPath":
            return collectionDefinition.map(function (propertyPath, propertyIdx) {
                return {
                    type: "PropertyPath",
                    value: propertyPath.PropertyPath,
                    fullyQualifiedName: parentFQN + "/" + propertyIdx,
                    $target: resolveTarget(objectMap, currentTarget, propertyPath.PropertyPath)
                };
            });
        case "Path":
            return collectionDefinition.map(function (pathValue) {
                if (isAnnotationPath(pathValue.Path)) {
                    // If it's an anntoation that we can resolve, resolve it !
                    var $target_2 = resolveTarget(objectMap, currentTarget, pathValue.Path);
                    if ($target_2) {
                        return $target_2;
                    }
                }
                var $target = resolveTarget(objectMap, currentTarget, pathValue.Path, true);
                var path = new Path(pathValue, $target);
                toResolve.push(path);
                return path;
            });
        case "AnnotationPath":
            return collectionDefinition.map(function (annotationPath, annotationIdx) {
                var annotationTarget = resolveTarget(objectMap, currentTarget, annotationPath.AnnotationPath, true);
                var annotationCollectionElement = {
                    type: "AnnotationPath",
                    value: annotationPath.AnnotationPath,
                    fullyQualifiedName: parentFQN + "/" + annotationIdx,
                    $target: annotationTarget
                };
                toResolve.push(annotationCollectionElement);
                return annotationCollectionElement;
            });
        case "NavigationPropertyPath":
            return collectionDefinition.map(function (navPropertyPath, navPropIdx) {
                return {
                    type: "NavigationPropertyPath",
                    value: navPropertyPath.NavigationPropertyPath,
                    fullyQualifiedName: parentFQN + "/" + navPropIdx,
                    $target: resolveTarget(objectMap, currentTarget, navPropertyPath.NavigationPropertyPath)
                };
            });
        case "Record":
            return collectionDefinition.map(function (recordDefinition, recordIdx) {
                return parseRecord(recordDefinition, parentFQN + "/" + recordIdx, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations);
            });
        case "String":
            return collectionDefinition.map(function (stringValue) {
                return stringValue;
            });
        default:
            if (collectionDefinition.length === 0) {
                return [];
            }
            throw new Error("Unsupported case");
    }
}
function convertAnnotation(annotation, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations) {
    if (annotation.record) {
        var annotationTerm_1 = {
            $Type: unalias(parserOutput.references, annotation.record.type),
            fullyQualifiedName: annotation.fullyQualifiedName,
            qualifier: annotation.qualifier
        };
        var annotationContent_1 = {};
        annotation.record.propertyValues.forEach(function (propertyValue) {
            annotationContent_1[propertyValue.name] = parseValue(propertyValue.value, annotation.fullyQualifiedName + "/" + propertyValue.name, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations);
            if (annotationContent_1.hasOwnProperty("Action") &&
                (!annotation.record ||
                    annotationTerm_1.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" ||
                    annotationTerm_1.$Type === "com.sap.vocabularies.UI.v1.DataFieldWithAction")) {
                if (currentTarget.actions) {
                    annotationContent_1.ActionTarget =
                        currentTarget.actions[annotationContent_1.Action] || objectMap[annotationContent_1.Action];
                    if (!annotationContent_1.ActionTarget) {
                        ANNOTATION_ERRORS.push({
                            message: "Unable to resolve the action " +
                                annotationContent_1.Action +
                                " defined for " +
                                annotation.fullyQualifiedName
                        });
                        // Add to diagnostics
                        // debugger;
                    }
                }
            }
        });
        return Object.assign(annotationTerm_1, annotationContent_1);
    }
    else if (annotation.collection === undefined) {
        if (annotation.value) {
            return parseValue(annotation.value, annotation.fullyQualifiedName, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations);
        }
        else {
            return true;
        }
    }
    else if (annotation.collection) {
        var collection = parseCollection(annotation.collection, annotation.fullyQualifiedName, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations);
        collection.fullyQualifiedName = annotation.fullyQualifiedName;
        return collection;
    }
    else {
        throw new Error("Unsupported case");
    }
}
function createResolvePathFn(entityType, objectMap) {
    return function (relativePath, includeVisitedObjects) {
        return resolveTarget(objectMap, entityType, relativePath, false, includeVisitedObjects);
    };
}
function resolveNavigationProperties(entityTypes, associations, objectMap) {
    entityTypes.forEach(function (entityType) {
        entityType.navigationProperties = entityType.navigationProperties.map(function (navProp) {
            var outNavProp = {
                _type: "NavigationProperty",
                name: navProp.name,
                fullyQualifiedName: navProp.fullyQualifiedName,
                partner: navProp.hasOwnProperty("partner") ? navProp.partner : undefined,
                // targetTypeName: FullyQualifiedName;
                // targetType: EntityType;
                isCollection: navProp.hasOwnProperty("isCollection") ? navProp.isCollection : false,
                containsTarget: navProp.hasOwnProperty("containsTarget")
                    ? navProp.containsTarget
                    : false,
                referentialConstraint: navProp.referentialConstraint
                    ? navProp.referentialConstraint
                    : []
            };
            if (navProp.targetTypeName) {
                outNavProp.targetType = objectMap[navProp.targetTypeName];
            }
            else if (navProp.relationship) {
                var targetAssociation = associations.find(function (association) { return association.fullyQualifiedName === navProp.relationship; });
                if (targetAssociation) {
                    var associationEnd = targetAssociation.associationEnd.find(function (end) { return end.role === navProp.toRole; });
                    if (associationEnd) {
                        outNavProp.targetType = objectMap[associationEnd.type];
                        outNavProp.isCollection = associationEnd.multiplicity === "*";
                    }
                }
            }
            if (outNavProp.targetType) {
                outNavProp.targetTypeName = outNavProp.targetType.fullyQualifiedName;
            }
            var outNavPropReq = outNavProp;
            objectMap[outNavPropReq.fullyQualifiedName] = outNavPropReq;
            return outNavPropReq;
        });
        entityType.resolvePath = createResolvePathFn(entityType, objectMap);
    });
}
function linkActionsToEntityType(namespace, actions, objectMap) {
    actions.forEach(function (action) {
        if (action.isBound) {
            var sourceEntityType = objectMap[action.sourceType];
            action.sourceEntityType = sourceEntityType;
            if (sourceEntityType) {
                if (!sourceEntityType.actions) {
                    sourceEntityType.actions = {};
                }
                sourceEntityType.actions[action.name] = action;
                sourceEntityType.actions[namespace + "." + action.name] = action;
            }
            action.returnEntityType = objectMap[action.returnType];
        }
    });
}
function linkEntityTypeToEntitySet(entitySets, objectMap) {
    entitySets.forEach(function (entitySet) {
        entitySet.entityType = objectMap[entitySet.entityTypeName];
        if (!entitySet.annotations) {
            entitySet.annotations = {};
        }
        if (!entitySet.entityType.annotations) {
            entitySet.entityType.annotations = {};
        }
        entitySet.entityType.keys.forEach(function (keyProp) {
            keyProp.isKey = true;
        });
    });
}
function linkPropertiesToComplexTypes(entityTypes, objectMap) {
    entityTypes.forEach(function (entityType) {
        entityType.entityProperties.forEach(function (entityProperty) {
            if (entityProperty.type.indexOf("Edm") === -1) {
                var complexType = objectMap[entityProperty.type];
                if (complexType) {
                    entityProperty.targetType = complexType;
                }
            }
        });
    });
}
function prepareComplexTypes(complexTypes, associations, objectMap) {
    complexTypes.forEach(function (complexType) {
        complexType.annotations = {};
        complexType.properties.forEach(function (property) {
            if (!property.annotations) {
                property.annotations = {};
            }
        });
        complexType.navigationProperties = complexType.navigationProperties.map(function (navProp) {
            if (!navProp.annotations) {
                navProp.annotations = {};
            }
            var outNavProp = {
                _type: "NavigationProperty",
                name: navProp.name,
                fullyQualifiedName: navProp.fullyQualifiedName,
                partner: navProp.hasOwnProperty("partner") ? navProp.partner : undefined,
                // targetTypeName: FullyQualifiedName;
                // targetType: EntityType;
                isCollection: navProp.hasOwnProperty("isCollection") ? navProp.isCollection : false,
                containsTarget: navProp.hasOwnProperty("containsTarget")
                    ? navProp.containsTarget
                    : false,
                referentialConstraint: navProp.referentialConstraint
                    ? navProp.referentialConstraint
                    : []
            };
            if (navProp.targetTypeName) {
                outNavProp.targetType = objectMap[navProp.targetTypeName];
            }
            else if (navProp.relationship) {
                var targetAssociation = associations.find(function (association) { return association.fullyQualifiedName === navProp.relationship; });
                if (targetAssociation) {
                    var associationEnd = targetAssociation.associationEnd.find(function (end) { return end.role === navProp.toRole; });
                    if (associationEnd) {
                        outNavProp.targetType = objectMap[associationEnd.type];
                        outNavProp.isCollection = associationEnd.multiplicity === "*";
                    }
                }
            }
            if (outNavProp.targetType) {
                outNavProp.targetTypeName = outNavProp.targetType.fullyQualifiedName;
            }
            var outNavPropReq = outNavProp;
            objectMap[outNavPropReq.fullyQualifiedName] = outNavPropReq;
            return outNavPropReq;
        });
    });
}
function splitTerm(references, termValue) {
    var aliasedTerm = alias(references, termValue);
    var lastDot = aliasedTerm.lastIndexOf(".");
    var termAlias = aliasedTerm.substr(0, lastDot);
    var term = aliasedTerm.substr(lastDot + 1);
    return [termAlias, term];
}
var ANNOTATION_ERRORS = [];
function convertTypes(parserOutput) {
    ANNOTATION_ERRORS = [];
    var objectMap = buildObjectMap(parserOutput);
    resolveNavigationProperties(parserOutput.schema.entityTypes, parserOutput.schema.associations, objectMap);
    linkActionsToEntityType(parserOutput.schema.namespace, parserOutput.schema.actions, objectMap);
    linkEntityTypeToEntitySet(parserOutput.schema.entitySets, objectMap);
    linkPropertiesToComplexTypes(parserOutput.schema.entityTypes, objectMap);
    prepareComplexTypes(parserOutput.schema.complexTypes, parserOutput.schema.associations, objectMap);
    var toResolve = [];
    var unresolvedAnnotations = [];
    Object.keys(parserOutput.schema.annotations).forEach(function (annotationSource) {
        parserOutput.schema.annotations[annotationSource].forEach(function (annotationList) {
            var currentTargetName = unalias(parserOutput.references, annotationList.target);
            var currentTarget = objectMap[currentTargetName];
            if (!currentTarget) {
                if (currentTargetName.indexOf("@") !== -1) {
                    annotationList.__source = annotationSource;
                    unresolvedAnnotations.push(annotationList);
                }
            }
            else if (typeof currentTarget === "object") {
                if (!currentTarget.annotations) {
                    currentTarget.annotations = {};
                }
                annotationList.annotations.forEach(function (annotation) {
                    var _a = splitTerm(exports.defaultReferences, annotation.term), vocAlias = _a[0], vocTerm = _a[1];
                    if (!currentTarget.annotations[vocAlias]) {
                        currentTarget.annotations[vocAlias] = {};
                    }
                    if (!currentTarget.annotations._annotations) {
                        currentTarget.annotations._annotations = {};
                    }
                    var vocTermWithQualifier = "" + vocTerm + (annotation.qualifier ? "#" + annotation.qualifier : "");
                    currentTarget.annotations[vocAlias][vocTermWithQualifier] = convertAnnotation(annotation, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations);
                    if (currentTarget.annotations[vocAlias][vocTermWithQualifier] !== null &&
                        typeof currentTarget.annotations[vocAlias][vocTermWithQualifier] === "object") {
                        currentTarget.annotations[vocAlias][vocTermWithQualifier].term = unalias(exports.defaultReferences, vocAlias + "." + vocTerm);
                        currentTarget.annotations[vocAlias][vocTermWithQualifier].qualifier = annotation.qualifier;
                        currentTarget.annotations[vocAlias][vocTermWithQualifier].__source = annotationSource;
                    }
                    var annotationTarget = currentTargetName + "@" + unalias(exports.defaultReferences, vocAlias + "." + vocTermWithQualifier);
                    if (annotation.annotations && Array.isArray(annotation.annotations)) {
                        var subAnnotationList = {
                            target: annotationTarget,
                            annotations: annotation.annotations,
                            __source: annotationSource
                        };
                        unresolvedAnnotations.push(subAnnotationList);
                    }
                    currentTarget.annotations._annotations[vocAlias + "." + vocTermWithQualifier] =
                        currentTarget.annotations[vocAlias][vocTermWithQualifier];
                    objectMap[annotationTarget] = currentTarget.annotations[vocAlias][vocTermWithQualifier];
                });
            }
        });
    });
    var extraUnresolvedAnnotations = [];
    unresolvedAnnotations.forEach(function (annotationList) {
        var currentTargetName = unalias(parserOutput.references, annotationList.target);
        var _a = currentTargetName.split("@"), baseObj = _a[0], annotationPart = _a[1];
        var targetSplit = annotationPart.split("/");
        baseObj = baseObj + "@" + targetSplit[0];
        var currentTarget = targetSplit.slice(1).reduce(function (currentObj, path) {
            if (!currentObj) {
                return null;
            }
            return currentObj[path];
        }, objectMap[baseObj]);
        if (!currentTarget) {
            ANNOTATION_ERRORS.push({
                message: "The following annotation target was not found on the service " + currentTargetName
            });
            // console.log("Missing target again " + currentTargetName);
        }
        else if (typeof currentTarget === "object") {
            if (!currentTarget.annotations) {
                currentTarget.annotations = {};
            }
            annotationList.annotations.forEach(function (annotation) {
                var _a = splitTerm(exports.defaultReferences, annotation.term), vocAlias = _a[0], vocTerm = _a[1];
                if (!currentTarget.annotations[vocAlias]) {
                    currentTarget.annotations[vocAlias] = {};
                }
                if (!currentTarget.annotations._annotations) {
                    currentTarget.annotations._annotations = {};
                }
                var vocTermWithQualifier = "" + vocTerm + (annotation.qualifier ? "#" + annotation.qualifier : "");
                currentTarget.annotations[vocAlias][vocTermWithQualifier] = convertAnnotation(annotation, parserOutput, currentTarget, objectMap, toResolve, annotationList.__source, extraUnresolvedAnnotations);
                if (currentTarget.annotations[vocAlias][vocTermWithQualifier] !== null &&
                    typeof currentTarget.annotations[vocAlias][vocTermWithQualifier] === "object") {
                    currentTarget.annotations[vocAlias][vocTermWithQualifier].term = unalias(exports.defaultReferences, vocAlias + "." + vocTerm);
                    currentTarget.annotations[vocAlias][vocTermWithQualifier].qualifier = annotation.qualifier;
                    currentTarget.annotations[vocAlias][vocTermWithQualifier].__source = annotationList.__source;
                }
                currentTarget.annotations._annotations[vocAlias + "." + vocTermWithQualifier] =
                    currentTarget.annotations[vocAlias][vocTermWithQualifier];
                objectMap[currentTargetName + "@" + unalias(exports.defaultReferences, vocAlias + "." + vocTermWithQualifier)] =
                    currentTarget.annotations[vocAlias][vocTermWithQualifier];
            });
        }
    });
    toResolve.forEach(function (resolveable) {
        var targetStr = resolveable.$target;
        resolveable.$target = objectMap[targetStr];
        if (!resolveable.$target) {
            resolveable.targetString = targetStr;
            ANNOTATION_ERRORS.push({ message: "Unable to resolve the path expression " + targetStr });
        }
    });
    parserOutput.entitySets = parserOutput.schema.entitySets;
    return {
        version: parserOutput.version,
        annotations: parserOutput.schema.annotations,
        namespace: parserOutput.schema.namespace,
        actions: parserOutput.schema.actions,
        entitySets: parserOutput.schema.entitySets,
        entityTypes: parserOutput.schema.entityTypes,
        complexTypes: parserOutput.schema.complexTypes,
        references: exports.defaultReferences,
        diagnostics: ANNOTATION_ERRORS.concat()
    };
}
exports.convertTypes = convertTypes;
function revertValueToGenericType(references, value) {
    var result;
    if (typeof value === "string") {
        var valueMatches_1 = value.match(/(\w+)\.\w+\/.*/);
        if (valueMatches_1 && references.find(function (ref) { return ref.alias === valueMatches_1[1]; })) {
            result = {
                type: "EnumMember",
                EnumMember: value
            };
        }
        else {
            result = {
                type: "String",
                String: value
            };
        }
    }
    else if (Array.isArray(value)) {
        result = {
            type: "Collection",
            Collection: value.map(function (anno) { return revertCollectionItemToGenericType(references, anno); })
        };
    }
    else if (typeof value === "boolean") {
        result = {
            type: "Bool",
            Bool: value
        };
    }
    else if (typeof value === "number") {
        if (value.toString() === value.toFixed()) {
            result = {
                type: "Int",
                Int: value
            };
        }
        else {
            result = {
                type: "Decimal",
                Decimal: value
            };
        }
    }
    else if (typeof value === "object" && value.isDecimal && value.isDecimal()) {
        result = {
            type: "Decimal",
            Decimal: value.valueOf()
        };
    }
    else if (value.type === "Path") {
        result = {
            type: "Path",
            Path: value.path
        };
    }
    else if (value.type === "AnnotationPath") {
        result = {
            type: "AnnotationPath",
            AnnotationPath: value.value
        };
    }
    else if (value.type === "PropertyPath") {
        result = {
            type: "PropertyPath",
            PropertyPath: value.value
        };
    }
    else if (value.type === "NavigationPropertyPath") {
        result = {
            type: "NavigationPropertyPath",
            NavigationPropertyPath: value.value
        };
    }
    else if (Object.prototype.hasOwnProperty.call(value, "$Type")) {
        result = {
            type: "Record",
            Record: revertCollectionItemToGenericType(references, value)
        };
    }
    return result;
}
function revertCollectionItemToGenericType(references, collectionItem) {
    if (typeof collectionItem === "string") {
        return collectionItem;
    }
    else if (typeof collectionItem === "object") {
        if (collectionItem.hasOwnProperty("$Type")) {
            // Annotation Record
            var outItem_1 = {
                type: collectionItem.$Type,
                propertyValues: []
            };
            // Could validate keys and type based on $Type
            Object.keys(collectionItem).forEach(function (collectionKey) {
                if (collectionKey !== "$Type" &&
                    collectionKey !== "term" &&
                    collectionKey !== "__source" &&
                    collectionKey !== "qualifier" &&
                    collectionKey !== "ActionTarget" &&
                    collectionKey !== "fullyQualifiedName" &&
                    collectionKey !== "annotations") {
                    var value = collectionItem[collectionKey];
                    outItem_1.propertyValues.push({
                        name: collectionKey,
                        value: revertValueToGenericType(references, value)
                    });
                }
                else if (collectionKey === "annotations") {
                    var annotations_1 = collectionItem[collectionKey];
                    outItem_1.annotations = [];
                    Object.keys(annotations_1)
                        .filter(function (key) { return key !== "_annotations"; })
                        .forEach(function (key) {
                        Object.keys(annotations_1[key]).forEach(function (term) {
                            var _a;
                            var parsedAnnotation = revertTermToGenericType(references, annotations_1[key][term]);
                            if (!parsedAnnotation.term) {
                                var unaliasedTerm = unalias(references, key + "." + term);
                                if (unaliasedTerm) {
                                    var qualifiedSplit = unaliasedTerm.split("#");
                                    parsedAnnotation.term = qualifiedSplit[0];
                                    if (qualifiedSplit.length > 1) {
                                        parsedAnnotation.qualifier = qualifiedSplit[1];
                                    }
                                }
                            }
                            (_a = outItem_1.annotations) === null || _a === void 0 ? void 0 : _a.push(parsedAnnotation);
                        });
                    });
                }
            });
            return outItem_1;
        }
        else if (collectionItem.type === "PropertyPath") {
            return {
                type: "PropertyPath",
                PropertyPath: collectionItem.value
            };
        }
        else if (collectionItem.type === "AnnotationPath") {
            return {
                type: "AnnotationPath",
                AnnotationPath: collectionItem.value
            };
        }
    }
}
function revertTermToGenericType(references, annotation) {
    var baseAnnotation = {
        term: annotation.term,
        qualifier: annotation.qualifier
    };
    if (Array.isArray(annotation)) {
        // Collection
        return __assign(__assign({}, baseAnnotation), { collection: annotation.map(function (anno) { return revertCollectionItemToGenericType(references, anno); }) });
    }
    else if (annotation.hasOwnProperty("$Type")) {
        return __assign(__assign({}, baseAnnotation), { record: revertCollectionItemToGenericType(references, annotation) });
    }
    else {
        return __assign(__assign({}, baseAnnotation), { value: revertValueToGenericType(references, annotation) });
    }
}
exports.revertTermToGenericType = revertTermToGenericType;
