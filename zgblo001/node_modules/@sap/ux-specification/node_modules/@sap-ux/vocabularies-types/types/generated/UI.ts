import * as Core from "./Core";
import * as Validation from "./Validation";
import * as Communication from "./Communication";
import * as Common from "./Common";
import * as HTML5 from "./HTML5";
import * as Edm from "../Edm";
import AnnotationTerm = Edm.AnnotationTerm;
import PropertyAnnotationValue = Edm.PropertyAnnotationValue;
import EnumValue = Edm.EnumValue;
import ComplexType = Edm.ComplexType;

// Term
/**
  Information for the header area of an entity representation. HeaderInfo is mandatory for main entity types of the model
*/
export type HeaderInfo = AnnotationTerm<HeaderInfoTypeTypes>;

// ComplexType
export type HeaderInfoType = ComplexType & {
	$Type: UIAnnotationTypes.HeaderInfoType;
	/**
        Name of the main entity type
    */
	TypeName: PropertyAnnotationValue<Edm.String>;
	/**
        Plural form of the name of the main entity type
    */
	TypeNamePlural: PropertyAnnotationValue<Edm.String>;
	/**
        Title, e.g. for overview pages
    */
	Title?: AnnotationTerm<DataFieldAbstractTypes>;
	/**
        Description, e.g. for overview pages
    */
	Description?: AnnotationTerm<DataFieldAbstractTypes>;
	/**
        Image URL for an instance of the entity type. If the property ImageUrl has a valid value, it can be used for the visualization of the instance. If it is not available or not valid the property TypeImageUrl can be used instead.
    */
	ImageUrl?: PropertyAnnotationValue<Edm.String>;
	/**
        Image URL for the entity type
    */
	TypeImageUrl?: PropertyAnnotationValue<Edm.String>;
	/**
        Latin letters to be used in case no ImageUrl or TypeImageUrl is present
    */
	Initials?: PropertyAnnotationValue<Edm.String>;
};

// Term
/**
  Collection of fields identifying the object
*/
export type Identification = AnnotationTerm<DataFieldAbstractTypes[]>;

// Term
/**
  Information usually displayed in the form of a business card
*/
export type Badge = AnnotationTerm<BadgeTypeTypes>;

// ComplexType
export type BadgeType = ComplexType & {
	$Type: UIAnnotationTypes.BadgeType;
	/**
        Headline
    */
	HeadLine: AnnotationTerm<DataFieldTypes>;
	/**
        Title
    */
	Title: AnnotationTerm<DataFieldTypes>;
	/**
        Image URL for an instance of the entity type. If the property ImageUrl has a valid value, it can be used for the visualization of the instance. If it is not available or not valid the property TypeImageUrl can be used instead.
    */
	ImageUrl?: PropertyAnnotationValue<Edm.String>;
	/**
        Image URL for the entity type
    */
	TypeImageUrl?: PropertyAnnotationValue<Edm.String>;
	/**
        Main information on the business card
    */
	MainInfo?: AnnotationTerm<DataFieldTypes>;
	/**
        Additional information on the business card
    */
	SecondaryInfo?: AnnotationTerm<DataFieldTypes>;
};

// Term
/**
  Collection of data fields for representation in a table or list
*/
export type LineItem = AnnotationTerm<DataFieldAbstractTypes[]>;

// Term
/**
  Collection of data fields describing the status of an entity
*/
export type StatusInfo = AnnotationTerm<DataFieldAbstractTypes[]>;

// Term
/**
  Group of fields with an optional label
*/
export type FieldGroup = AnnotationTerm<FieldGroupTypeTypes>;

// ComplexType
export type FieldGroupType = ComplexType & {
	$Type: UIAnnotationTypes.FieldGroupType;
	/**
        Label for the field group
    */
	Label?: PropertyAnnotationValue<Edm.String>;
	/**
        Collection of data fields
    */
	Data: AnnotationTerm<DataFieldAbstractTypes[]>;
};

// Term
/**
  Group of semantically connected fields with a representation template and an optional label
*/
export type ConnectedFields = AnnotationTerm<ConnectedFieldsTypeTypes>;

// ComplexType
/**
  Group of semantically connected fields with a representation template and an optional label
*/
export type ConnectedFieldsType = ComplexType & {
	$Type: UIAnnotationTypes.ConnectedFieldsType;
	/**
        Label for the connected fields
    */
	Label?: PropertyAnnotationValue<Edm.String>;
	/**
        Template for representing the connected fields
    */
	Template: PropertyAnnotationValue<Edm.String>;
	/**
        Dictionary of template variables
    */
	Data: Core.Dictionary;
};

// Term
/**
  Collection of geographic locations
*/
export type GeoLocations = AnnotationTerm<GeoLocationTypeTypes[]>;

// Term
/**
  Geographic location
*/
export type GeoLocation = AnnotationTerm<GeoLocationTypeTypes>;

// ComplexType
/**
  Properties that define a geographic location
*/
export type GeoLocationType = ComplexType & {
	$Type: UIAnnotationTypes.GeoLocationType;
	/**
        Geographic latitude
    */
	Latitude?: PropertyAnnotationValue<Edm.Double>;
	/**
        Geographic longitude
    */
	Longitude?: PropertyAnnotationValue<Edm.Double>;
	/**
        A point in a round-earth coordinate system
    */
	Location?: PropertyAnnotationValue<Edm.GeographyPoint>;
	/**
        vCard-style address
    */
	Address?: Communication.AddressType;
};

// Term
/**
  Collection of contacts
*/
export type Contacts = AnnotationTerm<Edm.AnnotationPath<any>[]>;

// Term
/**
  Properties that describe a media resource
*/
export type MediaResource = AnnotationTerm<MediaResourceTypeTypes>;

// ComplexType
export type MediaResourceType = ComplexType & {
	$Type: UIAnnotationTypes.MediaResourceType;
	/**
        URL of media resource
    */
	Url: PropertyAnnotationValue<Edm.String>;
	/**
        Content type, such as application/pdf, video/x-flv, image/jpeg
    */
	ContentType?: PropertyAnnotationValue<Edm.String>;
	/**
        Resource size in bytes
    */
	ByteSize?: PropertyAnnotationValue<Edm.Int64>;
	/**
        Date of last change
    */
	ChangedAt?: PropertyAnnotationValue<Edm.DateTimeOffset>;
	/**
        Thumbnail image
    */
	Thumbnail?: AnnotationTerm<ImageTypeTypes>;
	/**
        Resource title
    */
	Title: AnnotationTerm<DataFieldTypes>;
	/**
        Resource description
    */
	Description?: AnnotationTerm<DataFieldTypes>;
};

// ComplexType
export type ImageType = ComplexType & {
	$Type: UIAnnotationTypes.ImageType;
	/**
        URL of image
    */
	Url: PropertyAnnotationValue<Edm.String>;
	/**
        Width of image
    */
	Width?: PropertyAnnotationValue<Edm.String>;
	/**
        Height of image
    */
	Height?: PropertyAnnotationValue<Edm.String>;
};

// Term
/**
  Visualization of a single point of data, typically a number; may also be textual, e.g. a status value
*/
export type DataPoint = AnnotationTerm<DataPointTypeTypes>;

// ComplexType
export type DataPointType = ComplexType & {
	$Type: UIAnnotationTypes.DataPointType;
	/**
        Title of the data point
    */
	Title?: PropertyAnnotationValue<Edm.String>;
	/**
        Short description
    */
	Description?: PropertyAnnotationValue<Edm.String>;
	/**
        Full description
    */
	LongDescription?: PropertyAnnotationValue<Edm.String>;
	/**
        Numeric value
    */
	Value: PropertyAnnotationValue<Edm.PrimitiveType>;
	/**
        Target value
    */
	TargetValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
	/**
        Forecast value
    */
	ForecastValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
	/**
        Minimum value (for output rendering)
    */
	MinimumValue?: PropertyAnnotationValue<Edm.Decimal>;
	/**
        Maximum value (for output rendering)
    */
	MaximumValue?: PropertyAnnotationValue<Edm.Decimal>;
	/**
        Number format
    */
	ValueFormat?: AnnotationTerm<NumberFormatTypes>;
	/**
        Preferred visualization
    */
	Visualization?: VisualizationType;
	/**
        
              Sample size used for the determination of the data point; should contain just integer value as Edm.Byte, Edm.SByte, Edm.Intxx, and Edm.Decimal with scale 0.
            
    */
	SampleSize?: PropertyAnnotationValue<Edm.PrimitiveType>;
	/**
        Reference period
    */
	ReferencePeriod?: AnnotationTerm<ReferencePeriodTypes>;
	/**
        Service-calculated criticality, alternative to CriticalityCalculation
    */
	Criticality?: CriticalityType;
	/**
        Custom labels for the criticality legend. Annotation path MUST end in UI.CriticalityLabels
    */
	CriticalityLabels?: Edm.AnnotationPath<any>;
	/**
        Decides if criticality is visualized in addition by means of an icon
    */
	CriticalityRepresentation?: CriticalityRepresentationType;
	/**
        Parameters for client-calculated criticality, alternative to Criticality
    */
	CriticalityCalculation?: AnnotationTerm<CriticalityCalculationTypeTypes>;
	/**
        Service-calculated trend, alternative to TrendCalculation
    */
	Trend?: TrendType;
	/**
        Parameters for client-calculated trend, alternative to Trend
    */
	TrendCalculation?: AnnotationTerm<TrendCalculationTypeTypes>;
	/**
        Contact person
    */
	Responsible?: Communication.ContactType;
};

// ComplexType
/**
  Describes how to visualise a number
*/
export type NumberFormat = ComplexType & {
	$Type: UIAnnotationTypes.NumberFormat;
	/**
        Display value in *ScaleFactor* units, e.g. 1000 for k (kilo), 1e6 for M (Mega)
    */
	ScaleFactor?: PropertyAnnotationValue<Edm.Decimal>;
	/**
        Number of fractional digits of the scaled value to be visualized
    */
	NumberOfFractionalDigits?: PropertyAnnotationValue<Edm.Byte>;
};

// EnumType
export const enum VisualizationType {
	/**
	Visualize as a number
    */
	/**
	undefined
    */
	Number = "UI.VisualizationType/Number",
	/**
	Visualize as bullet chart - requires TargetValue
    */
	/**
	undefined
    */
	BulletChart = "UI.VisualizationType/BulletChart",
	/**
	Visualize as progress indicator - requires TargetValue
    */
	/**
	undefined
    */
	Progress = "UI.VisualizationType/Progress",
	/**
	Visualize as partially or completely filled stars/hearts/... - requires TargetValue
    */
	/**
	undefined
    */
	Rating = "UI.VisualizationType/Rating",
	/**
	Visualize as donut, optionally with missing segment - requires TargetValue
    */
	/**
	undefined
    */
	Donut = "UI.VisualizationType/Donut",
	/**
	Visualize as delta bullet chart - requires TargetValue
    */
	/**
	undefined
    */
	DeltaBulletChart = "UI.VisualizationType/DeltaBulletChart"
}

// ComplexType
/**
  Reference period
*/
export type ReferencePeriod = ComplexType & {
	$Type: UIAnnotationTypes.ReferencePeriod;
	/**
        Short description of the reference period
    */
	Description?: PropertyAnnotationValue<Edm.String>;
	/**
        Start of the reference period
    */
	Start?: PropertyAnnotationValue<Edm.DateTimeOffset>;
	/**
        End of the reference period
    */
	End?: PropertyAnnotationValue<Edm.DateTimeOffset>;
};

// EnumType
/**
  Criticality of a value or status, represented e.g. via semantic colors (https://experience.sap.com/fiori-design-web/foundation/colors/#semantic-colors)
*/
export const enum CriticalityType {
	/**
	Very negative / dark-red status - risk - out of stock - late
    */
	/**
	undefined
    */
	VeryNegative = "UI.CriticalityType/VeryNegative",
	/**
	Neutral / grey status - inactive - open - in progress
    */
	/**
	undefined
    */
	Neutral = "UI.CriticalityType/Neutral",
	/**
	Negative / red status - attention - overload - alert
    */
	/**
	undefined
    */
	Negative = "UI.CriticalityType/Negative",
	/**
	Critical / orange status - warning
    */
	/**
	undefined
    */
	Critical = "UI.CriticalityType/Critical",
	/**
	Positive / green status - completed - available - on track - acceptable
    */
	/**
	undefined
    */
	Positive = "UI.CriticalityType/Positive",
	/**
	Very positive / blue status - above max stock - excess
    */
	/**
	undefined
    */
	VeryPositive = "UI.CriticalityType/VeryPositive"
}

// ComplexType
/**
  Describes how to calculate the criticality of a value depending on the improvement direction
*/
export type CriticalityCalculationType = ComplexType &
	Omit<CriticalityThresholdsType, "$Type"> & {
		$Type: UIAnnotationTypes.CriticalityCalculationType;
		/**
        Reference value for the calculation, e.g. number of sales for the last year
    */
		ReferenceValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
		/**
        Calculate with a relative difference
    */
		IsRelativeDifference: PropertyAnnotationValue<Edm.Boolean>;
		/**
        Describes in which direction the value improves
    */
		ImprovementDirection: ImprovementDirectionType;
		/**
        List of thresholds depending on the aggregation level as a set of constant values
    */
		ConstantThresholds: AnnotationTerm<LevelThresholdsTypeTypes[]>;
	};

// ComplexType
/**
  Thresholds for calculating the criticality of a value
*/
export type CriticalityThresholdsType = ComplexType & {
	$Type: UIAnnotationTypes.CriticalityThresholdsType;
	/**
        Lowest value that is considered positive
    */
	AcceptanceRangeLowValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
	/**
        Highest value that is considered positive
    */
	AcceptanceRangeHighValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
	/**
        Lowest value that is considered neutral
    */
	ToleranceRangeLowValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
	/**
        Highest value that is considered neutral
    */
	ToleranceRangeHighValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
	/**
        Lowest value that is considered critical
    */
	DeviationRangeLowValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
	/**
        Highest value that is considered critical
    */
	DeviationRangeHighValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
};

// EnumType
/**
  Describes which direction of a value change is seen as an improvement
*/
export const enum ImprovementDirectionType {
	/**
	Lower is better
    */
	/**
	undefined
    */
	Minimize = "UI.ImprovementDirectionType/Minimize",
	/**
	Closer to the target is better
    */
	/**
	undefined
    */
	Target = "UI.ImprovementDirectionType/Target",
	/**
	Higher is better
    */
	/**
	undefined
    */
	Maximize = "UI.ImprovementDirectionType/Maximize"
}

// ComplexType
/**
  Thresholds for an aggregation level
*/
export type LevelThresholdsType = ComplexType &
	Omit<CriticalityThresholdsType, "$Type"> & {
		$Type: UIAnnotationTypes.LevelThresholdsType;
		/**
        An unordered tuple of dimensions, i.e. properties which are intended to be used for grouping in aggregating requests. In analytical UIs, e.g. an analytical chart, the aggregation level typically corresponds to the visible dimensions.
    */
		AggregationLevel: PropertyAnnotationValue<Edm.PropertyPath[]>;
	};

// EnumType
/**
  The trend of a value
*/
export const enum TrendType {
	/**
	Value grows strongly
    */
	/**
	undefined
    */
	StrongUp = "UI.TrendType/StrongUp",
	/**
	Value grows
    */
	/**
	undefined
    */
	Up = "UI.TrendType/Up",
	/**
	Value does not significantly grow or shrink
    */
	/**
	undefined
    */
	Sideways = "UI.TrendType/Sideways",
	/**
	Value shrinks
    */
	/**
	undefined
    */
	Down = "UI.TrendType/Down",
	/**
	Value shrinks strongly
    */
	/**
	undefined
    */
	StrongDown = "UI.TrendType/StrongDown"
}

// ComplexType
/**
  Describes how to calculate the trend of a value
*/
export type TrendCalculationType = ComplexType & {
	$Type: UIAnnotationTypes.TrendCalculationType;
	/**
        Reference value for the calculation, e.g. number of sales for the last year
    */
	ReferenceValue: PropertyAnnotationValue<Edm.PrimitiveType>;
	/**
        Calculate with a relative difference
    */
	IsRelativeDifference: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Threshold for Up
    */
	UpDifference: PropertyAnnotationValue<Edm.Decimal>;
	/**
        Threshold for StrongUp
    */
	StrongUpDifference: PropertyAnnotationValue<Edm.Decimal>;
	/**
        Threshold for Down
    */
	DownDifference: PropertyAnnotationValue<Edm.Decimal>;
	/**
        Threshold for StrongDown
    */
	StrongDownDifference: PropertyAnnotationValue<Edm.Decimal>;
};

// Term
/**
  A Key Performance Indicator (KPI) bundles a SelectionVariant and a DataPoint, and provides details for progressive disclosure
*/
export type KPI = AnnotationTerm<KPITypeTypes>;

// ComplexType
export type KPIType = ComplexType & {
	$Type: UIAnnotationTypes.KPIType;
	/**
        Optional identifier to reference this instance from an external context
    */
	ID?: PropertyAnnotationValue<Edm.String>;
	/**
        Very short description
    */
	ShortDescription?: PropertyAnnotationValue<Edm.String>;
	/**
        Selection variant, either specified inline or referencing another annotation via Path
    */
	SelectionVariant: AnnotationTerm<SelectionVariantTypeTypes>;
	/**
        Data point, either specified inline or referencing another annotation via Path
    */
	DataPoint: AnnotationTerm<DataPointTypeTypes>;
	/**
        Additional data points, either specified inline or referencing another annotation via Path
    */
	AdditionalDataPoints: AnnotationTerm<DataPointTypeTypes[]>;
	/**
        Contains information about KPI details, especially drill-down presentations
    */
	Detail?: AnnotationTerm<KPIDetailTypeTypes>;
};

// ComplexType
export type KPIDetailType = ComplexType & {
	$Type: UIAnnotationTypes.KPIDetailType;
	/**
        Presentation variant, either specified inline or referencing another annotation via Path
    */
	DefaultPresentationVariant?: AnnotationTerm<PresentationVariantTypeTypes>;
	/**
        A list of alternative presentation variants, either specified inline or referencing another annotation via Path
    */
	AlternativePresentationVariants: AnnotationTerm<PresentationVariantTypeTypes[]>;
	/**
        Name of the Semantic Object. If not specified, use Semantic Object annotated at the property referenced in KPI/DataPoint/Value
    */
	SemanticObject?: PropertyAnnotationValue<Edm.String>;
	/**
        Name of the Action on the Semantic Object. If not specified, let user choose which of the available actions to trigger.
    */
	Action?: PropertyAnnotationValue<Edm.String>;
};

// Term
/**
  Visualization of multiple data points
*/
export type Chart = AnnotationTerm<ChartDefinitionTypeTypes>;

// ComplexType
export type ChartDefinitionType = ComplexType & {
	$Type: UIAnnotationTypes.ChartDefinitionType;
	/**
        Title of the chart
    */
	Title?: PropertyAnnotationValue<Edm.String>;
	/**
        Short description
    */
	Description?: PropertyAnnotationValue<Edm.String>;
	/**
        Chart type
    */
	ChartType: ChartType;
	/**
        Describes the scale of the chart value axes
    */
	AxisScaling?: AnnotationTerm<ChartAxisScalingTypeTypes>;
	/**
        Measures of the chart, e.g. size and color in a bubble chart
    */
	Measures: PropertyAnnotationValue<Edm.PropertyPath[]>;
	/**
        Describes Attributes for Measures. All Measures used in this collection must also be part of the Measures Property.
    */
	MeasureAttributes: AnnotationTerm<ChartMeasureAttributeTypeTypes[]>;
	/**
        Dimensions of the chart, e.g. x- and y-axis of a bubble chart
    */
	Dimensions: PropertyAnnotationValue<Edm.PropertyPath[]>;
	/**
        Describes Attributes for Dimensions. All Dimensions used in this collection must also be part of the Dimensions Property.
    */
	DimensionAttributes: AnnotationTerm<ChartDimensionAttributeTypeTypes[]>;
	/**
        Available actions
    */
	Actions: AnnotationTerm<DataFieldForActionAbstractTypes[]>;
};

// EnumType
export const enum ChartType {
	Column = "UI.ChartType/Column",
	ColumnStacked = "UI.ChartType/ColumnStacked",
	ColumnDual = "UI.ChartType/ColumnDual",
	ColumnStackedDual = "UI.ChartType/ColumnStackedDual",
	ColumnStacked100 = "UI.ChartType/ColumnStacked100",
	ColumnStackedDual100 = "UI.ChartType/ColumnStackedDual100",
	Bar = "UI.ChartType/Bar",
	BarStacked = "UI.ChartType/BarStacked",
	BarDual = "UI.ChartType/BarDual",
	BarStackedDual = "UI.ChartType/BarStackedDual",
	BarStacked100 = "UI.ChartType/BarStacked100",
	BarStackedDual100 = "UI.ChartType/BarStackedDual100",
	Area = "UI.ChartType/Area",
	AreaStacked = "UI.ChartType/AreaStacked",
	AreaStacked100 = "UI.ChartType/AreaStacked100",
	HorizontalArea = "UI.ChartType/HorizontalArea",
	HorizontalAreaStacked = "UI.ChartType/HorizontalAreaStacked",
	HorizontalAreaStacked100 = "UI.ChartType/HorizontalAreaStacked100",
	Line = "UI.ChartType/Line",
	LineDual = "UI.ChartType/LineDual",
	Combination = "UI.ChartType/Combination",
	CombinationStacked = "UI.ChartType/CombinationStacked",
	CombinationDual = "UI.ChartType/CombinationDual",
	CombinationStackedDual = "UI.ChartType/CombinationStackedDual",
	HorizontalCombinationStacked = "UI.ChartType/HorizontalCombinationStacked",
	Pie = "UI.ChartType/Pie",
	Donut = "UI.ChartType/Donut",
	Scatter = "UI.ChartType/Scatter",
	Bubble = "UI.ChartType/Bubble",
	Radar = "UI.ChartType/Radar",
	HeatMap = "UI.ChartType/HeatMap",
	TreeMap = "UI.ChartType/TreeMap",
	Waterfall = "UI.ChartType/Waterfall",
	Bullet = "UI.ChartType/Bullet",
	VerticalBullet = "UI.ChartType/VerticalBullet",
	HorizontalWaterfall = "UI.ChartType/HorizontalWaterfall",
	HorizontalCombinationDual = "UI.ChartType/HorizontalCombinationDual",
	HorizontalCombinationStackedDual = "UI.ChartType/HorizontalCombinationStackedDual",
	Donut100 = "UI.ChartType/Donut100"
}

// ComplexType
export type ChartAxisScalingType = ComplexType & {
	$Type: UIAnnotationTypes.ChartAxisScalingType;
	/**
        Scale is fixed or adapts automatically to rendered values
    */
	ScaleBehavior: ChartAxisScaleBehaviorType;
	/**
        Settings for automatic scaling
    */
	AutoScaleBehavior?: AnnotationTerm<ChartAxisAutoScaleBehaviorTypeTypes>;
	/**
        Boundary values for fixed scaling of a stacking chart type with multiple measures
    */
	FixedScaleMultipleStackedMeasuresBoundaryValues?: AnnotationTerm<
		FixedScaleMultipleStackedMeasuresBoundaryValuesTypeTypes
	>;
};

// EnumType
export const enum ChartAxisScaleBehaviorType {
	/**
	Value axes scale automatically
    */
	/**
	undefined
    */
	AutoScale = "UI.ChartAxisScaleBehaviorType/AutoScale",
	/**
	Fixed minimum and maximum values are applied, which are derived from the @UI.MeasureAttributes.DataPoint/MinimumValue and .../MaximumValue annotation by default.
        For stacking chart types with multiple measures, they are taken from ChartAxisScalingType/FixedScaleMultipleStackedMeasuresBoundaryValues.
            
    */
	/**
	undefined
    */
	FixedScale = "UI.ChartAxisScaleBehaviorType/FixedScale"
}

// ComplexType
export type ChartAxisAutoScaleBehaviorType = ComplexType & {
	$Type: UIAnnotationTypes.ChartAxisAutoScaleBehaviorType;
	/**
        Forces the value axis to always display the zero value
    */
	ZeroAlwaysVisible: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Determines the automatic scaling
    */
	DataScope: ChartAxisAutoScaleDataScopeType;
};

// EnumType
export const enum ChartAxisAutoScaleDataScopeType {
	/**
	Minimum and maximum axes values are determined from the entire data set
    */
	/**
	undefined
    */
	DataSet = "UI.ChartAxisAutoScaleDataScopeType/DataSet",
	/**
	Minimum and maximum axes values are determined from the currently visible data. Scrolling will change the scale.
    */
	/**
	undefined
    */
	VisibleData = "UI.ChartAxisAutoScaleDataScopeType/VisibleData"
}

// ComplexType
export type FixedScaleMultipleStackedMeasuresBoundaryValuesType = ComplexType & {
	$Type: UIAnnotationTypes.FixedScaleMultipleStackedMeasuresBoundaryValuesType;
	/**
        Minimum value on value axes
    */
	MinimumValue: PropertyAnnotationValue<Edm.Decimal>;
	/**
        Maximum value on value axes
    */
	MaximumValue: PropertyAnnotationValue<Edm.Decimal>;
};

// ComplexType
export type ChartDimensionAttributeType = ComplexType & {
	$Type: UIAnnotationTypes.ChartDimensionAttributeType;
	Dimension?: PropertyAnnotationValue<Edm.PropertyPath>;
	Role?: ChartDimensionRoleType;
	/**
        For a dimension with a hierarchy, members are selected from this level. The root node of the hierarchy is at level 0.
    */
	HierarchyLevel?: PropertyAnnotationValue<Edm.Int32>;
	/**
        All values in this collection should be assigned to levels of the same color.
    */
	ValuesForSequentialColorLevels: PropertyAnnotationValue<Edm.String[]>;
	/**
        All values in this collection should be emphasized.
    */
	EmphasizedValues: PropertyAnnotationValue<Edm.String[]>;
	/**
        Assign a label to values with an emphasized representation. This is required, if more than one emphasized value has been specified.
    */
	EmphasisLabels?: AnnotationTerm<EmphasisLabelTypeTypes>;
};

// ComplexType
export type ChartMeasureAttributeType = ComplexType & {
	$Type: UIAnnotationTypes.ChartMeasureAttributeType;
	Measure?: PropertyAnnotationValue<Edm.PropertyPath>;
	Role?: ChartMeasureRoleType;
	/**
        Annotation path MUST end in @UI.DataPoint and the data point's Value MUST be the same property as in Measure
    */
	DataPoint?: Edm.AnnotationPath<any>;
	/**
        All measures for which this setting is true should be assigned to levels of the same color.
    */
	UseSequentialColorLevels: PropertyAnnotationValue<Edm.Boolean>;
};

// EnumType
export const enum ChartDimensionRoleType {
	Category = "UI.ChartDimensionRoleType/Category",
	Series = "UI.ChartDimensionRoleType/Series",
	Category2 = "UI.ChartDimensionRoleType/Category2"
}

// EnumType
export const enum ChartMeasureRoleType {
	Axis1 = "UI.ChartMeasureRoleType/Axis1",
	Axis2 = "UI.ChartMeasureRoleType/Axis2",
	Axis3 = "UI.ChartMeasureRoleType/Axis3"
}

// ComplexType
/**
  Assigns a label to the set of emphasized values and optionally also for non-emphasized values. This information can be used for semantic coloring.
*/
export type EmphasisLabelType = ComplexType & {
	$Type: UIAnnotationTypes.EmphasisLabelType;
	EmphasizedValuesLabel: PropertyAnnotationValue<Edm.String>;
	NonEmphasizedValuesLabel?: PropertyAnnotationValue<Edm.String>;
};

// Term
/**
  Assign criticalities to primitive values. This information can be used for semantic coloring.
*/
export type ValueCriticality = AnnotationTerm<ValueCriticalityTypeTypes[]>;

// ComplexType
/**
  Assigns a fixed criticality to a primitive value. This information can be used for semantic coloring.
*/
export type ValueCriticalityType = ComplexType & {
	$Type: UIAnnotationTypes.ValueCriticalityType;
	/**
        MUST be a fixed value of primitive type
    */
	Value?: PropertyAnnotationValue<Edm.PrimitiveType>;
	Criticality?: CriticalityType;
};

// Term
/**
  
              Assign labels to criticalities. This information can be used for semantic coloring.
              When applied to a property, a label for a criticality must be provided, if more than one value of the annotated property has been assigned to the same criticality.
              There must be no more than one label per criticality.
          
*/
export type CriticalityLabels = AnnotationTerm<CriticalityLabelTypeTypes[]>;

// ComplexType
/**
  Assigns a label to a criticality. This information can be used for semantic coloring.
*/
export type CriticalityLabelType = ComplexType & {
	$Type: UIAnnotationTypes.CriticalityLabelType;
	Criticality: CriticalityType;
	/**
        Criticality label
    */
	Label: PropertyAnnotationValue<Edm.String>;
};

// Term
/**
  Properties that might be relevant for filtering a collection of entities of this type
*/
export type SelectionFields = AnnotationTerm<Edm.PropertyPath[]>;

// Term
/**
  Collection of facets
*/
export type Facets = AnnotationTerm<FacetTypes[]>;

// Term
/**
  Facets for additional object header information
*/
export type HeaderFacets = AnnotationTerm<FacetTypes[]>;

// Term
/**
  Facets that may be used for a quick overview of the object
*/
export type QuickViewFacets = AnnotationTerm<FacetTypes[]>;

// Term
/**
  Facets that may be used for a (quick) create of the object
*/
export type QuickCreateFacets = AnnotationTerm<FacetTypes[]>;

// Term
/**
  Facets that reference UI.FieldGroup annotations to group filterable fields
*/
export type FilterFacets = AnnotationTerm<ReferenceFacetTypes[]>;

// ComplexType
/**
  Abstract base type for facets
*/
export type Facet = ComplexType & {
	$Type: UIAnnotationTypes.Facet;
	/**
        Facet label
    */
	Label?: PropertyAnnotationValue<Edm.String>;
	/**
        Unique identifier of a facet. ID should be stable, as long as the perceived semantics of the facet is unchanged.
    */
	ID?: PropertyAnnotationValue<Edm.String>;
};

// ComplexType
/**
  Collection of facets
*/
export type CollectionFacet = ComplexType &
	Omit<Facet, "$Type"> & {
		$Type: UIAnnotationTypes.CollectionFacet;
		/**
        Nested facets. An empty collection may be used as a placeholder for content added via extension points.
    */
		Facets: AnnotationTerm<FacetTypes[]>;
	};

// ComplexType
/**
  Facet that refers to a thing perspective, e.g. LineItem
*/
export type ReferenceFacet = ComplexType &
	Omit<Facet, "$Type"> & {
		$Type: UIAnnotationTypes.ReferenceFacet;
		/**
        Referenced information: Communication.Contact, Communication.Address, or a term that is tagged with UI.ThingPerspective, e.g. UI.StatusInfo, UI.LineItem, UI.Identification, UI.FieldGroup, UI.Badge
    */
		Target: Edm.AnnotationPath<any>;
	};

// ComplexType
/**
  Facet that refers to a URL
*/
export type ReferenceURLFacet = ComplexType &
	Omit<Facet, "$Type"> & {
		$Type: UIAnnotationTypes.ReferenceURLFacet;
		/**
        URL of referenced information
    */
		Url: PropertyAnnotationValue<Edm.String>;
		/**
        Media type of referenced information
    */
		UrlContentType?: PropertyAnnotationValue<Edm.String>;
	};

// Term
/**
  A SelectionPresentationVariant bundles a Selection Variant and a Presentation Variant
*/
export type SelectionPresentationVariant = AnnotationTerm<SelectionPresentationVariantTypeTypes>;

// ComplexType
export type SelectionPresentationVariantType = ComplexType & {
	$Type: UIAnnotationTypes.SelectionPresentationVariantType;
	/**
        Optional identifier to reference this variant from an external context
    */
	ID?: PropertyAnnotationValue<Edm.String>;
	/**
        Name of the bundling variant
    */
	Text?: PropertyAnnotationValue<Edm.String>;
	/**
        Selection variant, either specified inline or referencing another annotation via Path
    */
	SelectionVariant: AnnotationTerm<SelectionVariantTypeTypes>;
	/**
        Presentation variant, either specified inline or referencing another annotation via Path
    */
	PresentationVariant: AnnotationTerm<PresentationVariantTypeTypes>;
};

// Term
/**
  Defines how the result of a queried collection of entities is shaped and how this result is displayed
*/
export type PresentationVariant = AnnotationTerm<PresentationVariantTypeTypes>;

// ComplexType
export type PresentationVariantType = ComplexType & {
	$Type: UIAnnotationTypes.PresentationVariantType;
	/**
        Optional identifier to reference this variant from an external context
    */
	ID?: PropertyAnnotationValue<Edm.String>;
	/**
        Name of the presentation variant
    */
	Text?: PropertyAnnotationValue<Edm.String>;
	/**
        Maximum number of items that should be included in the result
    */
	MaxItems?: PropertyAnnotationValue<Edm.Int32>;
	/**
        Collection can be provided inline or as a reference to a Common.SortOrder annotation via Path
    */
	SortOrder: Common.SortOrderType[];
	/**
        Sequence of groupable properties p1, p2, ... defining how the result is composed of instances representing groups,
            one for each combination of value properties in the queried collection. The sequence specifies a certain level
            of aggregation for the queried collection, and every group instance will provide aggregated values for
            properties that are aggregatable. Moreover, the series of sub-sequences (p1), (p1, p2), ... forms a leveled hierarchy,
            which may become relevant in combination with `InitialExpansionLevel`.
    */
	GroupBy: PropertyAnnotationValue<Edm.PropertyPath[]>;
	/**
        Sub-sequence q1, q2, ... of properties p1, p2, ... specified in GroupBy. With this, additional levels of aggregation
            are requested in addition to the most granular level defined by GroupBy: Every element in the series of sub-sequences
            (q1), (q1, q2), ... introduces an additional aggregation level included in the result.
    */
	TotalBy: PropertyAnnotationValue<Edm.PropertyPath[]>;
	/**
        Aggregatable properties for which aggregated values should be provided for the additional aggregation levels specified in TotalBy.
    */
	Total: PropertyAnnotationValue<Edm.PropertyPath[]>;
	/**
        Result should include a grand total for the properties specified in Total
    */
	IncludeGrandTotal: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Level up to which the hierarchy defined for the queried collection should be expanded initially.
            The hierarchy may be implicitly imposed by the sequence of the GroupBy, or by an explicit hierarchy annotation.
    */
	InitialExpansionLevel: PropertyAnnotationValue<Edm.Int32>;
	/**
        Lists available visualization types. Currently supported types are `UI.LineItem`, `UI.Chart`, and `UI.DataPoint`.
              For each type, no more than a single annotation is meaningful. Multiple instances of the same visualization type
              shall be modeled with different presentation variants.
              A reference to `UI.Lineitem` should always be part of the collection (least common denominator for renderers).
              The first entry of the collection is the default visualization.
            
    */
	Visualizations: Edm.AnnotationPath<any>[];
	/**
        Properties that should always be included in the result of the queried collection
    */
	RequestAtLeast: PropertyAnnotationValue<Edm.PropertyPath[]>;
	/**
        Properties that should be presented for filtering a collection of entities.
            Can be provided inline or as a reference to a `UI.SelectionFields` annotation via Path.
    */
	SelectionFields: PropertyAnnotationValue<Edm.PropertyPath[]>;
};

// Term
/**
  A SelectionVariant denotes a combination of parameters and filters to query the annotated entity set
*/
export type SelectionVariant = AnnotationTerm<SelectionVariantTypeTypes>;

// ComplexType
export type SelectionVariantType = ComplexType & {
	$Type: UIAnnotationTypes.SelectionVariantType;
	/**
         May contain identifier to reference this instance from an external context
    */
	ID?: PropertyAnnotationValue<Edm.String>;
	/**
        Name of the selection variant
    */
	Text?: PropertyAnnotationValue<Edm.String>;
	/**
        Parameters of the selection variant
    */
	Parameters: AnnotationTerm<ParameterAbstractTypes[]>;
	/**
        Filter string for query part of URL, without `$filter=`
    */
	FilterExpression?: PropertyAnnotationValue<Edm.String>;
	/**
        ABAP Select Options Pattern
    */
	SelectOptions: AnnotationTerm<SelectOptionTypeTypes[]>;
};

// ComplexType
/**
  Key property of a parameter entity type
*/
export type ParameterAbstract = ComplexType & {
	$Type: UIAnnotationTypes.ParameterAbstract;
};

// ComplexType
/**
  Single-valued parameter
*/
export type Parameter = ComplexType &
	Omit<ParameterAbstract, "$Type"> & {
		$Type: UIAnnotationTypes.Parameter;
		/**
        Path to a key property of a parameter entity type
    */
		PropertyName: PropertyAnnotationValue<Edm.PropertyPath>;
		/**
        Value for the key property
    */
		PropertyValue: PropertyAnnotationValue<Edm.PrimitiveType>;
	};

// ComplexType
/**
  Interval parameter formed with a 'from' and a 'to' property
*/
export type IntervalParameter = ComplexType &
	Omit<ParameterAbstract, "$Type"> & {
		$Type: UIAnnotationTypes.IntervalParameter;
		/**
        Path to the 'from' property of a parameter entity type
    */
		PropertyNameFrom: PropertyAnnotationValue<Edm.PropertyPath>;
		/**
        Value for the 'from' property
    */
		PropertyValueFrom: PropertyAnnotationValue<Edm.PrimitiveType>;
		/**
        Path to the 'to' property of a parameter entity type
    */
		PropertyNameTo: PropertyAnnotationValue<Edm.PropertyPath>;
		/**
        Value for the 'to' property
    */
		PropertyValueTo: PropertyAnnotationValue<Edm.PrimitiveType>;
	};

// ComplexType
/**
  List of value ranges for a single property
*/
export type SelectOptionType = ComplexType & {
	$Type: UIAnnotationTypes.SelectOptionType;
	/**
        Path to the property
    */
	PropertyName: PropertyAnnotationValue<Edm.PropertyPath>;
	/**
        List of value ranges
    */
	Ranges: AnnotationTerm<SelectionRangeTypeTypes[]>;
};

// ComplexType
/**
  Value range. If the range option only requires a single value, the value must be in the property Low
*/
export type SelectionRangeType = ComplexType & {
	$Type: UIAnnotationTypes.SelectionRangeType;
	/**
        Include or exclude values
    */
	Sign: SelectionRangeSignType;
	/**
        Comparison operator
    */
	Option: SelectionRangeOptionType;
	/**
        Single value or lower interval boundary
    */
	Low: PropertyAnnotationValue<Edm.PrimitiveType>;
	/**
        Upper interval boundary
    */
	High?: PropertyAnnotationValue<Edm.PrimitiveType>;
};

// EnumType
export const enum SelectionRangeSignType {
	/**
	Inclusive
    */
	/**
	undefined
    */
	I = "UI.SelectionRangeSignType/I",
	/**
	Exclusive
    */
	/**
	undefined
    */
	E = "UI.SelectionRangeSignType/E"
}

// EnumType
/**
  Comparison operator
*/
export const enum SelectionRangeOptionType {
	/**
	Equal to
    */
	/**
	undefined
    */
	EQ = "UI.SelectionRangeOptionType/EQ",
	/**
	Between
    */
	/**
	undefined
    */
	BT = "UI.SelectionRangeOptionType/BT",
	/**
	Contains pattern
    */
	/**
	undefined
    */
	CP = "UI.SelectionRangeOptionType/CP",
	/**
	Less than or equal to
    */
	/**
	undefined
    */
	LE = "UI.SelectionRangeOptionType/LE",
	/**
	Greater than or equal to
    */
	/**
	undefined
    */
	GE = "UI.SelectionRangeOptionType/GE",
	/**
	Not equal to
    */
	/**
	undefined
    */
	NE = "UI.SelectionRangeOptionType/NE",
	/**
	Not between
    */
	/**
	undefined
    */
	NB = "UI.SelectionRangeOptionType/NB",
	/**
	Does not contain pattern
    */
	/**
	undefined
    */
	NP = "UI.SelectionRangeOptionType/NP",
	/**
	Greater than
    */
	/**
	undefined
    */
	GT = "UI.SelectionRangeOptionType/GT",
	/**
	Less than
    */
	/**
	undefined
    */
	LT = "UI.SelectionRangeOptionType/LT"
}

// Term
/**
  The annotated term is a Thing Perspective
*/
export type ThingPerspective = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  This Facet and all included Facets are the summary of the thing. At most one Facet of a thing can be tagged with this term
*/
export type IsSummary = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  This Facet and all included Facets are part of the Thing preview
*/
export type PartOfPreview = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Target MUST reference a UI.GeoLocation, Communication.Address or a collection of these
*/
export type Map = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Target MUST reference a UI.MediaResource
*/
export type Gallery = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Properties and terms annotated with this term MUST contain a valid URL referencing an resource with a MIME type image
*/
export type IsImageURL = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Properties annotated with this term MUST be a stream property annotated with a MIME type image
*/
export type IsImage = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Properties annotated with this annotation should be rendered as multi-line text (e.g. text area)
*/
export type MultiLineText = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  A short, human-readable text that gives a hint or an example to help the user with data entry
*/
export type Placeholder = AnnotationTerm<PropertyAnnotationValue<Edm.String>>;

// Term
/**
  Describes the arrangement of a code or ID value and its text
*/
export type TextArrangement = EnumValue<TextArrangementType>;

// EnumType
export const enum TextArrangementType {
	/**
	Text is first, followed by the code/ID (e.g. in parentheses)
    */
	/**
	undefined
    */
	TextFirst = "UI.TextArrangementType/TextFirst",
	/**
	Code/ID is first, followed by the text (e.g. separated by a dash)
    */
	/**
	undefined
    */
	TextLast = "UI.TextArrangementType/TextLast",
	/**
	Code/ID and text are represented separately
    */
	/**
	undefined
    */
	TextSeparate = "UI.TextArrangementType/TextSeparate",
	/**
	Only text is represented, code/ID is hidden (e.g. for UUIDs)
    */
	/**
	undefined
    */
	TextOnly = "UI.TextArrangementType/TextOnly"
}

// Term
/**
  Expresses the importance of e.g. a DataField or an annotation
*/
export type Importance = EnumValue<ImportanceType>;

// EnumType
export const enum ImportanceType {
	/**
	High importance
    */
	/**
	undefined
    */
	High = "UI.ImportanceType/High",
	/**
	Medium importance
    */
	/**
	undefined
    */
	Medium = "UI.ImportanceType/Medium",
	/**
	Low importance
    */
	/**
	undefined
    */
	Low = "UI.ImportanceType/Low"
}

// Term
/**
  Properties or facets (see UI.Facet) annotated with this term will not be rendered if the annotation evaluates to true.
*/
export type Hidden = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  EntitySets annotated with this term can control the visibility of the Create operation dynamically
*/
export type CreateHidden = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  EntitySets annotated with this term can control the visibility of the Edit/Save operation dynamically
*/
export type UpdateHidden = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  EntitySets annotated with this term can control the visibility of the Delete operation dynamically
*/
export type DeleteHidden = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Properties annotated with this term will not be rendered as filter criteria if the annotation evaluates to true.
*/
export type HiddenFilter = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Default representation of a property as a datafield, e.g. when the property is added as a table column or form field via personalization
*/
export type DataFieldDefault = AnnotationTerm<DataFieldAbstractTypes>;

// ComplexType
/**
  Elementary building block that represents a piece of data and/or allows triggering an action
*/
export type DataFieldAbstract = ComplexType & {
	$Type: UIAnnotationTypes.DataFieldAbstract;
	/**
        A short, human-readable text suitable for labels and captions in UIs
    */
	Label?: PropertyAnnotationValue<Edm.String>;
	/**
        Criticality of the data field value
    */
	Criticality?: CriticalityType;
	/**
        Decides if criticality is visualized in addition by means of an icon
    */
	CriticalityRepresentation?: CriticalityRepresentationType;
	/**
        Optional icon
    */
	IconUrl?: PropertyAnnotationValue<Edm.String>;
};

// EnumType
export const enum CriticalityRepresentationType {
	/**
	Criticality is represented with an icon
    */
	/**
	undefined
    */
	WithIcon = "UI.CriticalityRepresentationType/WithIcon",
	/**
	Criticality is represented without icon, e.g. only via text color
    */
	/**
	undefined
    */
	WithoutIcon = "UI.CriticalityRepresentationType/WithoutIcon",
	/**
	Criticality is represented only by using an icon
    */
	/**
	undefined
    */
	OnlyIcon = "UI.CriticalityRepresentationType/OnlyIcon"
}

// ComplexType
/**
  A structured piece of data described by an annotation
*/
export type DataFieldForAnnotation = ComplexType &
	Omit<DataFieldAbstract, "$Type"> & {
		$Type: UIAnnotationTypes.DataFieldForAnnotation;
		/**
        Target MUST reference an annotation of terms Communication.Contact, Communication.Address, UI.DataPoint, UI.Chart, UI.FieldGroup, or UI.ConnectedFields
    */
		Target: Edm.AnnotationPath<any>;
	};

// ComplexType
/**
  Triggers an action
*/
export type DataFieldForActionAbstract = ComplexType &
	Omit<DataFieldAbstract, "$Type"> & {
		$Type: UIAnnotationTypes.DataFieldForActionAbstract;
		/**
        Action should be placed close to (or even inside) the visualized term
    */
		Inline: PropertyAnnotationValue<Edm.Boolean>;
		/**
        Determines whether the action completes a process step (e.g. approve, reject).
    */
		Determining: PropertyAnnotationValue<Edm.Boolean>;
	};

// ComplexType
/**
  Triggers an OData action
*/
export type DataFieldForAction = ComplexType &
	Omit<DataFieldForActionAbstract, "$Type"> & {
		$Type: UIAnnotationTypes.DataFieldForAction;
		/**
        Qualified name of an Action, Function, ActionImport or FunctionImport in scope
    */
		Action: Common.ActionOverload;

		ActionTarget?: Edm.Action;
		/**
        Expresses how invocations of this action on multiple instances should be grouped
    */
		InvocationGrouping?: OperationGroupingType;
	};

// EnumType
export const enum OperationGroupingType {
	/**
	Invoke each action in isolation from other actions
    */
	/**
	undefined
    */
	Isolated = "UI.OperationGroupingType/Isolated",
	/**
	Group all actions into a single change set
    */
	/**
	undefined
    */
	ChangeSet = "UI.OperationGroupingType/ChangeSet"
}

// ComplexType
/**
  Triggers intent-based UI navigation
*/
export type DataFieldForIntentBasedNavigation = ComplexType &
	Omit<DataFieldForActionAbstract, "$Type"> & {
		$Type: UIAnnotationTypes.DataFieldForIntentBasedNavigation;
		/**
        Name of the Semantic Object
    */
		SemanticObject: PropertyAnnotationValue<Edm.String>;
		/**
        Name of the Action on the Semantic Object. If not specified, let user choose which of the available actions to trigger.
    */
		Action?: PropertyAnnotationValue<Edm.String>;
		/**
        Determines whether  a context needs to be passed to the target of this navigation.
    */
		RequiresContext: PropertyAnnotationValue<Edm.Boolean>;
		/**
        Maps properties of the annotated entity type to properties of the Semantic Object
    */
		Mapping: Common.SemanticObjectMappingType[];
	};

// ComplexType
/**
  A piece of data
*/
export type DataField = ComplexType &
	Omit<DataFieldAbstract, "$Type"> & {
		$Type: UIAnnotationTypes.DataField;
		/**
        The data field's value
    */
		Value: PropertyAnnotationValue<Edm.PrimitiveType>;
	};

// ComplexType
/**
  A piece of data that allows triggering an OData action
*/
export type DataFieldWithAction = ComplexType &
	Omit<DataField, "$Type"> & {
		$Type: UIAnnotationTypes.DataFieldWithAction;
		/**
        Qualified name of an Action, Function, ActionImport or FunctionImport in scope
    */
		Action: Common.QualifiedName;

		ActionTarget?: Edm.Action;
	};

// ComplexType
/**
  A piece of data that allows triggering intent-based UI navigation
*/
export type DataFieldWithIntentBasedNavigation = ComplexType &
	Omit<DataField, "$Type"> & {
		$Type: UIAnnotationTypes.DataFieldWithIntentBasedNavigation;
		/**
        Name of the Semantic Object
    */
		SemanticObject: PropertyAnnotationValue<Edm.String>;
		/**
        Name of the Action on the Semantic Object. If not specified, let user choose which of the available actions to trigger.
    */
		Action?: PropertyAnnotationValue<Edm.String>;
		/**
        Maps properties of the annotated entity type to properties of the Semantic Object
    */
		Mapping: Common.SemanticObjectMappingType[];
	};

// ComplexType
/**
  A piece of data that allows navigating to related data
*/
export type DataFieldWithNavigationPath = ComplexType &
	Omit<DataField, "$Type"> & {
		$Type: UIAnnotationTypes.DataFieldWithNavigationPath;
		/**
        Contains either a navigation property or a term cast, where term is of type Edm.EntityType or a concrete entity type or a collection of these types
    */
		Target: PropertyAnnotationValue<Edm.NavigationPropertyPath>;
	};

// ComplexType
/**
  A piece of data that allows navigating to other information on the Web
*/
export type DataFieldWithUrl = ComplexType &
	Omit<DataField, "$Type"> & {
		$Type: UIAnnotationTypes.DataFieldWithUrl;
		/**
        Target of the hyperlink
    */
		Url: PropertyAnnotationValue<Edm.String>;
		/**
        Media type of the hyperlink target, e.g. `video/mp4`
    */
		UrlContentType?: PropertyAnnotationValue<Edm.String>;
	};

// Term
/**
   Service-calculated criticality, alternative to UI.CriticalityCalculation
*/
export type Criticality = EnumValue<CriticalityType>;

// Term
/**
  Parameters for client-calculated criticality, alternative to UI.Criticality
*/
export type CriticalityCalculation = AnnotationTerm<CriticalityCalculationTypeTypes>;

// Term
/**
  Sort by the referenced property instead of by the annotated property
*/
export type OrderBy = AnnotationTerm<Edm.PropertyPath>;

// Term
/**
  Define default values for action parameters
*/
export type ParameterDefaultValue = AnnotationTerm<Edm.PrimitiveType>;

// Term
/**
  Indicates whether a field contains or has a recommended value
*/
export type RecommendationState = AnnotationTerm<PropertyAnnotationValue<RecommendationStateType>>;

// Typedefinition
/**
  Indicates whether a field contains or has a recommended value
*/
export type RecommendationStateType = Edm.Byte;

// Term
/**
  Specifies how to get a list of recommended values for a property or parameter
*/
export type RecommendationList = AnnotationTerm<RecommendationListTypeTypes>;

// ComplexType
/**
  Reference to a recommendation list
*/
export type RecommendationListType = ComplexType & {
	$Type: UIAnnotationTypes.RecommendationListType;
	/**
        Resource path of a collection of recommended values
    */
	CollectionPath: PropertyAnnotationValue<Edm.String>;
	/**
        Name of the property within the collection of recommended values that describes the rank of the recommendation
    */
	RankProperty: PropertyAnnotationValue<Edm.String>;
	/**
        List of pairs of a local property and recommended value property
    */
	Binding: AnnotationTerm<RecommendationBindingTypes[]>;
};

// ComplexType
export type RecommendationBinding = ComplexType & {
	$Type: UIAnnotationTypes.RecommendationBinding;
	/**
        Path to editable property for which recommended values exist
    */
	LocalDataProperty: PropertyAnnotationValue<Edm.PropertyPath>;
	/**
        Path to property in the collection of recommended values. Format is identical to PropertyPath annotations.
    */
	ValueListProperty: PropertyAnnotationValue<Edm.String>;
};

// Term
/**
  The contents of this property must not be propagated to the app-to-app navigation context
*/
export type ExcludeFromNavigationContext = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
export const enum UIAnnotationTerms {
	HeaderInfo = "com.sap.vocabularies.UI.v1.HeaderInfo",
	Identification = "com.sap.vocabularies.UI.v1.Identification",
	Badge = "com.sap.vocabularies.UI.v1.Badge",
	LineItem = "com.sap.vocabularies.UI.v1.LineItem",
	StatusInfo = "com.sap.vocabularies.UI.v1.StatusInfo",
	FieldGroup = "com.sap.vocabularies.UI.v1.FieldGroup",
	ConnectedFields = "com.sap.vocabularies.UI.v1.ConnectedFields",
	GeoLocations = "com.sap.vocabularies.UI.v1.GeoLocations",
	GeoLocation = "com.sap.vocabularies.UI.v1.GeoLocation",
	Contacts = "com.sap.vocabularies.UI.v1.Contacts",
	MediaResource = "com.sap.vocabularies.UI.v1.MediaResource",
	DataPoint = "com.sap.vocabularies.UI.v1.DataPoint",
	KPI = "com.sap.vocabularies.UI.v1.KPI",
	Chart = "com.sap.vocabularies.UI.v1.Chart",
	ValueCriticality = "com.sap.vocabularies.UI.v1.ValueCriticality",
	CriticalityLabels = "com.sap.vocabularies.UI.v1.CriticalityLabels",
	SelectionFields = "com.sap.vocabularies.UI.v1.SelectionFields",
	Facets = "com.sap.vocabularies.UI.v1.Facets",
	HeaderFacets = "com.sap.vocabularies.UI.v1.HeaderFacets",
	QuickViewFacets = "com.sap.vocabularies.UI.v1.QuickViewFacets",
	QuickCreateFacets = "com.sap.vocabularies.UI.v1.QuickCreateFacets",
	FilterFacets = "com.sap.vocabularies.UI.v1.FilterFacets",
	SelectionPresentationVariant = "com.sap.vocabularies.UI.v1.SelectionPresentationVariant",
	PresentationVariant = "com.sap.vocabularies.UI.v1.PresentationVariant",
	SelectionVariant = "com.sap.vocabularies.UI.v1.SelectionVariant",
	ThingPerspective = "com.sap.vocabularies.UI.v1.ThingPerspective",
	IsSummary = "com.sap.vocabularies.UI.v1.IsSummary",
	PartOfPreview = "com.sap.vocabularies.UI.v1.PartOfPreview",
	Map = "com.sap.vocabularies.UI.v1.Map",
	Gallery = "com.sap.vocabularies.UI.v1.Gallery",
	IsImageURL = "com.sap.vocabularies.UI.v1.IsImageURL",
	IsImage = "com.sap.vocabularies.UI.v1.IsImage",
	MultiLineText = "com.sap.vocabularies.UI.v1.MultiLineText",
	Placeholder = "com.sap.vocabularies.UI.v1.Placeholder",
	TextArrangement = "com.sap.vocabularies.UI.v1.TextArrangement",
	Importance = "com.sap.vocabularies.UI.v1.Importance",
	Hidden = "com.sap.vocabularies.UI.v1.Hidden",
	CreateHidden = "com.sap.vocabularies.UI.v1.CreateHidden",
	UpdateHidden = "com.sap.vocabularies.UI.v1.UpdateHidden",
	DeleteHidden = "com.sap.vocabularies.UI.v1.DeleteHidden",
	HiddenFilter = "com.sap.vocabularies.UI.v1.HiddenFilter",
	DataFieldDefault = "com.sap.vocabularies.UI.v1.DataFieldDefault",
	Criticality = "com.sap.vocabularies.UI.v1.Criticality",
	CriticalityCalculation = "com.sap.vocabularies.UI.v1.CriticalityCalculation",
	OrderBy = "com.sap.vocabularies.UI.v1.OrderBy",
	ParameterDefaultValue = "com.sap.vocabularies.UI.v1.ParameterDefaultValue",
	RecommendationState = "com.sap.vocabularies.UI.v1.RecommendationState",
	RecommendationList = "com.sap.vocabularies.UI.v1.RecommendationList",
	ExcludeFromNavigationContext = "com.sap.vocabularies.UI.v1.ExcludeFromNavigationContext"
}
export const enum UIAnnotationTypes {
	HeaderInfoType = "com.sap.vocabularies.UI.v1.HeaderInfoType",
	BadgeType = "com.sap.vocabularies.UI.v1.BadgeType",
	FieldGroupType = "com.sap.vocabularies.UI.v1.FieldGroupType",
	ConnectedFieldsType = "com.sap.vocabularies.UI.v1.ConnectedFieldsType",
	GeoLocationType = "com.sap.vocabularies.UI.v1.GeoLocationType",
	MediaResourceType = "com.sap.vocabularies.UI.v1.MediaResourceType",
	ImageType = "com.sap.vocabularies.UI.v1.ImageType",
	DataPointType = "com.sap.vocabularies.UI.v1.DataPointType",
	NumberFormat = "com.sap.vocabularies.UI.v1.NumberFormat",
	ReferencePeriod = "com.sap.vocabularies.UI.v1.ReferencePeriod",
	CriticalityCalculationType = "com.sap.vocabularies.UI.v1.CriticalityCalculationType",
	CriticalityThresholdsType = "com.sap.vocabularies.UI.v1.CriticalityThresholdsType",
	LevelThresholdsType = "com.sap.vocabularies.UI.v1.LevelThresholdsType",
	TrendCalculationType = "com.sap.vocabularies.UI.v1.TrendCalculationType",
	KPIType = "com.sap.vocabularies.UI.v1.KPIType",
	KPIDetailType = "com.sap.vocabularies.UI.v1.KPIDetailType",
	ChartDefinitionType = "com.sap.vocabularies.UI.v1.ChartDefinitionType",
	ChartAxisScalingType = "com.sap.vocabularies.UI.v1.ChartAxisScalingType",
	ChartAxisAutoScaleBehaviorType = "com.sap.vocabularies.UI.v1.ChartAxisAutoScaleBehaviorType",
	FixedScaleMultipleStackedMeasuresBoundaryValuesType = "com.sap.vocabularies.UI.v1.FixedScaleMultipleStackedMeasuresBoundaryValuesType",
	ChartDimensionAttributeType = "com.sap.vocabularies.UI.v1.ChartDimensionAttributeType",
	ChartMeasureAttributeType = "com.sap.vocabularies.UI.v1.ChartMeasureAttributeType",
	EmphasisLabelType = "com.sap.vocabularies.UI.v1.EmphasisLabelType",
	ValueCriticalityType = "com.sap.vocabularies.UI.v1.ValueCriticalityType",
	CriticalityLabelType = "com.sap.vocabularies.UI.v1.CriticalityLabelType",
	Facet = "com.sap.vocabularies.UI.v1.Facet",
	CollectionFacet = "com.sap.vocabularies.UI.v1.CollectionFacet",
	ReferenceFacet = "com.sap.vocabularies.UI.v1.ReferenceFacet",
	ReferenceURLFacet = "com.sap.vocabularies.UI.v1.ReferenceURLFacet",
	SelectionPresentationVariantType = "com.sap.vocabularies.UI.v1.SelectionPresentationVariantType",
	PresentationVariantType = "com.sap.vocabularies.UI.v1.PresentationVariantType",
	SelectionVariantType = "com.sap.vocabularies.UI.v1.SelectionVariantType",
	ParameterAbstract = "com.sap.vocabularies.UI.v1.ParameterAbstract",
	Parameter = "com.sap.vocabularies.UI.v1.Parameter",
	IntervalParameter = "com.sap.vocabularies.UI.v1.IntervalParameter",
	SelectOptionType = "com.sap.vocabularies.UI.v1.SelectOptionType",
	SelectionRangeType = "com.sap.vocabularies.UI.v1.SelectionRangeType",
	DataFieldAbstract = "com.sap.vocabularies.UI.v1.DataFieldAbstract",
	DataFieldForAnnotation = "com.sap.vocabularies.UI.v1.DataFieldForAnnotation",
	DataFieldForActionAbstract = "com.sap.vocabularies.UI.v1.DataFieldForActionAbstract",
	DataFieldForAction = "com.sap.vocabularies.UI.v1.DataFieldForAction",
	DataFieldForIntentBasedNavigation = "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation",
	DataField = "com.sap.vocabularies.UI.v1.DataField",
	DataFieldWithAction = "com.sap.vocabularies.UI.v1.DataFieldWithAction",
	DataFieldWithIntentBasedNavigation = "com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation",
	DataFieldWithNavigationPath = "com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath",
	DataFieldWithUrl = "com.sap.vocabularies.UI.v1.DataFieldWithUrl",
	RecommendationListType = "com.sap.vocabularies.UI.v1.RecommendationListType",
	RecommendationBinding = "com.sap.vocabularies.UI.v1.RecommendationBinding"
}

export type HeaderInfoTypeTypes = AnnotationTerm<HeaderInfoType>;
export type BadgeTypeTypes = AnnotationTerm<BadgeType>;
export type FieldGroupTypeTypes = AnnotationTerm<FieldGroupType>;
export type ConnectedFieldsTypeTypes = AnnotationTerm<ConnectedFieldsType>;
export type GeoLocationTypeTypes = AnnotationTerm<GeoLocationType>;
export type MediaResourceTypeTypes = AnnotationTerm<MediaResourceType>;
export type ImageTypeTypes = AnnotationTerm<ImageType>;
export type DataPointTypeTypes = AnnotationTerm<DataPointType>;
export type NumberFormatTypes = AnnotationTerm<NumberFormat>;
export type ReferencePeriodTypes = AnnotationTerm<ReferencePeriod>;
export type CriticalityCalculationTypeTypes = AnnotationTerm<CriticalityCalculationType>;
export type CriticalityThresholdsTypeTypes = AnnotationTerm<
	CriticalityThresholdsType | CriticalityCalculationTypeTypes | LevelThresholdsTypeTypes
>;
export type LevelThresholdsTypeTypes = AnnotationTerm<LevelThresholdsType>;
export type TrendCalculationTypeTypes = AnnotationTerm<TrendCalculationType>;
export type KPITypeTypes = AnnotationTerm<KPIType>;
export type KPIDetailTypeTypes = AnnotationTerm<KPIDetailType>;
export type ChartDefinitionTypeTypes = AnnotationTerm<ChartDefinitionType>;
export type ChartAxisScalingTypeTypes = AnnotationTerm<ChartAxisScalingType>;
export type ChartAxisAutoScaleBehaviorTypeTypes = AnnotationTerm<ChartAxisAutoScaleBehaviorType>;
export type FixedScaleMultipleStackedMeasuresBoundaryValuesTypeTypes = AnnotationTerm<
	FixedScaleMultipleStackedMeasuresBoundaryValuesType
>;
export type ChartDimensionAttributeTypeTypes = AnnotationTerm<ChartDimensionAttributeType>;
export type ChartMeasureAttributeTypeTypes = AnnotationTerm<ChartMeasureAttributeType>;
export type EmphasisLabelTypeTypes = AnnotationTerm<EmphasisLabelType>;
export type ValueCriticalityTypeTypes = AnnotationTerm<ValueCriticalityType>;
export type CriticalityLabelTypeTypes = AnnotationTerm<CriticalityLabelType>;
export type FacetTypes = AnnotationTerm<CollectionFacetTypes | ReferenceFacetTypes | ReferenceURLFacetTypes>;
export type CollectionFacetTypes = AnnotationTerm<CollectionFacet>;
export type ReferenceFacetTypes = AnnotationTerm<ReferenceFacet>;
export type ReferenceURLFacetTypes = AnnotationTerm<ReferenceURLFacet>;
export type SelectionPresentationVariantTypeTypes = AnnotationTerm<SelectionPresentationVariantType>;
export type PresentationVariantTypeTypes = AnnotationTerm<PresentationVariantType>;
export type SelectionVariantTypeTypes = AnnotationTerm<SelectionVariantType>;
export type ParameterAbstractTypes = AnnotationTerm<ParameterTypes | IntervalParameterTypes>;
export type ParameterTypes = AnnotationTerm<Parameter>;
export type IntervalParameterTypes = AnnotationTerm<IntervalParameter>;
export type SelectOptionTypeTypes = AnnotationTerm<SelectOptionType>;
export type SelectionRangeTypeTypes = AnnotationTerm<SelectionRangeType>;
export type DataFieldAbstractTypes = AnnotationTerm<
	DataFieldForAnnotationTypes | DataFieldForActionAbstractTypes | DataFieldTypes
>;
export type DataFieldForAnnotationTypes = AnnotationTerm<DataFieldForAnnotation>;
export type DataFieldForActionAbstractTypes = AnnotationTerm<
	DataFieldForActionTypes | DataFieldForIntentBasedNavigationTypes
>;
export type DataFieldForActionTypes = AnnotationTerm<DataFieldForAction>;
export type DataFieldForIntentBasedNavigationTypes = AnnotationTerm<DataFieldForIntentBasedNavigation>;
export type DataFieldTypes = AnnotationTerm<
	| DataField
	| DataFieldWithActionTypes
	| DataFieldWithIntentBasedNavigationTypes
	| DataFieldWithNavigationPathTypes
	| DataFieldWithUrlTypes
>;
export type DataFieldWithActionTypes = AnnotationTerm<DataFieldWithAction>;
export type DataFieldWithIntentBasedNavigationTypes = AnnotationTerm<DataFieldWithIntentBasedNavigation>;
export type DataFieldWithNavigationPathTypes = AnnotationTerm<DataFieldWithNavigationPath>;
export type DataFieldWithUrlTypes = AnnotationTerm<DataFieldWithUrl>;
export type RecommendationListTypeTypes = AnnotationTerm<RecommendationListType>;
export type RecommendationBindingTypes = AnnotationTerm<RecommendationBinding>;
