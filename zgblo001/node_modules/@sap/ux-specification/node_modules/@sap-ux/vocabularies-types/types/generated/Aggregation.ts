import * as Core from "./Core";
import * as Edm from "../Edm";
import AnnotationTerm = Edm.AnnotationTerm;
import PropertyAnnotationValue = Edm.PropertyAnnotationValue;
import EnumValue = Edm.EnumValue;
import ComplexType = Edm.ComplexType;

// Term
/**
  This structured type or entity container supports the $apply system query option
*/
export type ApplySupported = AnnotationTerm<ApplySupportedTypeTypes>;

// ComplexType
export type ApplySupportedType = ComplexType & {
	$Type: AggregationAnnotationTypes.ApplySupportedType;
	/**
        Transformations that can be used in $apply
    */
	Transformations: PropertyAnnotationValue<Edm.String[]>;
	/**
        Qualified names of custom aggregation methods that can be used in aggregate(...with...)
    */
	CustomAggregationMethods: PropertyAnnotationValue<Edm.String[]>;
	/**
        The service supports rollup hierarchies in a groupby transformation
    */
	Rollup: RollupType;
	/**
        Only properties tagged as Groupable can be used in the groupby transformation, and only those tagged as Aggregatable can be used in the aggregate transformation
    */
	PropertyRestrictions: PropertyAnnotationValue<Edm.Boolean>;
};

// EnumType
/**
  The number of rollup operators allowed in a groupby transformation
*/
export const enum RollupType {
	/**
	No rollup support
    */
	/**
	undefined
    */
	None = "Aggregation.RollupType/None",
	/**
	Only one rollup operator per groupby
    */
	/**
	undefined
    */
	SingleHierarchy = "Aggregation.RollupType/SingleHierarchy",
	/**
	Full rollup support
    */
	/**
	undefined
    */
	MultipleHierarchies = "Aggregation.RollupType/MultipleHierarchies"
}

// Term
/**
  This property can be used in the groupby transformation
*/
export type Groupable = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  This property can be used in the aggregate transformation
*/
export type Aggregatable = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Dynamic property that can be used in the aggregate transformation
*/
export type CustomAggregate = AnnotationTerm<PropertyAnnotationValue<Edm.String>>;

// Term
/**
  The annotated property or custom aggregate is only well-defined in the context of these properties
*/
export type ContextDefiningProperties = AnnotationTerm<Edm.PropertyPath[]>;

// Term
/**
  Defines a leveled hierarchy by defining an ordered list of properties in the hierarchy
*/
export type LeveledHierarchy = AnnotationTerm<Edm.PropertyPath[]>;

// Term
/**
  Defines a recursive hierarchy.
*/
export type RecursiveHierarchy = AnnotationTerm<RecursiveHierarchyTypeTypes>;

// ComplexType
export type RecursiveHierarchyType = ComplexType & {
	$Type: AggregationAnnotationTypes.RecursiveHierarchyType;
	/**
        Property holding the hierarchy node value
    */
	NodeProperty: PropertyAnnotationValue<Edm.PropertyPath>;
	/**
        Property for navigating to the parent node
    */
	ParentNavigationProperty: PropertyAnnotationValue<Edm.NavigationPropertyPath>;
	/**
        Property holding the number of edges between the node and the root node
    */
	DistanceFromRootProperty?: PropertyAnnotationValue<Edm.PropertyPath>;
	/**
        Property indicating whether the node is a leaf of the hierarchy
    */
	IsLeafProperty?: PropertyAnnotationValue<Edm.PropertyPath>;
};

/**
  Returns true, if and only if the value of the node property of the specified hierarchy is the root of the hierarchy
*/
export type isroot = (Entity: Edm.EntityType, Hierarchy: any) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy is a descendant of the given parent node with a distance of less than or equal to the optionally specified maximum distance
*/
export type isdescendant = (
	Entity: Edm.EntityType,
	Hierarchy: any,
	Node: Edm.PrimitiveType,
	MaxDistance: Edm.Int16
) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy is an ancestor of the given child node with a distance of less than or equal to the optionally specified maximum distance
*/
export type isancestor = (
	Entity: Edm.EntityType,
	Hierarchy: any,
	Node: Edm.PrimitiveType,
	MaxDistance: Edm.Int16
) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy has the same parent node as the specified node
*/
export type issibling = (Entity: Edm.EntityType, Hierarchy: any, Node: Edm.PrimitiveType) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy has no descendants
*/
export type isleaf = (Entity: Edm.EntityType, Hierarchy: any) => Edm.Boolean;

// Term
/**
  This action or function is available on aggregated entities if the RequiredProperties are still defined
*/
export type AvailableOnAggregates = AnnotationTerm<AvailableOnAggregatesTypeTypes>;

// ComplexType
export type AvailableOnAggregatesType = ComplexType & {
	$Type: AggregationAnnotationTypes.AvailableOnAggregatesType;
	/**
        Properties required to apply this action or function
    */
	RequiredProperties: PropertyAnnotationValue<Edm.PropertyPath[]>;
};

export const enum AggregationAnnotationTerms {
	ApplySupported = "Org.OData.Aggregation.V1.ApplySupported",
	Groupable = "Org.OData.Aggregation.V1.Groupable",
	Aggregatable = "Org.OData.Aggregation.V1.Aggregatable",
	CustomAggregate = "Org.OData.Aggregation.V1.CustomAggregate",
	ContextDefiningProperties = "Org.OData.Aggregation.V1.ContextDefiningProperties",
	LeveledHierarchy = "Org.OData.Aggregation.V1.LeveledHierarchy",
	RecursiveHierarchy = "Org.OData.Aggregation.V1.RecursiveHierarchy",
	AvailableOnAggregates = "Org.OData.Aggregation.V1.AvailableOnAggregates"
}
export const enum AggregationAnnotationTypes {
	ApplySupportedType = "Org.OData.Aggregation.V1.ApplySupportedType",
	RecursiveHierarchyType = "Org.OData.Aggregation.V1.RecursiveHierarchyType",
	AvailableOnAggregatesType = "Org.OData.Aggregation.V1.AvailableOnAggregatesType"
}

export type ApplySupportedTypeTypes = AnnotationTerm<ApplySupportedType>;
export type RecursiveHierarchyTypeTypes = AnnotationTerm<RecursiveHierarchyType>;
export type AvailableOnAggregatesTypeTypes = AnnotationTerm<AvailableOnAggregatesType>;
