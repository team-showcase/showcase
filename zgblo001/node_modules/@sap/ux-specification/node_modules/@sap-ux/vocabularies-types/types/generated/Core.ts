import * as Validation from "./Validation";
import * as Edm from "../Edm";
import AnnotationTerm = Edm.AnnotationTerm;
import PropertyAnnotationValue = Edm.PropertyAnnotationValue;
import EnumValue = Edm.EnumValue;
import ComplexType = Edm.ComplexType;

// Term
/**
  A space-separated list of supported versions of the OData Protocol. Note that 4.0 is implied by 4.01 and does not need to be separately listed.
*/
export type ODataVersions = AnnotationTerm<PropertyAnnotationValue<Edm.String>>;

// Term
/**
  Service-defined value representing the version of the schema. Services MAY use semantic versioning, but clients MUST NOT assume this is the case.
*/
export type SchemaVersion = AnnotationTerm<PropertyAnnotationValue<Edm.String>>;

// Term
/**
  List of revisions of a model element
*/
export type Revisions = AnnotationTerm<RevisionTypeTypes[]>;

// ComplexType
export type RevisionType = ComplexType & {
	$Type: CoreAnnotationTypes.RevisionType;
	/**
        The schema version with which this revision was first published
    */
	Version?: PropertyAnnotationValue<Edm.String>;
	/**
        The kind of revision
    */
	Kind: RevisionKind;
	/**
        Text describing the reason for the revision
    */
	Description: PropertyAnnotationValue<Edm.String>;
};

// EnumType
export const enum RevisionKind {
	/**
	Model element was added
    */
	/**
	undefined
    */
	Added = "Core.RevisionKind/Added",
	/**
	Model element was modified
    */
	/**
	undefined
    */
	Modified = "Core.RevisionKind/Modified",
	/**
	Model element was deprecated
    */
	/**
	undefined
    */
	Deprecated = "Core.RevisionKind/Deprecated"
}

// Term
/**
  A brief description of a model element
*/
export type Description = AnnotationTerm<PropertyAnnotationValue<Edm.String>>;

// Term
/**
  A lengthy description of a model element
*/
export type LongDescription = AnnotationTerm<PropertyAnnotationValue<Edm.String>>;

// Term
/**
  Link to related information
*/
export type Links = AnnotationTerm<LinkTypes[]>;

// ComplexType
/**
  The Link term is inspired by the `atom:link` element, see [RFC4287](https://tools.ietf.org/html/rfc4287#section-4.2.7), and the `Link` HTTP header, see [RFC5988](https://tools.ietf.org/html/rfc5988)
*/
export type Link = ComplexType & {
	$Type: CoreAnnotationTypes.Link;
	/**
        Link relation type, see [IANA Link Relations](http://www.iana.org/assignments/link-relations/link-relations.xhtml)
    */
	rel: PropertyAnnotationValue<Edm.String>;
	/**
        URL of related information
    */
	href: PropertyAnnotationValue<Edm.String>;
};

// Term
/**
  Example for an instance of the annotated model element
*/
export type Example = AnnotationTerm<ExampleValueTypes>;

// ComplexType
export type ExampleValue = ComplexType & {
	$Type: CoreAnnotationTypes.ExampleValue;
	/**
        Description of the example value
    */
	Description?: PropertyAnnotationValue<Edm.String>;
};

// ComplexType
export type PrimitiveExampleValue = ComplexType &
	Omit<ExampleValue, "$Type"> & {
		$Type: CoreAnnotationTypes.PrimitiveExampleValue;
		/**
        Example value for the custom parameter
    */
		Value: PropertyAnnotationValue<Edm.PrimitiveType>;
	};

// ComplexType
export type ComplexExampleValue = ComplexType &
	Omit<ExampleValue, "$Type"> & {
		$Type: CoreAnnotationTypes.ComplexExampleValue;
		/**
        Example value for the custom parameter
    */
		Value: PropertyAnnotationValue<Edm.ComplexType>;
	};

// ComplexType
export type EntityExampleValue = ComplexType &
	Omit<ExampleValue, "$Type"> & {
		$Type: CoreAnnotationTypes.EntityExampleValue;
		/**
        Example value for the custom parameter
    */
		Value: PropertyAnnotationValue<Edm.EntityType>;
	};

// ComplexType
export type ExternalExampleValue = ComplexType &
	Omit<ExampleValue, "$Type"> & {
		$Type: CoreAnnotationTypes.ExternalExampleValue;
		/**
        Url reference to the value in its literal format
    */
		ExternalValue: PropertyAnnotationValue<Edm.String>;
	};

// Term
/**
  Instance annotation for warning and info messages
*/
export type Messages = AnnotationTerm<MessageTypeTypes[]>;

// ComplexType
export type MessageType = ComplexType & {
	$Type: CoreAnnotationTypes.MessageType;
	/**
        Machine-readable, language-independent message code
    */
	code: PropertyAnnotationValue<Edm.String>;
	/**
        Human-readable, language-dependent message text
    */
	message: PropertyAnnotationValue<Edm.String>;
	/**
        Severity of the message
    */
	severity: MessageSeverity;
	/**
        A path to the target of the message detail, relative to the annotated instance
    */
	target?: PropertyAnnotationValue<Edm.String>;
	/**
        List of detail messages
    */
	details: AnnotationTerm<MessageTypeTypes[]>;
};

// Typedefinition
export type MessageSeverity = Edm.String;

// Term
/**
  The annotated value is problematic
*/
export type ValueException = AnnotationTerm<ValueExceptionTypeTypes>;

// ComplexType
export type ExceptionType = ComplexType & {
	$Type: CoreAnnotationTypes.ExceptionType;
	/**
        Information about the exception
    */
	info?: AnnotationTerm<MessageTypeTypes>;
};

// ComplexType
export type ValueExceptionType = ComplexType &
	Omit<ExceptionType, "$Type"> & {
		$Type: CoreAnnotationTypes.ValueExceptionType;
		/**
        String representation of the exact value
    */
		value?: PropertyAnnotationValue<Edm.String>;
	};

// Term
/**
  The annotated instance within a success payload is problematic
*/
export type ResourceException = AnnotationTerm<ResourceExceptionTypeTypes>;

// ComplexType
export type ResourceExceptionType = ComplexType &
	Omit<ExceptionType, "$Type"> & {
		$Type: CoreAnnotationTypes.ResourceExceptionType;
		/**
        A GET request to this URL retries retrieving the problematic instance
    */
		retryLink?: PropertyAnnotationValue<Edm.String>;
	};

// Term
/**
  A modification operation failed on the annotated instance or collection within a success payload
*/
export type DataModificationException = AnnotationTerm<DataModificationExceptionTypeTypes>;

// ComplexType
export type DataModificationExceptionType = ComplexType &
	Omit<ExceptionType, "$Type"> & {
		$Type: CoreAnnotationTypes.DataModificationExceptionType;
		/**
        The kind of modification operation that failed
    */
		failedOperation: DataModificationOperationKind;
		/**
        Response code of the failed operation, e.g. 424 for a failed dependency
    */
		responseCode?: PropertyAnnotationValue<Edm.Int16>;
	};

// EnumType
export const enum DataModificationOperationKind {
	/**
	Insert new instance
    */
	/**
	undefined
    */
	insert = "Core.DataModificationOperationKind/insert",
	/**
	Update existing instance
    */
	/**
	undefined
    */
	update = "Core.DataModificationOperationKind/update",
	/**
	Insert new instance or update it if it already exists
    */
	/**
	undefined
    */
	upsert = "Core.DataModificationOperationKind/upsert",
	/**
	Delete existing instance
    */
	/**
	undefined
    */
	delete = "Core.DataModificationOperationKind/delete",
	/**
	Invoke action or function
    */
	/**
	undefined
    */
	invoke = "Core.DataModificationOperationKind/invoke",
	/**
	Add link between entities
    */
	/**
	undefined
    */
	link = "Core.DataModificationOperationKind/link",
	/**
	Remove link between entities
    */
	/**
	undefined
    */
	unlink = "Core.DataModificationOperationKind/unlink"
}

// Term
/**
  Properties and terms annotated with this term are language-dependent
*/
export type IsLanguageDependent = AnnotationTerm<PropertyAnnotationValue<Tag>>;

// Typedefinition
/**
  This is the type to use for all tagging terms
*/
export type Tag = Edm.Boolean;

// Term
/**
  Terms annotated with this term can only be applied to elements that have a type that is identical to or derived from the given type name
*/
export type RequiresType = AnnotationTerm<PropertyAnnotationValue<Edm.String>>;

// Term
/**
  Resource path for entity container child, can be relative to xml:base and the request URL
*/
export type ResourcePath = AnnotationTerm<PropertyAnnotationValue<Edm.String>>;

// Term
/**
  Entity-ids are URLs that locate the identified entity
*/
export type DereferenceableIDs = AnnotationTerm<PropertyAnnotationValue<Tag>>;

// Term
/**
  Entity-ids follow OData URL conventions
*/
export type ConventionalIDs = AnnotationTerm<PropertyAnnotationValue<Tag>>;

// Term
/**
  Permissions for accessing a resource
*/
export type Permissions = EnumValue<Permission>;

// EnumType
export const enum Permission {
	/**
	No permissions
    */
	/**
	undefined
    */
	None = "Core.Permission/None",
	/**
	Read permission
    */
	/**
	undefined
    */
	Read = "Core.Permission/Read",
	/**
	Write permission
    */
	/**
	undefined
    */
	Write = "Core.Permission/Write",
	/**
	Read and write permission
    */
	/**
	undefined
    */
	ReadWrite = "Core.Permission/ReadWrite",
	/**
	Permission to invoke actions
    */
	/**
	undefined
    */
	Invoke = "Core.Permission/Invoke"
}

// Term
/**
  A unique identifier for nested entities within a request.
*/
export type ContentID = AnnotationTerm<PropertyAnnotationValue<Edm.String>>;

// Term
/**
  Functions, actions and types in this namespace can be referenced in URLs with or without namespace- or alias- qualification.
*/
export type DefaultNamespace = AnnotationTerm<PropertyAnnotationValue<Tag>>;

// Term
/**
  A value for this non-key property can be provided by the client on insert and remains unchanged on update
*/
export type Immutable = AnnotationTerm<PropertyAnnotationValue<Tag>>;

// Term
/**
  A value for this property is generated on both insert and update
*/
export type Computed = AnnotationTerm<PropertyAnnotationValue<Tag>>;

// Term
/**
  A value for this property can be provided by the client on insert and update. If no value is provided on insert, a non-static default value is generated
*/
export type ComputedDefaultValue = AnnotationTerm<PropertyAnnotationValue<Tag>>;

// Term
/**
  Properties and terms annotated with this term MUST contain a valid URL
*/
export type IsURL = AnnotationTerm<PropertyAnnotationValue<Tag>>;

// Term
/**
  Lists the MIME types acceptable for the annotated entity type marked with HasStream="true" or the annotated binary, stream, or string property or term
*/
export type AcceptableMediaTypes = AnnotationTerm<PropertyAnnotationValue<Edm.String[]>>;

// Term
/**
  The media type of the values of a binary or string property or term
*/
export type MediaType = AnnotationTerm<PropertyAnnotationValue<Edm.String>>;

// Term
/**
  Properties and terms annotated with this term MUST contain a valid MIME type
*/
export type IsMediaType = AnnotationTerm<PropertyAnnotationValue<Tag>>;

// Term
/**
  The content disposition of a binary or string property or term
*/
export type ContentDisposition = AnnotationTerm<ContentDispositionTypeTypes>;

// ComplexType
export type ContentDispositionType = ComplexType & {
	$Type: CoreAnnotationTypes.ContentDispositionType;
	/**
        The proposed filename for downloading the binary or stream value
    */
	Filename?: PropertyAnnotationValue<Edm.String>;
};

// Term
/**
  Data modification requires the use of ETags. A non-empty collection contains the set of properties that are used to compute the ETag. An empty collection means that the service won't tell how it computes the ETag.
*/
export type OptimisticConcurrency = AnnotationTerm<Edm.PropertyPath[]>;

// Term
/**
  Instances of this type may contain properties in addition to those declared in $metadata
*/
export type AdditionalProperties = AnnotationTerm<PropertyAnnotationValue<Tag>>;

// Term
/**
  The service will automatically expand this stream or navigation property even if not requested with $expand
*/
export type AutoExpand = AnnotationTerm<PropertyAnnotationValue<Tag>>;

// Term
/**
  The service will automatically expand this navigation property as entity references even if not requested with $expand=.../$ref
*/
export type AutoExpandReferences = AnnotationTerm<PropertyAnnotationValue<Tag>>;

// Term
/**
  A collection of qualified type names outside of the type hierarchy that instances of this type might be addressable as by using a type-cast segment.
*/
export type MayImplement = AnnotationTerm<PropertyAnnotationValue<QualifiedTypeName[]>>;

// Typedefinition
/**
  The qualified name of a term in scope.
*/
export type QualifiedTermName = Edm.String;

// Typedefinition
/**
  The qualified name of a type in scope.
*/
export type QualifiedTypeName = Edm.String;

// Term
/**
  Collection has a stable order. Ordered collections of primitive or complex types can be indexed by ordinal.
*/
export type Ordered = AnnotationTerm<PropertyAnnotationValue<Tag>>;

// Term
/**
  Items can be inserted at a given ordinal index.
*/
export type PositionalInsert = AnnotationTerm<PropertyAnnotationValue<Tag>>;

// Term
/**
  Communicates available alternate keys
*/
export type AlternateKeys = AnnotationTerm<AlternateKeyTypes[]>;

// ComplexType
export type AlternateKey = ComplexType & {
	$Type: CoreAnnotationTypes.AlternateKey;
	/**
        The set of properties that make up this key
    */
	Key: AnnotationTerm<PropertyRefTypes[]>;
};

// ComplexType
export type PropertyRef = ComplexType & {
	$Type: CoreAnnotationTypes.PropertyRef;
	/**
        A path expression resolving to a primitive property of the entity type itself or to a primitive property of a complex or navigation property (recursively) of the entity type. The names of the properties in the path are joined together by forward slashes.
    */
	Name: PropertyAnnotationValue<Edm.PropertyPath>;
	/**
        A SimpleIdentifier that MUST be unique within the set of aliases, structural and navigation properties of the containing entity type that MUST be used in the key predicate of URLs
    */
	Alias: PropertyAnnotationValue<Edm.String>;
};

// ComplexType
/**
  A dictionary of name-value pairs. Names must be valid property names, values may be restricted to a list of types via an annotation with term `Validation.OpenPropertyTypeConstraint`.
*/
export type Dictionary = ComplexType & {
	$Type: CoreAnnotationTypes.Dictionary;
};

// Term
/**
  Supplying a value for the action or function parameter is optional.
*/
export type OptionalParameter = AnnotationTerm<OptionalParameterTypeTypes>;

// ComplexType
export type OptionalParameterType = ComplexType & {
	$Type: CoreAnnotationTypes.OptionalParameterType;
	/**
        Default value for an optional parameter of primitive or enumeration type, using the same rules as the `cast` function in URLs.
    */
	DefaultValue?: PropertyAnnotationValue<Edm.String>;
};

// Term
/**
  Action or function is available
*/
export type OperationAvailable = AnnotationTerm<Edm.Boolean>;

// Typedefinition
/**
  A string representing a Local Date-Time value with no offset.
*/
export type LocalDateTime = Edm.String;

// Term
/**
  A symbolic name for a model element
*/
export type SymbolicName = AnnotationTerm<PropertyAnnotationValue<SimpleIdentifier>>;

// Typedefinition
/**
  A [simple identifier](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_SimpleIdentifier)
*/
export type SimpleIdentifier = Edm.String;
export const enum CoreAnnotationTerms {
	ODataVersions = "Org.OData.Core.V1.ODataVersions",
	SchemaVersion = "Org.OData.Core.V1.SchemaVersion",
	Revisions = "Org.OData.Core.V1.Revisions",
	Description = "Org.OData.Core.V1.Description",
	LongDescription = "Org.OData.Core.V1.LongDescription",
	Links = "Org.OData.Core.V1.Links",
	Example = "Org.OData.Core.V1.Example",
	Messages = "Org.OData.Core.V1.Messages",
	ValueException = "Org.OData.Core.V1.ValueException",
	ResourceException = "Org.OData.Core.V1.ResourceException",
	DataModificationException = "Org.OData.Core.V1.DataModificationException",
	IsLanguageDependent = "Org.OData.Core.V1.IsLanguageDependent",
	RequiresType = "Org.OData.Core.V1.RequiresType",
	ResourcePath = "Org.OData.Core.V1.ResourcePath",
	DereferenceableIDs = "Org.OData.Core.V1.DereferenceableIDs",
	ConventionalIDs = "Org.OData.Core.V1.ConventionalIDs",
	Permissions = "Org.OData.Core.V1.Permissions",
	ContentID = "Org.OData.Core.V1.ContentID",
	DefaultNamespace = "Org.OData.Core.V1.DefaultNamespace",
	Immutable = "Org.OData.Core.V1.Immutable",
	Computed = "Org.OData.Core.V1.Computed",
	ComputedDefaultValue = "Org.OData.Core.V1.ComputedDefaultValue",
	IsURL = "Org.OData.Core.V1.IsURL",
	AcceptableMediaTypes = "Org.OData.Core.V1.AcceptableMediaTypes",
	MediaType = "Org.OData.Core.V1.MediaType",
	IsMediaType = "Org.OData.Core.V1.IsMediaType",
	ContentDisposition = "Org.OData.Core.V1.ContentDisposition",
	OptimisticConcurrency = "Org.OData.Core.V1.OptimisticConcurrency",
	AdditionalProperties = "Org.OData.Core.V1.AdditionalProperties",
	AutoExpand = "Org.OData.Core.V1.AutoExpand",
	AutoExpandReferences = "Org.OData.Core.V1.AutoExpandReferences",
	MayImplement = "Org.OData.Core.V1.MayImplement",
	Ordered = "Org.OData.Core.V1.Ordered",
	PositionalInsert = "Org.OData.Core.V1.PositionalInsert",
	AlternateKeys = "Org.OData.Core.V1.AlternateKeys",
	OptionalParameter = "Org.OData.Core.V1.OptionalParameter",
	OperationAvailable = "Org.OData.Core.V1.OperationAvailable",
	SymbolicName = "Org.OData.Core.V1.SymbolicName"
}
export const enum CoreAnnotationTypes {
	RevisionType = "Org.OData.Core.V1.RevisionType",
	Link = "Org.OData.Core.V1.Link",
	ExampleValue = "Org.OData.Core.V1.ExampleValue",
	PrimitiveExampleValue = "Org.OData.Core.V1.PrimitiveExampleValue",
	ComplexExampleValue = "Org.OData.Core.V1.ComplexExampleValue",
	EntityExampleValue = "Org.OData.Core.V1.EntityExampleValue",
	ExternalExampleValue = "Org.OData.Core.V1.ExternalExampleValue",
	MessageType = "Org.OData.Core.V1.MessageType",
	ExceptionType = "Org.OData.Core.V1.ExceptionType",
	ValueExceptionType = "Org.OData.Core.V1.ValueExceptionType",
	ResourceExceptionType = "Org.OData.Core.V1.ResourceExceptionType",
	DataModificationExceptionType = "Org.OData.Core.V1.DataModificationExceptionType",
	ContentDispositionType = "Org.OData.Core.V1.ContentDispositionType",
	AlternateKey = "Org.OData.Core.V1.AlternateKey",
	PropertyRef = "Org.OData.Core.V1.PropertyRef",
	Dictionary = "Org.OData.Core.V1.Dictionary",
	OptionalParameterType = "Org.OData.Core.V1.OptionalParameterType"
}

export type RevisionTypeTypes = AnnotationTerm<RevisionType>;
export type LinkTypes = AnnotationTerm<Link>;
export type ExampleValueTypes = AnnotationTerm<
	| ExampleValue
	| PrimitiveExampleValueTypes
	| ComplexExampleValueTypes
	| EntityExampleValueTypes
	| ExternalExampleValueTypes
>;
export type PrimitiveExampleValueTypes = AnnotationTerm<PrimitiveExampleValue>;
export type ComplexExampleValueTypes = AnnotationTerm<ComplexExampleValue>;
export type EntityExampleValueTypes = AnnotationTerm<EntityExampleValue>;
export type ExternalExampleValueTypes = AnnotationTerm<ExternalExampleValue>;
export type MessageTypeTypes = AnnotationTerm<MessageType>;
export type ExceptionTypeTypes = AnnotationTerm<
	ValueExceptionTypeTypes | ResourceExceptionTypeTypes | DataModificationExceptionTypeTypes
>;
export type ValueExceptionTypeTypes = AnnotationTerm<ValueExceptionType>;
export type ResourceExceptionTypeTypes = AnnotationTerm<ResourceExceptionType>;
export type DataModificationExceptionTypeTypes = AnnotationTerm<DataModificationExceptionType>;
export type ContentDispositionTypeTypes = AnnotationTerm<ContentDispositionType>;
export type AlternateKeyTypes = AnnotationTerm<AlternateKey>;
export type PropertyRefTypes = AnnotationTerm<PropertyRef>;
export type DictionaryTypes = AnnotationTerm<Dictionary>;
export type OptionalParameterTypeTypes = AnnotationTerm<OptionalParameterType>;
