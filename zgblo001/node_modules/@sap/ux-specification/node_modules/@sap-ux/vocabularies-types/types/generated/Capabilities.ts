import * as Auth from "./Auth";
import * as Core from "./Core";
import * as Validation from "./Validation";
import * as Edm from "../Edm";
import AnnotationTerm = Edm.AnnotationTerm;
import PropertyAnnotationValue = Edm.PropertyAnnotationValue;
import EnumValue = Edm.EnumValue;
import ComplexType = Edm.ComplexType;

// Term
/**
  The conformance level achieved by this service
*/
export type ConformanceLevel = EnumValue<ConformanceLevelType>;

// EnumType
export const enum ConformanceLevelType {
	/**
	Minimal conformance level
    */
	/**
	undefined
    */
	Minimal = "Capabilities.ConformanceLevelType/Minimal",
	/**
	Intermediate conformance level
    */
	/**
	undefined
    */
	Intermediate = "Capabilities.ConformanceLevelType/Intermediate",
	/**
	Advanced conformance level
    */
	/**
	undefined
    */
	Advanced = "Capabilities.ConformanceLevelType/Advanced"
}

// Term
/**
  Media types of supported formats, including format parameters
*/
export type SupportedFormats = AnnotationTerm<PropertyAnnotationValue<Edm.String[]>>;

// Term
/**
  Media types of supported formats for $metadata, including format parameters
*/
export type SupportedMetadataFormats = AnnotationTerm<PropertyAnnotationValue<Edm.String[]>>;

// Term
/**
  List of acceptable compression methods for ($batch) requests, e.g. gzip
*/
export type AcceptableEncodings = AnnotationTerm<PropertyAnnotationValue<Edm.String[]>>;

// Term
/**
  Service supports the asynchronous request preference
*/
export type AsynchronousRequestsSupported = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Service supports the continue on error preference. Supports $batch requests. Services that apply the BatchContinueOnErrorSupported term should also specify the ContinueOnErrorSupported property from the BatchSupport term.
*/
export type BatchContinueOnErrorSupported = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Supported odata.isolation levels
*/
export type IsolationSupported = EnumValue<IsolationLevel>;

// EnumType
export const enum IsolationLevel {
	/**
	All data returned for a request, including multiple requests within a batch or results retrieved across multiple pages, will be consistent as of a single point in time
    */
	/**
	undefined
    */
	Snapshot = "Capabilities.IsolationLevel/Snapshot"
}

// Term
/**
  Supports cross joins for the entity sets in this container
*/
export type CrossJoinSupported = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Supports callbacks for the specified protocols
*/
export type CallbackSupported = AnnotationTerm<CallbackTypeTypes>;

// ComplexType
/**
  A non-empty collection lists the full set of supported protocols. A empty collection means 'only HTTP is supported'
*/
export type CallbackType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.CallbackType;
	/**
        List of supported callback protocols, e.g. `http` or `wss`
    */
	CallbackProtocols: AnnotationTerm<CallbackProtocolTypes[]>;
};

// ComplexType
export type CallbackProtocol = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.CallbackProtocol;
	/**
        Protocol Identifier
    */
	Id?: PropertyAnnotationValue<Edm.String>;
	/**
        URL Template including parameters. Parameters are enclosed in curly braces {} as defined in RFC6570
    */
	UrlTemplate?: PropertyAnnotationValue<Edm.String>;
	/**
        Human readable description of the meaning of the URL Template parameters
    */
	DocumentationUrl?: PropertyAnnotationValue<Edm.String>;
};

// Term
/**
  Change tracking capabilities of this service or entity set
*/
export type ChangeTracking = AnnotationTerm<ChangeTrackingTypeTypes>;

// ComplexType
export type ChangeTrackingType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.ChangeTrackingType;
	/**
        This entity set supports the odata.track-changes preference
    */
	Supported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Change tracking supports filters on these properties
    */
	FilterableProperties: PropertyAnnotationValue<Edm.PropertyPath[]>;
	/**
        Change tracking supports these properties expanded
    */
	ExpandableProperties: PropertyAnnotationValue<Edm.NavigationPropertyPath[]>;
};

// Term
/**
  Restrictions on /$count path suffix and $count=true system query option
*/
export type CountRestrictions = AnnotationTerm<CountRestrictionsTypeTypes>;

// ComplexType
export type CountRestrictionsType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.CountRestrictionsType;
	/**
        Entities can be counted (only valid if targeting an entity set)
    */
	Countable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Members of these collection properties cannot be counted
    */
	NonCountableProperties: PropertyAnnotationValue<Edm.PropertyPath[]>;
	/**
        Members of these navigation properties cannot be counted
    */
	NonCountableNavigationProperties: PropertyAnnotationValue<Edm.NavigationPropertyPath[]>;
};

// Term
/**
  Restrictions on navigating properties according to OData URL conventions
*/
export type NavigationRestrictions = AnnotationTerm<NavigationRestrictionsTypeTypes>;

// ComplexType
export type NavigationRestrictionsType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.NavigationRestrictionsType;
	/**
        Default navigability for all navigation properties of the annotation target. Individual navigation properties can override this value via `RestrictedProperties/Navigability`.
    */
	Navigability?: NavigationType;
	/**
        List of navigation properties with restrictions
    */
	RestrictedProperties: AnnotationTerm<NavigationPropertyRestrictionTypes[]>;
};

// ComplexType
export type NavigationPropertyRestriction = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.NavigationPropertyRestriction;
	/**
        Navigation properties can be navigated
    */
	NavigationProperty?: PropertyAnnotationValue<Edm.NavigationPropertyPath>;
	/**
        Supported navigability of this navigation property
    */
	Navigability?: NavigationType;
	/**
        List of functions and operators supported in filter expressions
    */
	FilterFunctions: PropertyAnnotationValue<Edm.String[]>;
	/**
        Restrictions on filter expressions
    */
	FilterRestrictions?: AnnotationTerm<FilterRestrictionsTypeTypes>;
	/**
        Restrictions on search expressions
    */
	SearchRestrictions?: AnnotationTerm<SearchRestrictionsTypeTypes>;
	/**
        Restrictions on orderby expressions
    */
	SortRestrictions?: AnnotationTerm<SortRestrictionsTypeTypes>;
	/**
        Supports $top
    */
	TopSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Supports $skip
    */
	SkipSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Support for $select
    */
	SelectSupport?: AnnotationTerm<SelectSupportTypeTypes>;
	/**
        Supports key values according to OData URL conventions
    */
	IndexableByKey: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Restrictions on insert operations
    */
	InsertRestrictions?: AnnotationTerm<InsertRestrictionsTypeTypes>;
	/**
        Deep Insert Support of the annotated resource (the whole service, an entity set, or a collection-valued resource)
    */
	DeepInsertSupport?: AnnotationTerm<DeepInsertSupportTypeTypes>;
	/**
        Restrictions on update operations
    */
	UpdateRestrictions?: AnnotationTerm<UpdateRestrictionsTypeTypes>;
	/**
        Deep Update Support of the annotated resource (the whole service, an entity set, or a collection-valued resource)
    */
	DeepUpdateSupport?: AnnotationTerm<DeepUpdateSupportTypeTypes>;
	/**
        Restrictions on delete operations
    */
	DeleteRestrictions?: AnnotationTerm<DeleteRestrictionsTypeTypes>;
	/**
        Data modification (including insert) along this navigation property requires the use of ETags
    */
	OptimisticConcurrencyControl: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Restrictions for retrieving entities
    */
	ReadRestrictions?: AnnotationTerm<ReadRestrictionsTypeTypes>;
};

// EnumType
export const enum NavigationType {
	/**
	Navigation properties can be recursively navigated
    */
	/**
	undefined
    */
	Recursive = "Capabilities.NavigationType/Recursive",
	/**
	Navigation properties can be navigated to a single level
    */
	/**
	undefined
    */
	Single = "Capabilities.NavigationType/Single",
	/**
	Navigation properties are not navigable
    */
	/**
	undefined
    */
	None = "Capabilities.NavigationType/None"
}

// Term
/**
  Supports key values according to OData URL conventions
*/
export type IndexableByKey = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Supports $top
*/
export type TopSupported = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Supports $skip
*/
export type SkipSupported = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Supports $compute
*/
export type ComputeSupported = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Support for $select and nested query options within $select
*/
export type SelectSupport = AnnotationTerm<SelectSupportTypeTypes>;

// ComplexType
export type SelectSupportType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.SelectSupportType;
	/**
        Supports $select
    */
	Supported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Supports instance annotations in $select list
    */
	InstanceAnnotationsSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        $expand within $select is supported
    */
	Expandable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        $filter within $select is supported
    */
	Filterable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        $search within $select is supported
    */
	Searchable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        $top within $select is supported
    */
	TopSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        $skip within $select is supported
    */
	SkipSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        $compute within $select is supported
    */
	ComputeSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        $count within $select is supported
    */
	Countable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        $orderby within $select is supported
    */
	Sortable: PropertyAnnotationValue<Edm.Boolean>;
};

// Term
/**
  Supports $batch requests. Services that apply the BatchSupported term should also apply the more comprehensive BatchSupport term.
*/
export type BatchSupported = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Batch Support for the service
*/
export type BatchSupport = AnnotationTerm<BatchSupportTypeTypes>;

// ComplexType
export type BatchSupportType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.BatchSupportType;
	/**
        Service supports requests to $batch
    */
	Supported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Service supports the continue on error preference
    */
	ContinueOnErrorSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Service supports Content-ID referencing in request bodies
    */
	ReferencesInRequestBodiesSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Service supports Content-ID referencing across change sets
    */
	ReferencesAcrossChangeSetsSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Service supports referencing Etags from previous requests
    */
	EtagReferencesSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Service supports the `if` member in JSON batch requests
    */
	RequestDependencyConditionsSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Media types of supported formats for $batch
    */
	SupportedFormats: PropertyAnnotationValue<Edm.String[]>;
};

// Term
/**
  List of functions and operators supported in filter expressions
*/
export type FilterFunctions = AnnotationTerm<PropertyAnnotationValue<Edm.String[]>>;

// Term
/**
  Restrictions on filter expressions
*/
export type FilterRestrictions = AnnotationTerm<FilterRestrictionsTypeTypes>;

// ComplexType
export type FilterRestrictionsType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.FilterRestrictionsType;
	/**
        $filter is supported
    */
	Filterable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        $filter is required
    */
	RequiresFilter: PropertyAnnotationValue<Edm.Boolean>;
	/**
        These properties must be specified in the $filter clause (properties of derived types are not allowed here)
    */
	RequiredProperties: PropertyAnnotationValue<Edm.PropertyPath[]>;
	/**
        These structural properties cannot be used in filter expressions
    */
	NonFilterableProperties: PropertyAnnotationValue<Edm.PropertyPath[]>;
	/**
        These properties only allow a subset of filter expressions. A valid filter expression for a single property can be enclosed in parentheses and combined by `and` with valid expressions for other properties.
    */
	FilterExpressionRestrictions: AnnotationTerm<FilterExpressionRestrictionTypeTypes[]>;
	/**
        The maximum number of levels (including recursion) that can be traversed in a filter expression. A value of -1 indicates there is no restriction.
    */
	MaxLevels: PropertyAnnotationValue<Edm.Int32>;
};

// ComplexType
export type FilterExpressionRestrictionType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.FilterExpressionRestrictionType;
	/**
        Path to the restricted property
    */
	Property?: PropertyAnnotationValue<Edm.PropertyPath>;
	/**
        Allowed subset of expressions
    */
	AllowedExpressions?: FilterExpressionType;
};

// Typedefinition
export type FilterExpressionType = Edm.String;

// Term
/**
  Restrictions on orderby expressions
*/
export type SortRestrictions = AnnotationTerm<SortRestrictionsTypeTypes>;

// ComplexType
export type SortRestrictionsType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.SortRestrictionsType;
	/**
        $orderby is supported
    */
	Sortable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        These properties can only be used for sorting in Ascending order
    */
	AscendingOnlyProperties: PropertyAnnotationValue<Edm.PropertyPath[]>;
	/**
        These properties can only be used for sorting in Descending order
    */
	DescendingOnlyProperties: PropertyAnnotationValue<Edm.PropertyPath[]>;
	/**
        These structural properties cannot be used in orderby expressions
    */
	NonSortableProperties: PropertyAnnotationValue<Edm.PropertyPath[]>;
};

// Term
/**
  Restrictions on expand expressions
*/
export type ExpandRestrictions = AnnotationTerm<ExpandRestrictionsTypeTypes>;

// ComplexType
export type ExpandRestrictionsType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.ExpandRestrictionsType;
	/**
        $expand is supported
    */
	Expandable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        $expand is supported for stream properties and media resources
    */
	StreamsExpandable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        These properties cannot be used in expand expressions
    */
	NonExpandableProperties: PropertyAnnotationValue<Edm.NavigationPropertyPath[]>;
	/**
        These stream properties cannot be used in expand expressions
    */
	NonExpandableStreamProperties: PropertyAnnotationValue<Edm.PropertyPath[]>;
	/**
        The maximum number of levels that can be expanded in a expand expression. A value of -1 indicates there is no restriction.
    */
	MaxLevels: PropertyAnnotationValue<Edm.Int32>;
};

// Term
/**
  Restrictions on search expressions
*/
export type SearchRestrictions = AnnotationTerm<SearchRestrictionsTypeTypes>;

// ComplexType
export type SearchRestrictionsType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.SearchRestrictionsType;
	/**
        $search is supported
    */
	Searchable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Expressions not supported in $search
    */
	UnsupportedExpressions: SearchExpressions;
};

// EnumType
export const enum SearchExpressions {
	/**
	Single search term
    */
	/**
	undefined
    */
	none = "Capabilities.SearchExpressions/none",
	/**
	Multiple search terms separated by `AND`
    */
	/**
	undefined
    */
	AND = "Capabilities.SearchExpressions/AND",
	/**
	Multiple search terms separated by `OR`
    */
	/**
	undefined
    */
	OR = "Capabilities.SearchExpressions/OR",
	/**
	Search terms preceded by `NOT`
    */
	/**
	undefined
    */
	NOT = "Capabilities.SearchExpressions/NOT",
	/**
	Search phrases enclosed in double quotes
    */
	/**
	undefined
    */
	phrase = "Capabilities.SearchExpressions/phrase",
	/**
	Precedence grouping of search expressions with parentheses
    */
	/**
	undefined
    */
	group = "Capabilities.SearchExpressions/group"
}

// Term
/**
  Supports [key-as-segment convention](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_KeyasSegmentConvention) for addressing entities within a collection
*/
export type KeyAsSegmentSupported = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Supports [passing query options in the request body](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_PassingQueryOptionsintheRequestBody)
*/
export type QuerySegmentSupported = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Restrictions on insert operations
*/
export type InsertRestrictions = AnnotationTerm<InsertRestrictionsTypeTypes>;

// ComplexType
export type InsertRestrictionsType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.InsertRestrictionsType;
	/**
        Entities can be inserted
    */
	Insertable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        These structural properties cannot be specified on insert
    */
	NonInsertableProperties: PropertyAnnotationValue<Edm.PropertyPath[]>;
	/**
        These navigation properties do not allow deep inserts
    */
	NonInsertableNavigationProperties: PropertyAnnotationValue<Edm.NavigationPropertyPath[]>;
	/**
        The maximum number of navigation properties that can be traversed when addressing the collection to insert into. A value of -1 indicates there is no restriction.
    */
	MaxLevels: PropertyAnnotationValue<Edm.Int32>;
	/**
        Entities of a specific derived type can be created by specifying a type-cast segment
    */
	TypecastSegmentSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Required permissions. One of the specified sets of scopes is required to perform the insert.
    */
	Permissions?: AnnotationTerm<PermissionTypeTypes[]>;
	/**
        Support for query options with insert requests
    */
	QueryOptions?: AnnotationTerm<ModificationQueryOptionsTypeTypes>;
	/**
        Supported or required custom headers
    */
	CustomHeaders: AnnotationTerm<CustomParameterTypes[]>;
	/**
        Supported or required custom query options
    */
	CustomQueryOptions: AnnotationTerm<CustomParameterTypes[]>;
	/**
        A brief description of the request
    */
	Description?: PropertyAnnotationValue<Edm.String>;
	/**
        A lengthy description of the request
    */
	LongDescription?: PropertyAnnotationValue<Edm.String>;
};

// ComplexType
export type PermissionType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.PermissionType;
	/**
        Authorization flow scheme name
    */
	SchemeName: Auth.SchemeName;
	/**
        List of scopes that can provide access to the resource
    */
	Scopes: AnnotationTerm<ScopeTypeTypes[]>;
};

// ComplexType
export type ScopeType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.ScopeType;
	/**
        Name of the scope.
    */
	Scope: PropertyAnnotationValue<Edm.String>;
	/**
        Comma-separated string value of all properties that will be included or excluded when using the scope.
    */
	RestrictedProperties?: PropertyAnnotationValue<Edm.String>;
};

// Term
/**
  Deep Insert Support of the annotated resource (the whole service, an entity set, or a collection-valued resource)
*/
export type DeepInsertSupport = AnnotationTerm<DeepInsertSupportTypeTypes>;

// ComplexType
export type DeepInsertSupportType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.DeepInsertSupportType;
	/**
        Annotation target supports deep inserts
    */
	Supported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Annotation target supports accepting and returning nested entities annotated with the `Core.ContentID` instance annotation.
    */
	ContentIDSupported: PropertyAnnotationValue<Edm.Boolean>;
};

// Term
/**
  Restrictions on update operations
*/
export type UpdateRestrictions = AnnotationTerm<UpdateRestrictionsTypeTypes>;

// ComplexType
export type UpdateRestrictionsType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.UpdateRestrictionsType;
	/**
        Entities can be updated
    */
	Updatable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Entities can be upserted
    */
	Upsertable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Entities can be inserted, updated, and deleted via a PATCH request with a delta payload
    */
	DeltaUpdateSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Members of collections can be updated via a PATCH request with a `/$filter(...)/$each` segment
    */
	FilterSegmentSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Members of collections can be updated via a PATCH request with a type-cast segment and a `/$each` segment
    */
	TypecastSegmentSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        These navigation properties do not allow rebinding
    */
	NonUpdatableNavigationProperties: PropertyAnnotationValue<Edm.NavigationPropertyPath[]>;
	/**
        The maximum number of navigation properties that can be traversed when addressing the collection or entity to update. A value of -1 indicates there is no restriction.
    */
	MaxLevels: PropertyAnnotationValue<Edm.Int32>;
	/**
        Required permissions. One of the specified sets of scopes is required to perform the update.
    */
	Permissions?: AnnotationTerm<PermissionTypeTypes[]>;
	/**
        Support for query options with update requests
    */
	QueryOptions?: AnnotationTerm<ModificationQueryOptionsTypeTypes>;
	/**
        Supported or required custom headers
    */
	CustomHeaders: AnnotationTerm<CustomParameterTypes[]>;
	/**
        Supported or required custom query options
    */
	CustomQueryOptions: AnnotationTerm<CustomParameterTypes[]>;
	/**
        A brief description of the request
    */
	Description?: PropertyAnnotationValue<Edm.String>;
	/**
        A lengthy description of the request
    */
	LongDescription?: PropertyAnnotationValue<Edm.String>;
};

// Term
/**
  Deep Update Support of the annotated resource (the whole service, an entity set, or a collection-valued resource)
*/
export type DeepUpdateSupport = AnnotationTerm<DeepUpdateSupportTypeTypes>;

// ComplexType
export type DeepUpdateSupportType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.DeepUpdateSupportType;
	/**
        Annotation target supports deep updates
    */
	Supported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Annotation target supports accepting and returning nested entities annotated with the `Core.ContentID` instance annotation.
    */
	ContentIDSupported: PropertyAnnotationValue<Edm.Boolean>;
};

// Term
/**
  Restrictions on delete operations
*/
export type DeleteRestrictions = AnnotationTerm<DeleteRestrictionsTypeTypes>;

// ComplexType
export type DeleteRestrictionsType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.DeleteRestrictionsType;
	/**
        Entities can be deleted
    */
	Deletable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        These navigation properties do not allow DeleteLink requests
    */
	NonDeletableNavigationProperties: PropertyAnnotationValue<Edm.NavigationPropertyPath[]>;
	/**
        The maximum number of navigation properties that can be traversed when addressing the collection to delete from or the entity to delete. A value of -1 indicates there is no restriction.
    */
	MaxLevels: PropertyAnnotationValue<Edm.Int32>;
	/**
        Members of collections can be updated via a PATCH request with a `/$filter(...)/$each` segment
    */
	FilterSegmentSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Members of collections can be updated via a PATCH request with a type-cast segment and a `/$each` segment
    */
	TypecastSegmentSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Required permissions. One of the specified sets of scopes is required to perform the delete.
    */
	Permissions?: AnnotationTerm<PermissionTypeTypes[]>;
	/**
        Supported or required custom headers
    */
	CustomHeaders: AnnotationTerm<CustomParameterTypes[]>;
	/**
        Supported or required custom query options
    */
	CustomQueryOptions: AnnotationTerm<CustomParameterTypes[]>;
	/**
        A brief description of the request
    */
	Description?: PropertyAnnotationValue<Edm.String>;
	/**
        A lengthy description of the request
    */
	LongDescription?: PropertyAnnotationValue<Edm.String>;
};

// Term
/**
  Describes restrictions on operations applied to collection-valued structural properties
*/
export type CollectionPropertyRestrictions = AnnotationTerm<CollectionPropertyRestrictionsTypeTypes[]>;

// ComplexType
export type CollectionPropertyRestrictionsType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.CollectionPropertyRestrictionsType;
	/**
        Restricted Collection-valued property
    */
	CollectionProperty?: PropertyAnnotationValue<Edm.PropertyPath>;
	/**
        List of functions and operators supported in filter expressions
    */
	FilterFunctions: PropertyAnnotationValue<Edm.String[]>;
	/**
        Restrictions on filter expressions
    */
	FilterRestrictions?: AnnotationTerm<FilterRestrictionsTypeTypes>;
	/**
        Restrictions on search expressions
    */
	SearchRestrictions?: AnnotationTerm<SearchRestrictionsTypeTypes>;
	/**
        Restrictions on orderby expressions
    */
	SortRestrictions?: AnnotationTerm<SortRestrictionsTypeTypes>;
	/**
        Supports $top
    */
	TopSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Supports $skip
    */
	SkipSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Support for $select
    */
	SelectSupport?: AnnotationTerm<SelectSupportTypeTypes>;
	/**
        Members can be inserted into this collection
    */
	Insertable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Members of this ordered collection can be updated by ordinal
    */
	Updatable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Members of this ordered collection can be deleted by ordinal
    */
	Deletable: PropertyAnnotationValue<Edm.Boolean>;
};

// Term
/**
  Restrictions for function or action operation
*/
export type OperationRestrictions = AnnotationTerm<OperationRestrictionsTypeTypes>;

// ComplexType
export type OperationRestrictionsType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.OperationRestrictionsType;
	/**
        Bound action or function can be invoked on a collection-valued binding parameter path with a `/$filter(...)` segment
    */
	FilterSegmentSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Required permissions. One of the specified sets of scopes is required to invoke an action or function
    */
	Permissions?: AnnotationTerm<PermissionTypeTypes[]>;
	/**
        Supported or required custom headers
    */
	CustomHeaders: AnnotationTerm<CustomParameterTypes[]>;
	/**
        Supported or required custom query options
    */
	CustomQueryOptions: AnnotationTerm<CustomParameterTypes[]>;
};

// Term
/**
  Supports annotation values within system query options
*/
export type AnnotationValuesInQuerySupported = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Support for query options with modification requests (insert, update, action invocation)
*/
export type ModificationQueryOptions = AnnotationTerm<ModificationQueryOptionsTypeTypes>;

// ComplexType
export type ModificationQueryOptionsType = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.ModificationQueryOptionsType;
	/**
        Supports $expand with modification requests
    */
	ExpandSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Supports $select with modification requests
    */
	SelectSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Supports $compute with modification requests
    */
	ComputeSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Supports $filter with modification requests
    */
	FilterSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Supports $search with modification requests
    */
	SearchSupported: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Supports $orderby with modification requests
    */
	SortSupported: PropertyAnnotationValue<Edm.Boolean>;
};

// Term
/**
  Restrictions for retrieving a collection of entities, retrieving a singleton instance.
*/
export type ReadRestrictions = AnnotationTerm<ReadRestrictionsTypeTypes>;

// ComplexType
export type ReadRestrictionsBase = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.ReadRestrictionsBase;
	/**
        Entities can be retrieved
    */
	Readable: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Required permissions. One of the specified sets of scopes is required to read.
    */
	Permissions?: AnnotationTerm<PermissionTypeTypes[]>;
	/**
        Supported or required custom headers
    */
	CustomHeaders: AnnotationTerm<CustomParameterTypes[]>;
	/**
        Supported or required custom query options
    */
	CustomQueryOptions: AnnotationTerm<CustomParameterTypes[]>;
	/**
        A brief description of the request
    */
	Description?: PropertyAnnotationValue<Edm.String>;
	/**
        A lengthy description of the request
    */
	LongDescription?: PropertyAnnotationValue<Edm.String>;
};

// ComplexType
/**
  Restrictions for retrieving an entity by key
*/
export type ReadByKeyRestrictionsType = ComplexType &
	Omit<ReadRestrictionsBase, "$Type"> & {
		$Type: CapabilitiesAnnotationTypes.ReadByKeyRestrictionsType;
	};

// ComplexType
export type ReadRestrictionsType = ComplexType &
	Omit<ReadRestrictionsBase, "$Type"> & {
		$Type: CapabilitiesAnnotationTypes.ReadRestrictionsType;
		/**
        Restrictions for retrieving an entity by key
    */
		ReadByKeyRestrictions?: AnnotationTerm<ReadByKeyRestrictionsTypeTypes>;
	};

// Term
/**
  Custom headers that are supported/required for the annotated resource
*/
export type CustomHeaders = AnnotationTerm<CustomParameterTypes[]>;

// Term
/**
  Custom query options that are supported/required for the annotated resource
*/
export type CustomQueryOptions = AnnotationTerm<CustomParameterTypes[]>;

// ComplexType
/**
  A custom parameter is either a header or a query option
*/
export type CustomParameter = ComplexType & {
	$Type: CapabilitiesAnnotationTypes.CustomParameter;
	/**
        Name of the custom parameter
    */
	Name: PropertyAnnotationValue<Edm.String>;
	/**
        Description of the custom parameter
    */
	Description?: PropertyAnnotationValue<Edm.String>;
	/**
        URL of related documentation
    */
	DocumentationURL?: PropertyAnnotationValue<Edm.String>;
	/**
        true: parameter is required, false or not specified: parameter is optional
    */
	Required: PropertyAnnotationValue<Edm.Boolean>;
	/**
        Example values for the custom parameter
    */
	ExampleValues: Core.PrimitiveExampleValue[];
};

// Term
/**
  Stream property supports update of its media edit URL and/or media read URL
*/
export type MediaLocationUpdateSupported = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
export const enum CapabilitiesAnnotationTerms {
	ConformanceLevel = "Org.OData.Capabilities.V1.ConformanceLevel",
	SupportedFormats = "Org.OData.Capabilities.V1.SupportedFormats",
	SupportedMetadataFormats = "Org.OData.Capabilities.V1.SupportedMetadataFormats",
	AcceptableEncodings = "Org.OData.Capabilities.V1.AcceptableEncodings",
	AsynchronousRequestsSupported = "Org.OData.Capabilities.V1.AsynchronousRequestsSupported",
	BatchContinueOnErrorSupported = "Org.OData.Capabilities.V1.BatchContinueOnErrorSupported",
	IsolationSupported = "Org.OData.Capabilities.V1.IsolationSupported",
	CrossJoinSupported = "Org.OData.Capabilities.V1.CrossJoinSupported",
	CallbackSupported = "Org.OData.Capabilities.V1.CallbackSupported",
	ChangeTracking = "Org.OData.Capabilities.V1.ChangeTracking",
	CountRestrictions = "Org.OData.Capabilities.V1.CountRestrictions",
	NavigationRestrictions = "Org.OData.Capabilities.V1.NavigationRestrictions",
	IndexableByKey = "Org.OData.Capabilities.V1.IndexableByKey",
	TopSupported = "Org.OData.Capabilities.V1.TopSupported",
	SkipSupported = "Org.OData.Capabilities.V1.SkipSupported",
	ComputeSupported = "Org.OData.Capabilities.V1.ComputeSupported",
	SelectSupport = "Org.OData.Capabilities.V1.SelectSupport",
	BatchSupported = "Org.OData.Capabilities.V1.BatchSupported",
	BatchSupport = "Org.OData.Capabilities.V1.BatchSupport",
	FilterFunctions = "Org.OData.Capabilities.V1.FilterFunctions",
	FilterRestrictions = "Org.OData.Capabilities.V1.FilterRestrictions",
	SortRestrictions = "Org.OData.Capabilities.V1.SortRestrictions",
	ExpandRestrictions = "Org.OData.Capabilities.V1.ExpandRestrictions",
	SearchRestrictions = "Org.OData.Capabilities.V1.SearchRestrictions",
	KeyAsSegmentSupported = "Org.OData.Capabilities.V1.KeyAsSegmentSupported",
	QuerySegmentSupported = "Org.OData.Capabilities.V1.QuerySegmentSupported",
	InsertRestrictions = "Org.OData.Capabilities.V1.InsertRestrictions",
	DeepInsertSupport = "Org.OData.Capabilities.V1.DeepInsertSupport",
	UpdateRestrictions = "Org.OData.Capabilities.V1.UpdateRestrictions",
	DeepUpdateSupport = "Org.OData.Capabilities.V1.DeepUpdateSupport",
	DeleteRestrictions = "Org.OData.Capabilities.V1.DeleteRestrictions",
	CollectionPropertyRestrictions = "Org.OData.Capabilities.V1.CollectionPropertyRestrictions",
	OperationRestrictions = "Org.OData.Capabilities.V1.OperationRestrictions",
	AnnotationValuesInQuerySupported = "Org.OData.Capabilities.V1.AnnotationValuesInQuerySupported",
	ModificationQueryOptions = "Org.OData.Capabilities.V1.ModificationQueryOptions",
	ReadRestrictions = "Org.OData.Capabilities.V1.ReadRestrictions",
	CustomHeaders = "Org.OData.Capabilities.V1.CustomHeaders",
	CustomQueryOptions = "Org.OData.Capabilities.V1.CustomQueryOptions",
	MediaLocationUpdateSupported = "Org.OData.Capabilities.V1.MediaLocationUpdateSupported"
}
export const enum CapabilitiesAnnotationTypes {
	CallbackType = "Org.OData.Capabilities.V1.CallbackType",
	CallbackProtocol = "Org.OData.Capabilities.V1.CallbackProtocol",
	ChangeTrackingType = "Org.OData.Capabilities.V1.ChangeTrackingType",
	CountRestrictionsType = "Org.OData.Capabilities.V1.CountRestrictionsType",
	NavigationRestrictionsType = "Org.OData.Capabilities.V1.NavigationRestrictionsType",
	NavigationPropertyRestriction = "Org.OData.Capabilities.V1.NavigationPropertyRestriction",
	SelectSupportType = "Org.OData.Capabilities.V1.SelectSupportType",
	BatchSupportType = "Org.OData.Capabilities.V1.BatchSupportType",
	FilterRestrictionsType = "Org.OData.Capabilities.V1.FilterRestrictionsType",
	FilterExpressionRestrictionType = "Org.OData.Capabilities.V1.FilterExpressionRestrictionType",
	SortRestrictionsType = "Org.OData.Capabilities.V1.SortRestrictionsType",
	ExpandRestrictionsType = "Org.OData.Capabilities.V1.ExpandRestrictionsType",
	SearchRestrictionsType = "Org.OData.Capabilities.V1.SearchRestrictionsType",
	InsertRestrictionsType = "Org.OData.Capabilities.V1.InsertRestrictionsType",
	PermissionType = "Org.OData.Capabilities.V1.PermissionType",
	ScopeType = "Org.OData.Capabilities.V1.ScopeType",
	DeepInsertSupportType = "Org.OData.Capabilities.V1.DeepInsertSupportType",
	UpdateRestrictionsType = "Org.OData.Capabilities.V1.UpdateRestrictionsType",
	DeepUpdateSupportType = "Org.OData.Capabilities.V1.DeepUpdateSupportType",
	DeleteRestrictionsType = "Org.OData.Capabilities.V1.DeleteRestrictionsType",
	CollectionPropertyRestrictionsType = "Org.OData.Capabilities.V1.CollectionPropertyRestrictionsType",
	OperationRestrictionsType = "Org.OData.Capabilities.V1.OperationRestrictionsType",
	ModificationQueryOptionsType = "Org.OData.Capabilities.V1.ModificationQueryOptionsType",
	ReadRestrictionsBase = "Org.OData.Capabilities.V1.ReadRestrictionsBase",
	ReadByKeyRestrictionsType = "Org.OData.Capabilities.V1.ReadByKeyRestrictionsType",
	ReadRestrictionsType = "Org.OData.Capabilities.V1.ReadRestrictionsType",
	CustomParameter = "Org.OData.Capabilities.V1.CustomParameter"
}

export type CallbackTypeTypes = AnnotationTerm<CallbackType>;
export type CallbackProtocolTypes = AnnotationTerm<CallbackProtocol>;
export type ChangeTrackingTypeTypes = AnnotationTerm<ChangeTrackingType>;
export type CountRestrictionsTypeTypes = AnnotationTerm<CountRestrictionsType>;
export type NavigationRestrictionsTypeTypes = AnnotationTerm<NavigationRestrictionsType>;
export type NavigationPropertyRestrictionTypes = AnnotationTerm<NavigationPropertyRestriction>;
export type SelectSupportTypeTypes = AnnotationTerm<SelectSupportType>;
export type BatchSupportTypeTypes = AnnotationTerm<BatchSupportType>;
export type FilterRestrictionsTypeTypes = AnnotationTerm<FilterRestrictionsType>;
export type FilterExpressionRestrictionTypeTypes = AnnotationTerm<FilterExpressionRestrictionType>;
export type SortRestrictionsTypeTypes = AnnotationTerm<SortRestrictionsType>;
export type ExpandRestrictionsTypeTypes = AnnotationTerm<ExpandRestrictionsType>;
export type SearchRestrictionsTypeTypes = AnnotationTerm<SearchRestrictionsType>;
export type InsertRestrictionsTypeTypes = AnnotationTerm<InsertRestrictionsType>;
export type PermissionTypeTypes = AnnotationTerm<PermissionType>;
export type ScopeTypeTypes = AnnotationTerm<ScopeType>;
export type DeepInsertSupportTypeTypes = AnnotationTerm<DeepInsertSupportType>;
export type UpdateRestrictionsTypeTypes = AnnotationTerm<UpdateRestrictionsType>;
export type DeepUpdateSupportTypeTypes = AnnotationTerm<DeepUpdateSupportType>;
export type DeleteRestrictionsTypeTypes = AnnotationTerm<DeleteRestrictionsType>;
export type CollectionPropertyRestrictionsTypeTypes = AnnotationTerm<CollectionPropertyRestrictionsType>;
export type OperationRestrictionsTypeTypes = AnnotationTerm<OperationRestrictionsType>;
export type ModificationQueryOptionsTypeTypes = AnnotationTerm<ModificationQueryOptionsType>;
export type ReadRestrictionsBaseTypes = AnnotationTerm<ReadByKeyRestrictionsTypeTypes | ReadRestrictionsTypeTypes>;
export type ReadByKeyRestrictionsTypeTypes = AnnotationTerm<ReadByKeyRestrictionsType>;
export type ReadRestrictionsTypeTypes = AnnotationTerm<ReadRestrictionsType>;
export type CustomParameterTypes = AnnotationTerm<CustomParameter>;
