import * as Core from "./Core";
import * as Edm from "../Edm";
import AnnotationTerm = Edm.AnnotationTerm;
import PropertyAnnotationValue = Edm.PropertyAnnotationValue;
import EnumValue = Edm.EnumValue;
import ComplexType = Edm.ComplexType;

// Term
/**
  The pattern that a string property, parameter, or term must match. This SHOULD be a valid regular expression, according to the ECMA 262 regular expression dialect.
*/
export type Pattern = AnnotationTerm<PropertyAnnotationValue<Edm.String>>;

// Term
/**
  Minimum value that a property, parameter, or term can have.
*/
export type Minimum = AnnotationTerm<Edm.PrimitiveType>;

// Term
/**
  Maximum value that a property, parameter, or term can have.
*/
export type Maximum = AnnotationTerm<Edm.PrimitiveType>;

// Term
/**
  Tags a Minimum or Maximum as exclusive, i.e. an open interval boundary.
*/
export type Exclusive = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  A collection of valid values for the annotated property, parameter, or type definition
*/
export type AllowedValues = AnnotationTerm<AllowedValueTypes[]>;

// ComplexType
export type AllowedValue = ComplexType & {
	$Type: ValidationAnnotationTypes.AllowedValue;
	/**
        An allowed value for the property, parameter, or type definition
    */
	Value?: PropertyAnnotationValue<Edm.PrimitiveType>;
};

// Term
/**
  The value of the annotated property, parameter, or term must be an integer multiple of this positive value. For temporal types, the value is measured in seconds.
*/
export type MultipleOf = AnnotationTerm<Edm.Decimal>;

// Term
/**
  Condition that the annotation target has to fulfill
*/
export type Constraint = AnnotationTerm<ConstraintTypeTypes>;

// ComplexType
export type ConstraintType = ComplexType & {
	$Type: ValidationAnnotationTypes.ConstraintType;
	/**
        Human-readable message that can be shown to end users if the constraint is not fulfilled
    */
	FailureMessage?: PropertyAnnotationValue<Edm.String>;
	/**
        Value MUST be a dynamic expression that evaluates to true if and only if the constraint is fulfilled
    */
	Condition: PropertyAnnotationValue<Edm.Boolean>;
};

// Term
/**
  A list of constraints describing that entities related via one navigation property MUST also be related via another, collection-valued navigation property. The same `path` value MUST NOT occur more than once.
*/
export type ItemsOf = AnnotationTerm<ItemsOfTypeTypes[]>;

// ComplexType
/**
  Entities related via the single- or collection-valued navigation property identified by `path` are also related via the collection-valued navigation property identified by `target`.
*/
export type ItemsOfType = ComplexType & {
	$Type: ValidationAnnotationTypes.ItemsOfType;
	/**
        A path to a single- or collection-valued navigation property
    */
	path: PropertyAnnotationValue<Edm.NavigationPropertyPath>;
	/**
        A path to a collection-valued navigation property
    */
	target: PropertyAnnotationValue<Edm.NavigationPropertyPath>;
};

// Term
/**
  Dynamic properties added to the annotated open structured type are restricted to the listed types.
*/
export type OpenPropertyTypeConstraint = AnnotationTerm<Core.QualifiedTypeName[]>;

// Term
/**
  Values are restricted to types that are both identical to or derived from the declared type and a type listed in this collection.
*/
export type DerivedTypeConstraint = AnnotationTerm<Core.QualifiedTypeName[]>;

// Term
/**
  Annotate a term of type Edm.AnnotationPath, or a property of type Edm.AnnotationPath that is used within a structured term, to restrict the terms that can be targeted by the path.
*/
export type AllowedTerms = AnnotationTerm<Core.QualifiedTermName[]>;

// Term
/**
  Names of specific terms that are applicable and may be applied in the current context. This annotation does not restrict the use of other terms.
*/
export type ApplicableTerms = AnnotationTerm<Core.QualifiedTermName[]>;

// Term
/**
  The annotated collection must have at most the specified number of items.
*/
export type MaxItems = AnnotationTerm<Edm.Int64>;

// Term
/**
  The annotated collection must have at least the specified number of items.
*/
export type MinItems = AnnotationTerm<Edm.Int64>;
export const enum ValidationAnnotationTerms {
	Pattern = "Org.OData.Validation.V1.Pattern",
	Minimum = "Org.OData.Validation.V1.Minimum",
	Maximum = "Org.OData.Validation.V1.Maximum",
	Exclusive = "Org.OData.Validation.V1.Exclusive",
	AllowedValues = "Org.OData.Validation.V1.AllowedValues",
	MultipleOf = "Org.OData.Validation.V1.MultipleOf",
	Constraint = "Org.OData.Validation.V1.Constraint",
	ItemsOf = "Org.OData.Validation.V1.ItemsOf",
	OpenPropertyTypeConstraint = "Org.OData.Validation.V1.OpenPropertyTypeConstraint",
	DerivedTypeConstraint = "Org.OData.Validation.V1.DerivedTypeConstraint",
	AllowedTerms = "Org.OData.Validation.V1.AllowedTerms",
	ApplicableTerms = "Org.OData.Validation.V1.ApplicableTerms",
	MaxItems = "Org.OData.Validation.V1.MaxItems",
	MinItems = "Org.OData.Validation.V1.MinItems"
}
export const enum ValidationAnnotationTypes {
	AllowedValue = "Org.OData.Validation.V1.AllowedValue",
	ConstraintType = "Org.OData.Validation.V1.ConstraintType",
	ItemsOfType = "Org.OData.Validation.V1.ItemsOfType"
}

export type AllowedValueTypes = AnnotationTerm<AllowedValue>;
export type ConstraintTypeTypes = AnnotationTerm<ConstraintType>;
export type ItemsOfTypeTypes = AnnotationTerm<ItemsOfType>;
