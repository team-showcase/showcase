import {
	Property as ParserProperty,
	EntityType as ParserEntityType,
	EntitySet as ParserEntitySet,
	Action as ParserAction,
	ComplexType as ParserComplexType,
	Reference,
	ReferentialConstraint
} from "./Parser";

import { Annotation as EdmAnnotation, AnnotationList, FullyQualifiedName, SimpleIdentifier } from "./BaseEdm";
import {
	ActionAnnotations,
	ActionImportAnnotations,
	AnnotationAnnotations,
	ComplexTypeAnnotations,
	EntityContainerAnnotations,
	EntitySetAnnotations,
	EntityTypeAnnotations,
	EnumTypeAnnotations,
	FunctionAnnotations,
	FunctionImportAnnotations,
	IncludeAnnotations,
	NavigationPropertyAnnotations,
	ParameterAnnotations,
	PropertyAnnotations,
	ReferenceAnnotations,
	ReturnTypeAnnotations,
	SchemaAnnotations,
	SingletonAnnotations,
	TermAnnotations,
	TypeDefinitionAnnotations,
	PropertyValueAnnotations,
	RecordAnnotations
} from "./generated/Edm_Types";

export type AnyAnnotation =
	| EnumTypeAnnotations
	| PropertyValueAnnotations
	| IncludeAnnotations
	| ReferenceAnnotations
	| ActionAnnotations
	| FunctionImportAnnotations
	| ActionImportAnnotations
	| TypeDefinitionAnnotations
	| SingletonAnnotations
	| EntityContainerAnnotations
	| FunctionAnnotations
	| ReturnTypeAnnotations
	| ParameterAnnotations
	| ComplexTypeAnnotations
	| TermAnnotations
	| RecordAnnotations
	| SchemaAnnotations
	| AnnotationAnnotations
	| EntitySetAnnotations
	| EntityTypeAnnotations
	| PropertyAnnotations
	| NavigationPropertyAnnotations;

export type Property = ParserProperty & {
	annotations: PropertyAnnotations;
	targetType?: ComplexType;
	isKey: boolean;
};

export type ComplexType = Omit<ParserComplexType, "properties" | "navigationProperties"> & {
	properties: Property[];
	navigationProperties: NavigationProperty[];
	annotations: ComplexTypeAnnotations;
};

export type NavigationProperty = {
	_type: "NavigationProperty";
	name: SimpleIdentifier;
	partner: string;
	fullyQualifiedName: FullyQualifiedName;
	targetTypeName: FullyQualifiedName;
	targetType: EntityType;
	annotations: NavigationPropertyAnnotations;
	isCollection: boolean;
	containsTarget: boolean;
	referentialConstraint?: ReferentialConstraint[];
};

export type EntityType = Omit<ParserEntityType, "entityProperties" | "navigationProperties" | "keys"> & {
	_type: "EntityType";
	entityProperties: Property[];
	keys: Property[];
	navigationProperties: NavigationProperty[];
	actions: Record<string, Action>;
	annotations: EntityTypeAnnotations;
	resolvePath(relativePath: string, includeVisitedObjects?: boolean): any;
};

export type EntitySet = Omit<ParserEntitySet, "entityType"> & {
	_type: "EntitySet";
	entityType: EntityType;
	navigationPropertyBinding: Record<string, EntitySet>;
	annotations: EntitySetAnnotations;
};

export type Action = ParserAction & {
	_type: "Action";
	sourceEntityType?: EntityType;
	returnEntityType?: EntityType;
	annotations: ActionAnnotations;
	parameters: {
		_type: "ActionParameter";
		isEntitySet: boolean;
		fullyQualifiedName: string;
		type: string;
		annotations: ParameterAnnotations;
	}[];
};

export type Annotation = EdmAnnotation & {
	fullyQualifiedName: string;
};

export type ConverterOutput = {
	version: string;
	annotations: Record<string, AnnotationList[]>;
	namespace: string;
	actions: Action[];
	complexTypes: ComplexType[];
	entitySets: EntitySet[];
	entityTypes: EntityType[];
	references: Reference[];
	diagnostics: { message: string }[];
};

export function Decimal(value: number) {
	return {
		isDecimal() {
			return true;
		},
		valueOf() {
			return value;
		},
		toString() {
			return value.toString();
		}
	};
}
