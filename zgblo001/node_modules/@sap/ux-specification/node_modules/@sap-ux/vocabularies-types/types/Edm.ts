// PURE EDM Types
import { EntityType as _EntityType, Action as _Action, Property, NavigationProperty } from "./Converter";
import { RecordAnnotations, TermAnnotations, AnnotationAnnotations } from "./generated/Edm_Types";

// Generated EDM Types for the converter

export type PropertyPath = {
	fullyQualifiedName: string;
	type: "PropertyPath";
	value: string;
	$target: Property;
};
export type NavigationPropertyPath = {
	type: "NavigationPropertyPath";
	value: string;
	$target: NavigationProperty;
};

export type AnnotationPath<P> = {
	type: "AnnotationPath";
	value: string;
	$target: AnnotationTerm<P>;
};

type PrimitiveTypeCast<P, G> =
	| (P extends boolean ? boolean | (BooleanConstructor & G) : never)
	| (P extends number ? number | (NumberConstructor & G) : never)
	| (P extends string ? string | (StringConstructor & G) : never)
	| (P & G);

export type AnnotationTerm<P> = PrimitiveTypeCast<
	P,
	{
		fullyQualifiedName: string;
		term: string;
		qualifier: string;
		annotations?: TermAnnotations & AnnotationAnnotations;
	}
>;

export type PathAnnotationExpression<P> = {
	type: "Path";
	path: string; // The defined path
	$target: P;
	getValue(): P;
};

export type ApplyAnnotationExpression<P> = {
	type: "Apply";
	value: any;
	getValue(): P;
};

export type EqConditionalExpression = {
	$Eq: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};

export type NeConditionalExpression = {
	$Ne: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};

export type GtConditionalExpression = {
	$Gt: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};

export type GeConditionalExpression = {
	$Ge: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};

export type LtConditionalExpression = {
	$Lt: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};

export type LeConditionalExpression = {
	$Le: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};

export type AndConditionalExpression = {
	$And: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};

export type OrConditionalExpression = {
	$Or: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};

export type NotConditionalExpression = {
	$Not: [ConditionalCheckOrValue];
};

export type PathConditionExpression<T> = {
	$Path: string;
};
export type ConditionalCheck =
	| OrConditionalExpression
	| AndConditionalExpression
	| NotConditionalExpression
	| EqConditionalExpression
	| NeConditionalExpression
	| GtConditionalExpression
	| GeConditionalExpression
	| LtConditionalExpression
	| LeConditionalExpression;
export type ConditionalCheckOrValue =
	| null
	| string
	| number
	| boolean
	| ConditionalCheck
	| PathConditionExpression<string | number | boolean>;
export type IfAnnotationExpressionValue<OutType> = [ConditionalCheck, OutType, OutType];
export type IfAnnotationExpression<P> = {
	type: "If";
	If: IfAnnotationExpressionValue<P>;
	getValue(): P;
};

export type PropertyAnnotationValue<P> =
	| P
	| PathAnnotationExpression<P>
	| ApplyAnnotationExpression<P>
	| IfAnnotationExpression<P>;

export type String = string;
export type InstancePath = string;
export type Boolean = boolean;
export type Byte = number;
export type Int16 = number;
export type Int32 = number;
export type Int64 = number;
export type Time = string;
export type Binary = string;
export type Decimal = number;
export type Double = number;

export type Date = string;
export type Guid = any;
export type Duration = any;
export type DateTimeOffset = any;

export type GeographyPoint = any;

export type PrimitiveType =
	| Binary
	| Boolean
	| Byte
	| Date
	| DateTimeOffset
	| Decimal
	| Double
	| Duration
	| Guid
	| Int16
	| Int32
	| Int64
	// | Edm.SByte
	// | Edm.Single
	// | Edm.Stream
	| String
	// | Edm.TimeOfData
	// | Edm.Geography
	| GeographyPoint;
// | Edm.GeographyLineString
// | Edm.GeographyPolygon
// | Edm.GeographyMultiPoint
// | Edm.GeographyMultiLineString
// | Edm.GeographyMultiPolygon
// | Edm.GeographyCollection
// | Edm.Geometry
// | Edm.GeometryPoint
// | Edm.GeometryLineString
// | Edm.GeometryPolygon
// | Edm.GeometryMultiPoint
// | Edm.GeometryMultiLineString
// | Edm.GeometryMultiPolygon
// | Edm.GeometryCollection;

export type EnumValue<P> = P | PathAnnotationExpression<P> | ApplyAnnotationExpression<P> | IfAnnotationExpression<P>;

export type ComplexType = {
	annotations?: RecordAnnotations;
};

export type EntityType = _EntityType;
export type Action = _Action;
