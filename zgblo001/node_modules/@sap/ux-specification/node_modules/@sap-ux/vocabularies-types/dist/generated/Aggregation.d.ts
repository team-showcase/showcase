import * as Core from "./Core";
import * as Edm from "../Edm";
import AnnotationTerm = Edm.AnnotationTerm;
import PropertyAnnotationValue = Edm.PropertyAnnotationValue;
import ComplexType = Edm.ComplexType;
/**
  This structured type or entity container supports the $apply system query option
*/
export declare type ApplySupported = AnnotationTerm<ApplySupportedTypeTypes>;
export declare type ApplySupportedType = ComplexType & {
    $Type: AggregationAnnotationTypes.ApplySupportedType;
    /**
        Transformations that can be used in $apply
    */
    Transformations: PropertyAnnotationValue<Edm.String[]>;
    /**
        Qualified names of custom aggregation methods that can be used in aggregate(...with...)
    */
    CustomAggregationMethods: PropertyAnnotationValue<Edm.String[]>;
    /**
        The service supports rollup hierarchies in a groupby transformation
    */
    Rollup: RollupType;
    /**
        Only properties tagged as Groupable can be used in the groupby transformation, and only those tagged as Aggregatable can be used in the aggregate transformation
    */
    PropertyRestrictions: PropertyAnnotationValue<Edm.Boolean>;
};
/**
  The number of rollup operators allowed in a groupby transformation
*/
export declare const enum RollupType {
    /**
    No rollup support
    */
    /**
    undefined
    */
    None = "Aggregation.RollupType/None",
    /**
    Only one rollup operator per groupby
    */
    /**
    undefined
    */
    SingleHierarchy = "Aggregation.RollupType/SingleHierarchy",
    /**
    Full rollup support
    */
    /**
    undefined
    */
    MultipleHierarchies = "Aggregation.RollupType/MultipleHierarchies"
}
/**
  This property can be used in the groupby transformation
*/
export declare type Groupable = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  This property can be used in the aggregate transformation
*/
export declare type Aggregatable = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  Dynamic property that can be used in the aggregate transformation
*/
export declare type CustomAggregate = AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  The annotated property or custom aggregate is only well-defined in the context of these properties
*/
export declare type ContextDefiningProperties = AnnotationTerm<Edm.PropertyPath[]>;
/**
  Defines a leveled hierarchy by defining an ordered list of properties in the hierarchy
*/
export declare type LeveledHierarchy = AnnotationTerm<Edm.PropertyPath[]>;
/**
  Defines a recursive hierarchy.
*/
export declare type RecursiveHierarchy = AnnotationTerm<RecursiveHierarchyTypeTypes>;
export declare type RecursiveHierarchyType = ComplexType & {
    $Type: AggregationAnnotationTypes.RecursiveHierarchyType;
    /**
        Property holding the hierarchy node value
    */
    NodeProperty: PropertyAnnotationValue<Edm.PropertyPath>;
    /**
        Property for navigating to the parent node
    */
    ParentNavigationProperty: PropertyAnnotationValue<Edm.NavigationPropertyPath>;
    /**
        Property holding the number of edges between the node and the root node
    */
    DistanceFromRootProperty?: PropertyAnnotationValue<Edm.PropertyPath>;
    /**
        Property indicating whether the node is a leaf of the hierarchy
    */
    IsLeafProperty?: PropertyAnnotationValue<Edm.PropertyPath>;
};
/**
  Returns true, if and only if the value of the node property of the specified hierarchy is the root of the hierarchy
*/
export declare type isroot = (Entity: Edm.EntityType, Hierarchy: any) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy is a descendant of the given parent node with a distance of less than or equal to the optionally specified maximum distance
*/
export declare type isdescendant = (Entity: Edm.EntityType, Hierarchy: any, Node: Edm.PrimitiveType, MaxDistance: Edm.Int16) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy is an ancestor of the given child node with a distance of less than or equal to the optionally specified maximum distance
*/
export declare type isancestor = (Entity: Edm.EntityType, Hierarchy: any, Node: Edm.PrimitiveType, MaxDistance: Edm.Int16) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy has the same parent node as the specified node
*/
export declare type issibling = (Entity: Edm.EntityType, Hierarchy: any, Node: Edm.PrimitiveType) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy has no descendants
*/
export declare type isleaf = (Entity: Edm.EntityType, Hierarchy: any) => Edm.Boolean;
/**
  This action or function is available on aggregated entities if the RequiredProperties are still defined
*/
export declare type AvailableOnAggregates = AnnotationTerm<AvailableOnAggregatesTypeTypes>;
export declare type AvailableOnAggregatesType = ComplexType & {
    $Type: AggregationAnnotationTypes.AvailableOnAggregatesType;
    /**
        Properties required to apply this action or function
    */
    RequiredProperties: PropertyAnnotationValue<Edm.PropertyPath[]>;
};
export declare const enum AggregationAnnotationTerms {
    ApplySupported = "Org.OData.Aggregation.V1.ApplySupported",
    Groupable = "Org.OData.Aggregation.V1.Groupable",
    Aggregatable = "Org.OData.Aggregation.V1.Aggregatable",
    CustomAggregate = "Org.OData.Aggregation.V1.CustomAggregate",
    ContextDefiningProperties = "Org.OData.Aggregation.V1.ContextDefiningProperties",
    LeveledHierarchy = "Org.OData.Aggregation.V1.LeveledHierarchy",
    RecursiveHierarchy = "Org.OData.Aggregation.V1.RecursiveHierarchy",
    AvailableOnAggregates = "Org.OData.Aggregation.V1.AvailableOnAggregates"
}
export declare const enum AggregationAnnotationTypes {
    ApplySupportedType = "Org.OData.Aggregation.V1.ApplySupportedType",
    RecursiveHierarchyType = "Org.OData.Aggregation.V1.RecursiveHierarchyType",
    AvailableOnAggregatesType = "Org.OData.Aggregation.V1.AvailableOnAggregatesType"
}
export declare type ApplySupportedTypeTypes = AnnotationTerm<ApplySupportedType>;
export declare type RecursiveHierarchyTypeTypes = AnnotationTerm<RecursiveHierarchyType>;
export declare type AvailableOnAggregatesTypeTypes = AnnotationTerm<AvailableOnAggregatesType>;
