import * as Core from "./Core";
import * as Communication from "./Communication";
import * as Common from "./Common";
import * as Edm from "../Edm";
import AnnotationTerm = Edm.AnnotationTerm;
import PropertyAnnotationValue = Edm.PropertyAnnotationValue;
import EnumValue = Edm.EnumValue;
import ComplexType = Edm.ComplexType;
/**
  Information for the header area of an entity representation. HeaderInfo is mandatory for main entity types of the model
*/
export declare type HeaderInfo = AnnotationTerm<HeaderInfoTypeTypes>;
export declare type HeaderInfoType = ComplexType & {
    $Type: UIAnnotationTypes.HeaderInfoType;
    /**
        Name of the main entity type
    */
    TypeName: PropertyAnnotationValue<Edm.String>;
    /**
        Plural form of the name of the main entity type
    */
    TypeNamePlural: PropertyAnnotationValue<Edm.String>;
    /**
        Title, e.g. for overview pages
    */
    Title?: AnnotationTerm<DataFieldAbstractTypes>;
    /**
        Description, e.g. for overview pages
    */
    Description?: AnnotationTerm<DataFieldAbstractTypes>;
    /**
        Image URL for an instance of the entity type. If the property ImageUrl has a valid value, it can be used for the visualization of the instance. If it is not available or not valid the property TypeImageUrl can be used instead.
    */
    ImageUrl?: PropertyAnnotationValue<Edm.String>;
    /**
        Image URL for the entity type
    */
    TypeImageUrl?: PropertyAnnotationValue<Edm.String>;
    /**
        Latin letters to be used in case no ImageUrl or TypeImageUrl is present
    */
    Initials?: PropertyAnnotationValue<Edm.String>;
};
/**
  Collection of fields identifying the object
*/
export declare type Identification = AnnotationTerm<DataFieldAbstractTypes[]>;
/**
  Information usually displayed in the form of a business card
*/
export declare type Badge = AnnotationTerm<BadgeTypeTypes>;
export declare type BadgeType = ComplexType & {
    $Type: UIAnnotationTypes.BadgeType;
    /**
        Headline
    */
    HeadLine: AnnotationTerm<DataFieldTypes>;
    /**
        Title
    */
    Title: AnnotationTerm<DataFieldTypes>;
    /**
        Image URL for an instance of the entity type. If the property ImageUrl has a valid value, it can be used for the visualization of the instance. If it is not available or not valid the property TypeImageUrl can be used instead.
    */
    ImageUrl?: PropertyAnnotationValue<Edm.String>;
    /**
        Image URL for the entity type
    */
    TypeImageUrl?: PropertyAnnotationValue<Edm.String>;
    /**
        Main information on the business card
    */
    MainInfo?: AnnotationTerm<DataFieldTypes>;
    /**
        Additional information on the business card
    */
    SecondaryInfo?: AnnotationTerm<DataFieldTypes>;
};
/**
  Collection of data fields for representation in a table or list
*/
export declare type LineItem = AnnotationTerm<DataFieldAbstractTypes[]>;
/**
  Collection of data fields describing the status of an entity
*/
export declare type StatusInfo = AnnotationTerm<DataFieldAbstractTypes[]>;
/**
  Group of fields with an optional label
*/
export declare type FieldGroup = AnnotationTerm<FieldGroupTypeTypes>;
export declare type FieldGroupType = ComplexType & {
    $Type: UIAnnotationTypes.FieldGroupType;
    /**
        Label for the field group
    */
    Label?: PropertyAnnotationValue<Edm.String>;
    /**
        Collection of data fields
    */
    Data: AnnotationTerm<DataFieldAbstractTypes[]>;
};
/**
  Group of semantically connected fields with a representation template and an optional label
*/
export declare type ConnectedFields = AnnotationTerm<ConnectedFieldsTypeTypes>;
/**
  Group of semantically connected fields with a representation template and an optional label
*/
export declare type ConnectedFieldsType = ComplexType & {
    $Type: UIAnnotationTypes.ConnectedFieldsType;
    /**
        Label for the connected fields
    */
    Label?: PropertyAnnotationValue<Edm.String>;
    /**
        Template for representing the connected fields
    */
    Template: PropertyAnnotationValue<Edm.String>;
    /**
        Dictionary of template variables
    */
    Data: Core.Dictionary;
};
/**
  Collection of geographic locations
*/
export declare type GeoLocations = AnnotationTerm<GeoLocationTypeTypes[]>;
/**
  Geographic location
*/
export declare type GeoLocation = AnnotationTerm<GeoLocationTypeTypes>;
/**
  Properties that define a geographic location
*/
export declare type GeoLocationType = ComplexType & {
    $Type: UIAnnotationTypes.GeoLocationType;
    /**
        Geographic latitude
    */
    Latitude?: PropertyAnnotationValue<Edm.Double>;
    /**
        Geographic longitude
    */
    Longitude?: PropertyAnnotationValue<Edm.Double>;
    /**
        A point in a round-earth coordinate system
    */
    Location?: PropertyAnnotationValue<Edm.GeographyPoint>;
    /**
        vCard-style address
    */
    Address?: Communication.AddressType;
};
/**
  Collection of contacts
*/
export declare type Contacts = AnnotationTerm<Edm.AnnotationPath<any>[]>;
/**
  Properties that describe a media resource
*/
export declare type MediaResource = AnnotationTerm<MediaResourceTypeTypes>;
export declare type MediaResourceType = ComplexType & {
    $Type: UIAnnotationTypes.MediaResourceType;
    /**
        URL of media resource
    */
    Url: PropertyAnnotationValue<Edm.String>;
    /**
        Content type, such as application/pdf, video/x-flv, image/jpeg
    */
    ContentType?: PropertyAnnotationValue<Edm.String>;
    /**
        Resource size in bytes
    */
    ByteSize?: PropertyAnnotationValue<Edm.Int64>;
    /**
        Date of last change
    */
    ChangedAt?: PropertyAnnotationValue<Edm.DateTimeOffset>;
    /**
        Thumbnail image
    */
    Thumbnail?: AnnotationTerm<ImageTypeTypes>;
    /**
        Resource title
    */
    Title: AnnotationTerm<DataFieldTypes>;
    /**
        Resource description
    */
    Description?: AnnotationTerm<DataFieldTypes>;
};
export declare type ImageType = ComplexType & {
    $Type: UIAnnotationTypes.ImageType;
    /**
        URL of image
    */
    Url: PropertyAnnotationValue<Edm.String>;
    /**
        Width of image
    */
    Width?: PropertyAnnotationValue<Edm.String>;
    /**
        Height of image
    */
    Height?: PropertyAnnotationValue<Edm.String>;
};
/**
  Visualization of a single point of data, typically a number; may also be textual, e.g. a status value
*/
export declare type DataPoint = AnnotationTerm<DataPointTypeTypes>;
export declare type DataPointType = ComplexType & {
    $Type: UIAnnotationTypes.DataPointType;
    /**
        Title of the data point
    */
    Title?: PropertyAnnotationValue<Edm.String>;
    /**
        Short description
    */
    Description?: PropertyAnnotationValue<Edm.String>;
    /**
        Full description
    */
    LongDescription?: PropertyAnnotationValue<Edm.String>;
    /**
        Numeric value
    */
    Value: PropertyAnnotationValue<Edm.PrimitiveType>;
    /**
        Target value
    */
    TargetValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
    /**
        Forecast value
    */
    ForecastValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
    /**
        Minimum value (for output rendering)
    */
    MinimumValue?: PropertyAnnotationValue<Edm.Decimal>;
    /**
        Maximum value (for output rendering)
    */
    MaximumValue?: PropertyAnnotationValue<Edm.Decimal>;
    /**
        Number format
    */
    ValueFormat?: AnnotationTerm<NumberFormatTypes>;
    /**
        Preferred visualization
    */
    Visualization?: VisualizationType;
    /**
        
              Sample size used for the determination of the data point; should contain just integer value as Edm.Byte, Edm.SByte, Edm.Intxx, and Edm.Decimal with scale 0.
            
    */
    SampleSize?: PropertyAnnotationValue<Edm.PrimitiveType>;
    /**
        Reference period
    */
    ReferencePeriod?: AnnotationTerm<ReferencePeriodTypes>;
    /**
        Service-calculated criticality, alternative to CriticalityCalculation
    */
    Criticality?: CriticalityType;
    /**
        Custom labels for the criticality legend. Annotation path MUST end in UI.CriticalityLabels
    */
    CriticalityLabels?: Edm.AnnotationPath<any>;
    /**
        Decides if criticality is visualized in addition by means of an icon
    */
    CriticalityRepresentation?: CriticalityRepresentationType;
    /**
        Parameters for client-calculated criticality, alternative to Criticality
    */
    CriticalityCalculation?: AnnotationTerm<CriticalityCalculationTypeTypes>;
    /**
        Service-calculated trend, alternative to TrendCalculation
    */
    Trend?: TrendType;
    /**
        Parameters for client-calculated trend, alternative to Trend
    */
    TrendCalculation?: AnnotationTerm<TrendCalculationTypeTypes>;
    /**
        Contact person
    */
    Responsible?: Communication.ContactType;
};
/**
  Describes how to visualise a number
*/
export declare type NumberFormat = ComplexType & {
    $Type: UIAnnotationTypes.NumberFormat;
    /**
        Display value in *ScaleFactor* units, e.g. 1000 for k (kilo), 1e6 for M (Mega)
    */
    ScaleFactor?: PropertyAnnotationValue<Edm.Decimal>;
    /**
        Number of fractional digits of the scaled value to be visualized
    */
    NumberOfFractionalDigits?: PropertyAnnotationValue<Edm.Byte>;
};
export declare const enum VisualizationType {
    /**
    Visualize as a number
    */
    /**
    undefined
    */
    Number = "UI.VisualizationType/Number",
    /**
    Visualize as bullet chart - requires TargetValue
    */
    /**
    undefined
    */
    BulletChart = "UI.VisualizationType/BulletChart",
    /**
    Visualize as progress indicator - requires TargetValue
    */
    /**
    undefined
    */
    Progress = "UI.VisualizationType/Progress",
    /**
    Visualize as partially or completely filled stars/hearts/... - requires TargetValue
    */
    /**
    undefined
    */
    Rating = "UI.VisualizationType/Rating",
    /**
    Visualize as donut, optionally with missing segment - requires TargetValue
    */
    /**
    undefined
    */
    Donut = "UI.VisualizationType/Donut",
    /**
    Visualize as delta bullet chart - requires TargetValue
    */
    /**
    undefined
    */
    DeltaBulletChart = "UI.VisualizationType/DeltaBulletChart"
}
/**
  Reference period
*/
export declare type ReferencePeriod = ComplexType & {
    $Type: UIAnnotationTypes.ReferencePeriod;
    /**
        Short description of the reference period
    */
    Description?: PropertyAnnotationValue<Edm.String>;
    /**
        Start of the reference period
    */
    Start?: PropertyAnnotationValue<Edm.DateTimeOffset>;
    /**
        End of the reference period
    */
    End?: PropertyAnnotationValue<Edm.DateTimeOffset>;
};
/**
  Criticality of a value or status, represented e.g. via semantic colors (https://experience.sap.com/fiori-design-web/foundation/colors/#semantic-colors)
*/
export declare const enum CriticalityType {
    /**
    Very negative / dark-red status - risk - out of stock - late
    */
    /**
    undefined
    */
    VeryNegative = "UI.CriticalityType/VeryNegative",
    /**
    Neutral / grey status - inactive - open - in progress
    */
    /**
    undefined
    */
    Neutral = "UI.CriticalityType/Neutral",
    /**
    Negative / red status - attention - overload - alert
    */
    /**
    undefined
    */
    Negative = "UI.CriticalityType/Negative",
    /**
    Critical / orange status - warning
    */
    /**
    undefined
    */
    Critical = "UI.CriticalityType/Critical",
    /**
    Positive / green status - completed - available - on track - acceptable
    */
    /**
    undefined
    */
    Positive = "UI.CriticalityType/Positive",
    /**
    Very positive / blue status - above max stock - excess
    */
    /**
    undefined
    */
    VeryPositive = "UI.CriticalityType/VeryPositive"
}
/**
  Describes how to calculate the criticality of a value depending on the improvement direction
*/
export declare type CriticalityCalculationType = ComplexType & Omit<CriticalityThresholdsType, "$Type"> & {
    $Type: UIAnnotationTypes.CriticalityCalculationType;
    /**
    Reference value for the calculation, e.g. number of sales for the last year
*/
    ReferenceValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
    /**
    Calculate with a relative difference
*/
    IsRelativeDifference: PropertyAnnotationValue<Edm.Boolean>;
    /**
    Describes in which direction the value improves
*/
    ImprovementDirection: ImprovementDirectionType;
    /**
    List of thresholds depending on the aggregation level as a set of constant values
*/
    ConstantThresholds: AnnotationTerm<LevelThresholdsTypeTypes[]>;
};
/**
  Thresholds for calculating the criticality of a value
*/
export declare type CriticalityThresholdsType = ComplexType & {
    $Type: UIAnnotationTypes.CriticalityThresholdsType;
    /**
        Lowest value that is considered positive
    */
    AcceptanceRangeLowValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
    /**
        Highest value that is considered positive
    */
    AcceptanceRangeHighValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
    /**
        Lowest value that is considered neutral
    */
    ToleranceRangeLowValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
    /**
        Highest value that is considered neutral
    */
    ToleranceRangeHighValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
    /**
        Lowest value that is considered critical
    */
    DeviationRangeLowValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
    /**
        Highest value that is considered critical
    */
    DeviationRangeHighValue?: PropertyAnnotationValue<Edm.PrimitiveType>;
};
/**
  Describes which direction of a value change is seen as an improvement
*/
export declare const enum ImprovementDirectionType {
    /**
    Lower is better
    */
    /**
    undefined
    */
    Minimize = "UI.ImprovementDirectionType/Minimize",
    /**
    Closer to the target is better
    */
    /**
    undefined
    */
    Target = "UI.ImprovementDirectionType/Target",
    /**
    Higher is better
    */
    /**
    undefined
    */
    Maximize = "UI.ImprovementDirectionType/Maximize"
}
/**
  Thresholds for an aggregation level
*/
export declare type LevelThresholdsType = ComplexType & Omit<CriticalityThresholdsType, "$Type"> & {
    $Type: UIAnnotationTypes.LevelThresholdsType;
    /**
    An unordered tuple of dimensions, i.e. properties which are intended to be used for grouping in aggregating requests. In analytical UIs, e.g. an analytical chart, the aggregation level typically corresponds to the visible dimensions.
*/
    AggregationLevel: PropertyAnnotationValue<Edm.PropertyPath[]>;
};
/**
  The trend of a value
*/
export declare const enum TrendType {
    /**
    Value grows strongly
    */
    /**
    undefined
    */
    StrongUp = "UI.TrendType/StrongUp",
    /**
    Value grows
    */
    /**
    undefined
    */
    Up = "UI.TrendType/Up",
    /**
    Value does not significantly grow or shrink
    */
    /**
    undefined
    */
    Sideways = "UI.TrendType/Sideways",
    /**
    Value shrinks
    */
    /**
    undefined
    */
    Down = "UI.TrendType/Down",
    /**
    Value shrinks strongly
    */
    /**
    undefined
    */
    StrongDown = "UI.TrendType/StrongDown"
}
/**
  Describes how to calculate the trend of a value
*/
export declare type TrendCalculationType = ComplexType & {
    $Type: UIAnnotationTypes.TrendCalculationType;
    /**
        Reference value for the calculation, e.g. number of sales for the last year
    */
    ReferenceValue: PropertyAnnotationValue<Edm.PrimitiveType>;
    /**
        Calculate with a relative difference
    */
    IsRelativeDifference: PropertyAnnotationValue<Edm.Boolean>;
    /**
        Threshold for Up
    */
    UpDifference: PropertyAnnotationValue<Edm.Decimal>;
    /**
        Threshold for StrongUp
    */
    StrongUpDifference: PropertyAnnotationValue<Edm.Decimal>;
    /**
        Threshold for Down
    */
    DownDifference: PropertyAnnotationValue<Edm.Decimal>;
    /**
        Threshold for StrongDown
    */
    StrongDownDifference: PropertyAnnotationValue<Edm.Decimal>;
};
/**
  A Key Performance Indicator (KPI) bundles a SelectionVariant and a DataPoint, and provides details for progressive disclosure
*/
export declare type KPI = AnnotationTerm<KPITypeTypes>;
export declare type KPIType = ComplexType & {
    $Type: UIAnnotationTypes.KPIType;
    /**
        Optional identifier to reference this instance from an external context
    */
    ID?: PropertyAnnotationValue<Edm.String>;
    /**
        Very short description
    */
    ShortDescription?: PropertyAnnotationValue<Edm.String>;
    /**
        Selection variant, either specified inline or referencing another annotation via Path
    */
    SelectionVariant: AnnotationTerm<SelectionVariantTypeTypes>;
    /**
        Data point, either specified inline or referencing another annotation via Path
    */
    DataPoint: AnnotationTerm<DataPointTypeTypes>;
    /**
        Additional data points, either specified inline or referencing another annotation via Path
    */
    AdditionalDataPoints: AnnotationTerm<DataPointTypeTypes[]>;
    /**
        Contains information about KPI details, especially drill-down presentations
    */
    Detail?: AnnotationTerm<KPIDetailTypeTypes>;
};
export declare type KPIDetailType = ComplexType & {
    $Type: UIAnnotationTypes.KPIDetailType;
    /**
        Presentation variant, either specified inline or referencing another annotation via Path
    */
    DefaultPresentationVariant?: AnnotationTerm<PresentationVariantTypeTypes>;
    /**
        A list of alternative presentation variants, either specified inline or referencing another annotation via Path
    */
    AlternativePresentationVariants: AnnotationTerm<PresentationVariantTypeTypes[]>;
    /**
        Name of the Semantic Object. If not specified, use Semantic Object annotated at the property referenced in KPI/DataPoint/Value
    */
    SemanticObject?: PropertyAnnotationValue<Edm.String>;
    /**
        Name of the Action on the Semantic Object. If not specified, let user choose which of the available actions to trigger.
    */
    Action?: PropertyAnnotationValue<Edm.String>;
};
/**
  Visualization of multiple data points
*/
export declare type Chart = AnnotationTerm<ChartDefinitionTypeTypes>;
export declare type ChartDefinitionType = ComplexType & {
    $Type: UIAnnotationTypes.ChartDefinitionType;
    /**
        Title of the chart
    */
    Title?: PropertyAnnotationValue<Edm.String>;
    /**
        Short description
    */
    Description?: PropertyAnnotationValue<Edm.String>;
    /**
        Chart type
    */
    ChartType: ChartType;
    /**
        Describes the scale of the chart value axes
    */
    AxisScaling?: AnnotationTerm<ChartAxisScalingTypeTypes>;
    /**
        Measures of the chart, e.g. size and color in a bubble chart
    */
    Measures: PropertyAnnotationValue<Edm.PropertyPath[]>;
    /**
        Describes Attributes for Measures. All Measures used in this collection must also be part of the Measures Property.
    */
    MeasureAttributes: AnnotationTerm<ChartMeasureAttributeTypeTypes[]>;
    /**
        Dimensions of the chart, e.g. x- and y-axis of a bubble chart
    */
    Dimensions: PropertyAnnotationValue<Edm.PropertyPath[]>;
    /**
        Describes Attributes for Dimensions. All Dimensions used in this collection must also be part of the Dimensions Property.
    */
    DimensionAttributes: AnnotationTerm<ChartDimensionAttributeTypeTypes[]>;
    /**
        Available actions
    */
    Actions: AnnotationTerm<DataFieldForActionAbstractTypes[]>;
};
export declare const enum ChartType {
    Column = "UI.ChartType/Column",
    ColumnStacked = "UI.ChartType/ColumnStacked",
    ColumnDual = "UI.ChartType/ColumnDual",
    ColumnStackedDual = "UI.ChartType/ColumnStackedDual",
    ColumnStacked100 = "UI.ChartType/ColumnStacked100",
    ColumnStackedDual100 = "UI.ChartType/ColumnStackedDual100",
    Bar = "UI.ChartType/Bar",
    BarStacked = "UI.ChartType/BarStacked",
    BarDual = "UI.ChartType/BarDual",
    BarStackedDual = "UI.ChartType/BarStackedDual",
    BarStacked100 = "UI.ChartType/BarStacked100",
    BarStackedDual100 = "UI.ChartType/BarStackedDual100",
    Area = "UI.ChartType/Area",
    AreaStacked = "UI.ChartType/AreaStacked",
    AreaStacked100 = "UI.ChartType/AreaStacked100",
    HorizontalArea = "UI.ChartType/HorizontalArea",
    HorizontalAreaStacked = "UI.ChartType/HorizontalAreaStacked",
    HorizontalAreaStacked100 = "UI.ChartType/HorizontalAreaStacked100",
    Line = "UI.ChartType/Line",
    LineDual = "UI.ChartType/LineDual",
    Combination = "UI.ChartType/Combination",
    CombinationStacked = "UI.ChartType/CombinationStacked",
    CombinationDual = "UI.ChartType/CombinationDual",
    CombinationStackedDual = "UI.ChartType/CombinationStackedDual",
    HorizontalCombinationStacked = "UI.ChartType/HorizontalCombinationStacked",
    Pie = "UI.ChartType/Pie",
    Donut = "UI.ChartType/Donut",
    Scatter = "UI.ChartType/Scatter",
    Bubble = "UI.ChartType/Bubble",
    Radar = "UI.ChartType/Radar",
    HeatMap = "UI.ChartType/HeatMap",
    TreeMap = "UI.ChartType/TreeMap",
    Waterfall = "UI.ChartType/Waterfall",
    Bullet = "UI.ChartType/Bullet",
    VerticalBullet = "UI.ChartType/VerticalBullet",
    HorizontalWaterfall = "UI.ChartType/HorizontalWaterfall",
    HorizontalCombinationDual = "UI.ChartType/HorizontalCombinationDual",
    HorizontalCombinationStackedDual = "UI.ChartType/HorizontalCombinationStackedDual",
    Donut100 = "UI.ChartType/Donut100"
}
export declare type ChartAxisScalingType = ComplexType & {
    $Type: UIAnnotationTypes.ChartAxisScalingType;
    /**
        Scale is fixed or adapts automatically to rendered values
    */
    ScaleBehavior: ChartAxisScaleBehaviorType;
    /**
        Settings for automatic scaling
    */
    AutoScaleBehavior?: AnnotationTerm<ChartAxisAutoScaleBehaviorTypeTypes>;
    /**
        Boundary values for fixed scaling of a stacking chart type with multiple measures
    */
    FixedScaleMultipleStackedMeasuresBoundaryValues?: AnnotationTerm<FixedScaleMultipleStackedMeasuresBoundaryValuesTypeTypes>;
};
export declare const enum ChartAxisScaleBehaviorType {
    /**
    Value axes scale automatically
    */
    /**
    undefined
    */
    AutoScale = "UI.ChartAxisScaleBehaviorType/AutoScale",
    /**
    Fixed minimum and maximum values are applied, which are derived from the @UI.MeasureAttributes.DataPoint/MinimumValue and .../MaximumValue annotation by default.
        For stacking chart types with multiple measures, they are taken from ChartAxisScalingType/FixedScaleMultipleStackedMeasuresBoundaryValues.
            
    */
    /**
    undefined
    */
    FixedScale = "UI.ChartAxisScaleBehaviorType/FixedScale"
}
export declare type ChartAxisAutoScaleBehaviorType = ComplexType & {
    $Type: UIAnnotationTypes.ChartAxisAutoScaleBehaviorType;
    /**
        Forces the value axis to always display the zero value
    */
    ZeroAlwaysVisible: PropertyAnnotationValue<Edm.Boolean>;
    /**
        Determines the automatic scaling
    */
    DataScope: ChartAxisAutoScaleDataScopeType;
};
export declare const enum ChartAxisAutoScaleDataScopeType {
    /**
    Minimum and maximum axes values are determined from the entire data set
    */
    /**
    undefined
    */
    DataSet = "UI.ChartAxisAutoScaleDataScopeType/DataSet",
    /**
    Minimum and maximum axes values are determined from the currently visible data. Scrolling will change the scale.
    */
    /**
    undefined
    */
    VisibleData = "UI.ChartAxisAutoScaleDataScopeType/VisibleData"
}
export declare type FixedScaleMultipleStackedMeasuresBoundaryValuesType = ComplexType & {
    $Type: UIAnnotationTypes.FixedScaleMultipleStackedMeasuresBoundaryValuesType;
    /**
        Minimum value on value axes
    */
    MinimumValue: PropertyAnnotationValue<Edm.Decimal>;
    /**
        Maximum value on value axes
    */
    MaximumValue: PropertyAnnotationValue<Edm.Decimal>;
};
export declare type ChartDimensionAttributeType = ComplexType & {
    $Type: UIAnnotationTypes.ChartDimensionAttributeType;
    Dimension?: PropertyAnnotationValue<Edm.PropertyPath>;
    Role?: ChartDimensionRoleType;
    /**
        For a dimension with a hierarchy, members are selected from this level. The root node of the hierarchy is at level 0.
    */
    HierarchyLevel?: PropertyAnnotationValue<Edm.Int32>;
    /**
        All values in this collection should be assigned to levels of the same color.
    */
    ValuesForSequentialColorLevels: PropertyAnnotationValue<Edm.String[]>;
    /**
        All values in this collection should be emphasized.
    */
    EmphasizedValues: PropertyAnnotationValue<Edm.String[]>;
    /**
        Assign a label to values with an emphasized representation. This is required, if more than one emphasized value has been specified.
    */
    EmphasisLabels?: AnnotationTerm<EmphasisLabelTypeTypes>;
};
export declare type ChartMeasureAttributeType = ComplexType & {
    $Type: UIAnnotationTypes.ChartMeasureAttributeType;
    Measure?: PropertyAnnotationValue<Edm.PropertyPath>;
    Role?: ChartMeasureRoleType;
    /**
        Annotation path MUST end in @UI.DataPoint and the data point's Value MUST be the same property as in Measure
    */
    DataPoint?: Edm.AnnotationPath<any>;
    /**
        All measures for which this setting is true should be assigned to levels of the same color.
    */
    UseSequentialColorLevels: PropertyAnnotationValue<Edm.Boolean>;
};
export declare const enum ChartDimensionRoleType {
    Category = "UI.ChartDimensionRoleType/Category",
    Series = "UI.ChartDimensionRoleType/Series",
    Category2 = "UI.ChartDimensionRoleType/Category2"
}
export declare const enum ChartMeasureRoleType {
    Axis1 = "UI.ChartMeasureRoleType/Axis1",
    Axis2 = "UI.ChartMeasureRoleType/Axis2",
    Axis3 = "UI.ChartMeasureRoleType/Axis3"
}
/**
  Assigns a label to the set of emphasized values and optionally also for non-emphasized values. This information can be used for semantic coloring.
*/
export declare type EmphasisLabelType = ComplexType & {
    $Type: UIAnnotationTypes.EmphasisLabelType;
    EmphasizedValuesLabel: PropertyAnnotationValue<Edm.String>;
    NonEmphasizedValuesLabel?: PropertyAnnotationValue<Edm.String>;
};
/**
  Assign criticalities to primitive values. This information can be used for semantic coloring.
*/
export declare type ValueCriticality = AnnotationTerm<ValueCriticalityTypeTypes[]>;
/**
  Assigns a fixed criticality to a primitive value. This information can be used for semantic coloring.
*/
export declare type ValueCriticalityType = ComplexType & {
    $Type: UIAnnotationTypes.ValueCriticalityType;
    /**
        MUST be a fixed value of primitive type
    */
    Value?: PropertyAnnotationValue<Edm.PrimitiveType>;
    Criticality?: CriticalityType;
};
/**
  
              Assign labels to criticalities. This information can be used for semantic coloring.
              When applied to a property, a label for a criticality must be provided, if more than one value of the annotated property has been assigned to the same criticality.
              There must be no more than one label per criticality.
          
*/
export declare type CriticalityLabels = AnnotationTerm<CriticalityLabelTypeTypes[]>;
/**
  Assigns a label to a criticality. This information can be used for semantic coloring.
*/
export declare type CriticalityLabelType = ComplexType & {
    $Type: UIAnnotationTypes.CriticalityLabelType;
    Criticality: CriticalityType;
    /**
        Criticality label
    */
    Label: PropertyAnnotationValue<Edm.String>;
};
/**
  Properties that might be relevant for filtering a collection of entities of this type
*/
export declare type SelectionFields = AnnotationTerm<Edm.PropertyPath[]>;
/**
  Collection of facets
*/
export declare type Facets = AnnotationTerm<FacetTypes[]>;
/**
  Facets for additional object header information
*/
export declare type HeaderFacets = AnnotationTerm<FacetTypes[]>;
/**
  Facets that may be used for a quick overview of the object
*/
export declare type QuickViewFacets = AnnotationTerm<FacetTypes[]>;
/**
  Facets that may be used for a (quick) create of the object
*/
export declare type QuickCreateFacets = AnnotationTerm<FacetTypes[]>;
/**
  Facets that reference UI.FieldGroup annotations to group filterable fields
*/
export declare type FilterFacets = AnnotationTerm<ReferenceFacetTypes[]>;
/**
  Abstract base type for facets
*/
export declare type Facet = ComplexType & {
    $Type: UIAnnotationTypes.Facet;
    /**
        Facet label
    */
    Label?: PropertyAnnotationValue<Edm.String>;
    /**
        Unique identifier of a facet. ID should be stable, as long as the perceived semantics of the facet is unchanged.
    */
    ID?: PropertyAnnotationValue<Edm.String>;
};
/**
  Collection of facets
*/
export declare type CollectionFacet = ComplexType & Omit<Facet, "$Type"> & {
    $Type: UIAnnotationTypes.CollectionFacet;
    /**
    Nested facets. An empty collection may be used as a placeholder for content added via extension points.
*/
    Facets: AnnotationTerm<FacetTypes[]>;
};
/**
  Facet that refers to a thing perspective, e.g. LineItem
*/
export declare type ReferenceFacet = ComplexType & Omit<Facet, "$Type"> & {
    $Type: UIAnnotationTypes.ReferenceFacet;
    /**
    Referenced information: Communication.Contact, Communication.Address, or a term that is tagged with UI.ThingPerspective, e.g. UI.StatusInfo, UI.LineItem, UI.Identification, UI.FieldGroup, UI.Badge
*/
    Target: Edm.AnnotationPath<any>;
};
/**
  Facet that refers to a URL
*/
export declare type ReferenceURLFacet = ComplexType & Omit<Facet, "$Type"> & {
    $Type: UIAnnotationTypes.ReferenceURLFacet;
    /**
    URL of referenced information
*/
    Url: PropertyAnnotationValue<Edm.String>;
    /**
    Media type of referenced information
*/
    UrlContentType?: PropertyAnnotationValue<Edm.String>;
};
/**
  A SelectionPresentationVariant bundles a Selection Variant and a Presentation Variant
*/
export declare type SelectionPresentationVariant = AnnotationTerm<SelectionPresentationVariantTypeTypes>;
export declare type SelectionPresentationVariantType = ComplexType & {
    $Type: UIAnnotationTypes.SelectionPresentationVariantType;
    /**
        Optional identifier to reference this variant from an external context
    */
    ID?: PropertyAnnotationValue<Edm.String>;
    /**
        Name of the bundling variant
    */
    Text?: PropertyAnnotationValue<Edm.String>;
    /**
        Selection variant, either specified inline or referencing another annotation via Path
    */
    SelectionVariant: AnnotationTerm<SelectionVariantTypeTypes>;
    /**
        Presentation variant, either specified inline or referencing another annotation via Path
    */
    PresentationVariant: AnnotationTerm<PresentationVariantTypeTypes>;
};
/**
  Defines how the result of a queried collection of entities is shaped and how this result is displayed
*/
export declare type PresentationVariant = AnnotationTerm<PresentationVariantTypeTypes>;
export declare type PresentationVariantType = ComplexType & {
    $Type: UIAnnotationTypes.PresentationVariantType;
    /**
        Optional identifier to reference this variant from an external context
    */
    ID?: PropertyAnnotationValue<Edm.String>;
    /**
        Name of the presentation variant
    */
    Text?: PropertyAnnotationValue<Edm.String>;
    /**
        Maximum number of items that should be included in the result
    */
    MaxItems?: PropertyAnnotationValue<Edm.Int32>;
    /**
        Collection can be provided inline or as a reference to a Common.SortOrder annotation via Path
    */
    SortOrder: Common.SortOrderType[];
    /**
        Sequence of groupable properties p1, p2, ... defining how the result is composed of instances representing groups,
            one for each combination of value properties in the queried collection. The sequence specifies a certain level
            of aggregation for the queried collection, and every group instance will provide aggregated values for
            properties that are aggregatable. Moreover, the series of sub-sequences (p1), (p1, p2), ... forms a leveled hierarchy,
            which may become relevant in combination with `InitialExpansionLevel`.
    */
    GroupBy: PropertyAnnotationValue<Edm.PropertyPath[]>;
    /**
        Sub-sequence q1, q2, ... of properties p1, p2, ... specified in GroupBy. With this, additional levels of aggregation
            are requested in addition to the most granular level defined by GroupBy: Every element in the series of sub-sequences
            (q1), (q1, q2), ... introduces an additional aggregation level included in the result.
    */
    TotalBy: PropertyAnnotationValue<Edm.PropertyPath[]>;
    /**
        Aggregatable properties for which aggregated values should be provided for the additional aggregation levels specified in TotalBy.
    */
    Total: PropertyAnnotationValue<Edm.PropertyPath[]>;
    /**
        Result should include a grand total for the properties specified in Total
    */
    IncludeGrandTotal: PropertyAnnotationValue<Edm.Boolean>;
    /**
        Level up to which the hierarchy defined for the queried collection should be expanded initially.
            The hierarchy may be implicitly imposed by the sequence of the GroupBy, or by an explicit hierarchy annotation.
    */
    InitialExpansionLevel: PropertyAnnotationValue<Edm.Int32>;
    /**
        Lists available visualization types. Currently supported types are `UI.LineItem`, `UI.Chart`, and `UI.DataPoint`.
              For each type, no more than a single annotation is meaningful. Multiple instances of the same visualization type
              shall be modeled with different presentation variants.
              A reference to `UI.Lineitem` should always be part of the collection (least common denominator for renderers).
              The first entry of the collection is the default visualization.
            
    */
    Visualizations: Edm.AnnotationPath<any>[];
    /**
        Properties that should always be included in the result of the queried collection
    */
    RequestAtLeast: PropertyAnnotationValue<Edm.PropertyPath[]>;
    /**
        Properties that should be presented for filtering a collection of entities.
            Can be provided inline or as a reference to a `UI.SelectionFields` annotation via Path.
    */
    SelectionFields: PropertyAnnotationValue<Edm.PropertyPath[]>;
};
/**
  A SelectionVariant denotes a combination of parameters and filters to query the annotated entity set
*/
export declare type SelectionVariant = AnnotationTerm<SelectionVariantTypeTypes>;
export declare type SelectionVariantType = ComplexType & {
    $Type: UIAnnotationTypes.SelectionVariantType;
    /**
         May contain identifier to reference this instance from an external context
    */
    ID?: PropertyAnnotationValue<Edm.String>;
    /**
        Name of the selection variant
    */
    Text?: PropertyAnnotationValue<Edm.String>;
    /**
        Parameters of the selection variant
    */
    Parameters: AnnotationTerm<ParameterAbstractTypes[]>;
    /**
        Filter string for query part of URL, without `$filter=`
    */
    FilterExpression?: PropertyAnnotationValue<Edm.String>;
    /**
        ABAP Select Options Pattern
    */
    SelectOptions: AnnotationTerm<SelectOptionTypeTypes[]>;
};
/**
  Key property of a parameter entity type
*/
export declare type ParameterAbstract = ComplexType & {
    $Type: UIAnnotationTypes.ParameterAbstract;
};
/**
  Single-valued parameter
*/
export declare type Parameter = ComplexType & Omit<ParameterAbstract, "$Type"> & {
    $Type: UIAnnotationTypes.Parameter;
    /**
    Path to a key property of a parameter entity type
*/
    PropertyName: PropertyAnnotationValue<Edm.PropertyPath>;
    /**
    Value for the key property
*/
    PropertyValue: PropertyAnnotationValue<Edm.PrimitiveType>;
};
/**
  Interval parameter formed with a 'from' and a 'to' property
*/
export declare type IntervalParameter = ComplexType & Omit<ParameterAbstract, "$Type"> & {
    $Type: UIAnnotationTypes.IntervalParameter;
    /**
    Path to the 'from' property of a parameter entity type
*/
    PropertyNameFrom: PropertyAnnotationValue<Edm.PropertyPath>;
    /**
    Value for the 'from' property
*/
    PropertyValueFrom: PropertyAnnotationValue<Edm.PrimitiveType>;
    /**
    Path to the 'to' property of a parameter entity type
*/
    PropertyNameTo: PropertyAnnotationValue<Edm.PropertyPath>;
    /**
    Value for the 'to' property
*/
    PropertyValueTo: PropertyAnnotationValue<Edm.PrimitiveType>;
};
/**
  List of value ranges for a single property
*/
export declare type SelectOptionType = ComplexType & {
    $Type: UIAnnotationTypes.SelectOptionType;
    /**
        Path to the property
    */
    PropertyName: PropertyAnnotationValue<Edm.PropertyPath>;
    /**
        List of value ranges
    */
    Ranges: AnnotationTerm<SelectionRangeTypeTypes[]>;
};
/**
  Value range. If the range option only requires a single value, the value must be in the property Low
*/
export declare type SelectionRangeType = ComplexType & {
    $Type: UIAnnotationTypes.SelectionRangeType;
    /**
        Include or exclude values
    */
    Sign: SelectionRangeSignType;
    /**
        Comparison operator
    */
    Option: SelectionRangeOptionType;
    /**
        Single value or lower interval boundary
    */
    Low: PropertyAnnotationValue<Edm.PrimitiveType>;
    /**
        Upper interval boundary
    */
    High?: PropertyAnnotationValue<Edm.PrimitiveType>;
};
export declare const enum SelectionRangeSignType {
    /**
    Inclusive
    */
    /**
    undefined
    */
    I = "UI.SelectionRangeSignType/I",
    /**
    Exclusive
    */
    /**
    undefined
    */
    E = "UI.SelectionRangeSignType/E"
}
/**
  Comparison operator
*/
export declare const enum SelectionRangeOptionType {
    /**
    Equal to
    */
    /**
    undefined
    */
    EQ = "UI.SelectionRangeOptionType/EQ",
    /**
    Between
    */
    /**
    undefined
    */
    BT = "UI.SelectionRangeOptionType/BT",
    /**
    Contains pattern
    */
    /**
    undefined
    */
    CP = "UI.SelectionRangeOptionType/CP",
    /**
    Less than or equal to
    */
    /**
    undefined
    */
    LE = "UI.SelectionRangeOptionType/LE",
    /**
    Greater than or equal to
    */
    /**
    undefined
    */
    GE = "UI.SelectionRangeOptionType/GE",
    /**
    Not equal to
    */
    /**
    undefined
    */
    NE = "UI.SelectionRangeOptionType/NE",
    /**
    Not between
    */
    /**
    undefined
    */
    NB = "UI.SelectionRangeOptionType/NB",
    /**
    Does not contain pattern
    */
    /**
    undefined
    */
    NP = "UI.SelectionRangeOptionType/NP",
    /**
    Greater than
    */
    /**
    undefined
    */
    GT = "UI.SelectionRangeOptionType/GT",
    /**
    Less than
    */
    /**
    undefined
    */
    LT = "UI.SelectionRangeOptionType/LT"
}
/**
  The annotated term is a Thing Perspective
*/
export declare type ThingPerspective = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  This Facet and all included Facets are the summary of the thing. At most one Facet of a thing can be tagged with this term
*/
export declare type IsSummary = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  This Facet and all included Facets are part of the Thing preview
*/
export declare type PartOfPreview = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  Target MUST reference a UI.GeoLocation, Communication.Address or a collection of these
*/
export declare type Map = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  Target MUST reference a UI.MediaResource
*/
export declare type Gallery = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  Properties and terms annotated with this term MUST contain a valid URL referencing an resource with a MIME type image
*/
export declare type IsImageURL = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  Properties annotated with this term MUST be a stream property annotated with a MIME type image
*/
export declare type IsImage = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  Properties annotated with this annotation should be rendered as multi-line text (e.g. text area)
*/
export declare type MultiLineText = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  A short, human-readable text that gives a hint or an example to help the user with data entry
*/
export declare type Placeholder = AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  Describes the arrangement of a code or ID value and its text
*/
export declare type TextArrangement = EnumValue<TextArrangementType>;
export declare const enum TextArrangementType {
    /**
    Text is first, followed by the code/ID (e.g. in parentheses)
    */
    /**
    undefined
    */
    TextFirst = "UI.TextArrangementType/TextFirst",
    /**
    Code/ID is first, followed by the text (e.g. separated by a dash)
    */
    /**
    undefined
    */
    TextLast = "UI.TextArrangementType/TextLast",
    /**
    Code/ID and text are represented separately
    */
    /**
    undefined
    */
    TextSeparate = "UI.TextArrangementType/TextSeparate",
    /**
    Only text is represented, code/ID is hidden (e.g. for UUIDs)
    */
    /**
    undefined
    */
    TextOnly = "UI.TextArrangementType/TextOnly"
}
/**
  Expresses the importance of e.g. a DataField or an annotation
*/
export declare type Importance = EnumValue<ImportanceType>;
export declare const enum ImportanceType {
    /**
    High importance
    */
    /**
    undefined
    */
    High = "UI.ImportanceType/High",
    /**
    Medium importance
    */
    /**
    undefined
    */
    Medium = "UI.ImportanceType/Medium",
    /**
    Low importance
    */
    /**
    undefined
    */
    Low = "UI.ImportanceType/Low"
}
/**
  Properties or facets (see UI.Facet) annotated with this term will not be rendered if the annotation evaluates to true.
*/
export declare type Hidden = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  EntitySets annotated with this term can control the visibility of the Create operation dynamically
*/
export declare type CreateHidden = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  EntitySets annotated with this term can control the visibility of the Edit/Save operation dynamically
*/
export declare type UpdateHidden = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  EntitySets annotated with this term can control the visibility of the Delete operation dynamically
*/
export declare type DeleteHidden = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  Properties annotated with this term will not be rendered as filter criteria if the annotation evaluates to true.
*/
export declare type HiddenFilter = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  Default representation of a property as a datafield, e.g. when the property is added as a table column or form field via personalization
*/
export declare type DataFieldDefault = AnnotationTerm<DataFieldAbstractTypes>;
/**
  Elementary building block that represents a piece of data and/or allows triggering an action
*/
export declare type DataFieldAbstract = ComplexType & {
    $Type: UIAnnotationTypes.DataFieldAbstract;
    /**
        A short, human-readable text suitable for labels and captions in UIs
    */
    Label?: PropertyAnnotationValue<Edm.String>;
    /**
        Criticality of the data field value
    */
    Criticality?: CriticalityType;
    /**
        Decides if criticality is visualized in addition by means of an icon
    */
    CriticalityRepresentation?: CriticalityRepresentationType;
    /**
        Optional icon
    */
    IconUrl?: PropertyAnnotationValue<Edm.String>;
};
export declare const enum CriticalityRepresentationType {
    /**
    Criticality is represented with an icon
    */
    /**
    undefined
    */
    WithIcon = "UI.CriticalityRepresentationType/WithIcon",
    /**
    Criticality is represented without icon, e.g. only via text color
    */
    /**
    undefined
    */
    WithoutIcon = "UI.CriticalityRepresentationType/WithoutIcon",
    /**
    Criticality is represented only by using an icon
    */
    /**
    undefined
    */
    OnlyIcon = "UI.CriticalityRepresentationType/OnlyIcon"
}
/**
  A structured piece of data described by an annotation
*/
export declare type DataFieldForAnnotation = ComplexType & Omit<DataFieldAbstract, "$Type"> & {
    $Type: UIAnnotationTypes.DataFieldForAnnotation;
    /**
    Target MUST reference an annotation of terms Communication.Contact, Communication.Address, UI.DataPoint, UI.Chart, UI.FieldGroup, or UI.ConnectedFields
*/
    Target: Edm.AnnotationPath<any>;
};
/**
  Triggers an action
*/
export declare type DataFieldForActionAbstract = ComplexType & Omit<DataFieldAbstract, "$Type"> & {
    $Type: UIAnnotationTypes.DataFieldForActionAbstract;
    /**
    Action should be placed close to (or even inside) the visualized term
*/
    Inline: PropertyAnnotationValue<Edm.Boolean>;
    /**
    Determines whether the action completes a process step (e.g. approve, reject).
*/
    Determining: PropertyAnnotationValue<Edm.Boolean>;
};
/**
  Triggers an OData action
*/
export declare type DataFieldForAction = ComplexType & Omit<DataFieldForActionAbstract, "$Type"> & {
    $Type: UIAnnotationTypes.DataFieldForAction;
    /**
    Qualified name of an Action, Function, ActionImport or FunctionImport in scope
*/
    Action: Common.ActionOverload;
    ActionTarget?: Edm.Action;
    /**
    Expresses how invocations of this action on multiple instances should be grouped
*/
    InvocationGrouping?: OperationGroupingType;
};
export declare const enum OperationGroupingType {
    /**
    Invoke each action in isolation from other actions
    */
    /**
    undefined
    */
    Isolated = "UI.OperationGroupingType/Isolated",
    /**
    Group all actions into a single change set
    */
    /**
    undefined
    */
    ChangeSet = "UI.OperationGroupingType/ChangeSet"
}
/**
  Triggers intent-based UI navigation
*/
export declare type DataFieldForIntentBasedNavigation = ComplexType & Omit<DataFieldForActionAbstract, "$Type"> & {
    $Type: UIAnnotationTypes.DataFieldForIntentBasedNavigation;
    /**
    Name of the Semantic Object
*/
    SemanticObject: PropertyAnnotationValue<Edm.String>;
    /**
    Name of the Action on the Semantic Object. If not specified, let user choose which of the available actions to trigger.
*/
    Action?: PropertyAnnotationValue<Edm.String>;
    /**
    Determines whether  a context needs to be passed to the target of this navigation.
*/
    RequiresContext: PropertyAnnotationValue<Edm.Boolean>;
    /**
    Maps properties of the annotated entity type to properties of the Semantic Object
*/
    Mapping: Common.SemanticObjectMappingType[];
};
/**
  A piece of data
*/
export declare type DataField = ComplexType & Omit<DataFieldAbstract, "$Type"> & {
    $Type: UIAnnotationTypes.DataField;
    /**
    The data field's value
*/
    Value: PropertyAnnotationValue<Edm.PrimitiveType>;
};
/**
  A piece of data that allows triggering an OData action
*/
export declare type DataFieldWithAction = ComplexType & Omit<DataField, "$Type"> & {
    $Type: UIAnnotationTypes.DataFieldWithAction;
    /**
    Qualified name of an Action, Function, ActionImport or FunctionImport in scope
*/
    Action: Common.QualifiedName;
    ActionTarget?: Edm.Action;
};
/**
  A piece of data that allows triggering intent-based UI navigation
*/
export declare type DataFieldWithIntentBasedNavigation = ComplexType & Omit<DataField, "$Type"> & {
    $Type: UIAnnotationTypes.DataFieldWithIntentBasedNavigation;
    /**
    Name of the Semantic Object
*/
    SemanticObject: PropertyAnnotationValue<Edm.String>;
    /**
    Name of the Action on the Semantic Object. If not specified, let user choose which of the available actions to trigger.
*/
    Action?: PropertyAnnotationValue<Edm.String>;
    /**
    Maps properties of the annotated entity type to properties of the Semantic Object
*/
    Mapping: Common.SemanticObjectMappingType[];
};
/**
  A piece of data that allows navigating to related data
*/
export declare type DataFieldWithNavigationPath = ComplexType & Omit<DataField, "$Type"> & {
    $Type: UIAnnotationTypes.DataFieldWithNavigationPath;
    /**
    Contains either a navigation property or a term cast, where term is of type Edm.EntityType or a concrete entity type or a collection of these types
*/
    Target: PropertyAnnotationValue<Edm.NavigationPropertyPath>;
};
/**
  A piece of data that allows navigating to other information on the Web
*/
export declare type DataFieldWithUrl = ComplexType & Omit<DataField, "$Type"> & {
    $Type: UIAnnotationTypes.DataFieldWithUrl;
    /**
    Target of the hyperlink
*/
    Url: PropertyAnnotationValue<Edm.String>;
    /**
    Media type of the hyperlink target, e.g. `video/mp4`
*/
    UrlContentType?: PropertyAnnotationValue<Edm.String>;
};
/**
   Service-calculated criticality, alternative to UI.CriticalityCalculation
*/
export declare type Criticality = EnumValue<CriticalityType>;
/**
  Parameters for client-calculated criticality, alternative to UI.Criticality
*/
export declare type CriticalityCalculation = AnnotationTerm<CriticalityCalculationTypeTypes>;
/**
  Sort by the referenced property instead of by the annotated property
*/
export declare type OrderBy = AnnotationTerm<Edm.PropertyPath>;
/**
  Define default values for action parameters
*/
export declare type ParameterDefaultValue = AnnotationTerm<Edm.PrimitiveType>;
/**
  Indicates whether a field contains or has a recommended value
*/
export declare type RecommendationState = AnnotationTerm<PropertyAnnotationValue<RecommendationStateType>>;
/**
  Indicates whether a field contains or has a recommended value
*/
export declare type RecommendationStateType = Edm.Byte;
/**
  Specifies how to get a list of recommended values for a property or parameter
*/
export declare type RecommendationList = AnnotationTerm<RecommendationListTypeTypes>;
/**
  Reference to a recommendation list
*/
export declare type RecommendationListType = ComplexType & {
    $Type: UIAnnotationTypes.RecommendationListType;
    /**
        Resource path of a collection of recommended values
    */
    CollectionPath: PropertyAnnotationValue<Edm.String>;
    /**
        Name of the property within the collection of recommended values that describes the rank of the recommendation
    */
    RankProperty: PropertyAnnotationValue<Edm.String>;
    /**
        List of pairs of a local property and recommended value property
    */
    Binding: AnnotationTerm<RecommendationBindingTypes[]>;
};
export declare type RecommendationBinding = ComplexType & {
    $Type: UIAnnotationTypes.RecommendationBinding;
    /**
        Path to editable property for which recommended values exist
    */
    LocalDataProperty: PropertyAnnotationValue<Edm.PropertyPath>;
    /**
        Path to property in the collection of recommended values. Format is identical to PropertyPath annotations.
    */
    ValueListProperty: PropertyAnnotationValue<Edm.String>;
};
/**
  The contents of this property must not be propagated to the app-to-app navigation context
*/
export declare type ExcludeFromNavigationContext = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
export declare const enum UIAnnotationTerms {
    HeaderInfo = "com.sap.vocabularies.UI.v1.HeaderInfo",
    Identification = "com.sap.vocabularies.UI.v1.Identification",
    Badge = "com.sap.vocabularies.UI.v1.Badge",
    LineItem = "com.sap.vocabularies.UI.v1.LineItem",
    StatusInfo = "com.sap.vocabularies.UI.v1.StatusInfo",
    FieldGroup = "com.sap.vocabularies.UI.v1.FieldGroup",
    ConnectedFields = "com.sap.vocabularies.UI.v1.ConnectedFields",
    GeoLocations = "com.sap.vocabularies.UI.v1.GeoLocations",
    GeoLocation = "com.sap.vocabularies.UI.v1.GeoLocation",
    Contacts = "com.sap.vocabularies.UI.v1.Contacts",
    MediaResource = "com.sap.vocabularies.UI.v1.MediaResource",
    DataPoint = "com.sap.vocabularies.UI.v1.DataPoint",
    KPI = "com.sap.vocabularies.UI.v1.KPI",
    Chart = "com.sap.vocabularies.UI.v1.Chart",
    ValueCriticality = "com.sap.vocabularies.UI.v1.ValueCriticality",
    CriticalityLabels = "com.sap.vocabularies.UI.v1.CriticalityLabels",
    SelectionFields = "com.sap.vocabularies.UI.v1.SelectionFields",
    Facets = "com.sap.vocabularies.UI.v1.Facets",
    HeaderFacets = "com.sap.vocabularies.UI.v1.HeaderFacets",
    QuickViewFacets = "com.sap.vocabularies.UI.v1.QuickViewFacets",
    QuickCreateFacets = "com.sap.vocabularies.UI.v1.QuickCreateFacets",
    FilterFacets = "com.sap.vocabularies.UI.v1.FilterFacets",
    SelectionPresentationVariant = "com.sap.vocabularies.UI.v1.SelectionPresentationVariant",
    PresentationVariant = "com.sap.vocabularies.UI.v1.PresentationVariant",
    SelectionVariant = "com.sap.vocabularies.UI.v1.SelectionVariant",
    ThingPerspective = "com.sap.vocabularies.UI.v1.ThingPerspective",
    IsSummary = "com.sap.vocabularies.UI.v1.IsSummary",
    PartOfPreview = "com.sap.vocabularies.UI.v1.PartOfPreview",
    Map = "com.sap.vocabularies.UI.v1.Map",
    Gallery = "com.sap.vocabularies.UI.v1.Gallery",
    IsImageURL = "com.sap.vocabularies.UI.v1.IsImageURL",
    IsImage = "com.sap.vocabularies.UI.v1.IsImage",
    MultiLineText = "com.sap.vocabularies.UI.v1.MultiLineText",
    Placeholder = "com.sap.vocabularies.UI.v1.Placeholder",
    TextArrangement = "com.sap.vocabularies.UI.v1.TextArrangement",
    Importance = "com.sap.vocabularies.UI.v1.Importance",
    Hidden = "com.sap.vocabularies.UI.v1.Hidden",
    CreateHidden = "com.sap.vocabularies.UI.v1.CreateHidden",
    UpdateHidden = "com.sap.vocabularies.UI.v1.UpdateHidden",
    DeleteHidden = "com.sap.vocabularies.UI.v1.DeleteHidden",
    HiddenFilter = "com.sap.vocabularies.UI.v1.HiddenFilter",
    DataFieldDefault = "com.sap.vocabularies.UI.v1.DataFieldDefault",
    Criticality = "com.sap.vocabularies.UI.v1.Criticality",
    CriticalityCalculation = "com.sap.vocabularies.UI.v1.CriticalityCalculation",
    OrderBy = "com.sap.vocabularies.UI.v1.OrderBy",
    ParameterDefaultValue = "com.sap.vocabularies.UI.v1.ParameterDefaultValue",
    RecommendationState = "com.sap.vocabularies.UI.v1.RecommendationState",
    RecommendationList = "com.sap.vocabularies.UI.v1.RecommendationList",
    ExcludeFromNavigationContext = "com.sap.vocabularies.UI.v1.ExcludeFromNavigationContext"
}
export declare const enum UIAnnotationTypes {
    HeaderInfoType = "com.sap.vocabularies.UI.v1.HeaderInfoType",
    BadgeType = "com.sap.vocabularies.UI.v1.BadgeType",
    FieldGroupType = "com.sap.vocabularies.UI.v1.FieldGroupType",
    ConnectedFieldsType = "com.sap.vocabularies.UI.v1.ConnectedFieldsType",
    GeoLocationType = "com.sap.vocabularies.UI.v1.GeoLocationType",
    MediaResourceType = "com.sap.vocabularies.UI.v1.MediaResourceType",
    ImageType = "com.sap.vocabularies.UI.v1.ImageType",
    DataPointType = "com.sap.vocabularies.UI.v1.DataPointType",
    NumberFormat = "com.sap.vocabularies.UI.v1.NumberFormat",
    ReferencePeriod = "com.sap.vocabularies.UI.v1.ReferencePeriod",
    CriticalityCalculationType = "com.sap.vocabularies.UI.v1.CriticalityCalculationType",
    CriticalityThresholdsType = "com.sap.vocabularies.UI.v1.CriticalityThresholdsType",
    LevelThresholdsType = "com.sap.vocabularies.UI.v1.LevelThresholdsType",
    TrendCalculationType = "com.sap.vocabularies.UI.v1.TrendCalculationType",
    KPIType = "com.sap.vocabularies.UI.v1.KPIType",
    KPIDetailType = "com.sap.vocabularies.UI.v1.KPIDetailType",
    ChartDefinitionType = "com.sap.vocabularies.UI.v1.ChartDefinitionType",
    ChartAxisScalingType = "com.sap.vocabularies.UI.v1.ChartAxisScalingType",
    ChartAxisAutoScaleBehaviorType = "com.sap.vocabularies.UI.v1.ChartAxisAutoScaleBehaviorType",
    FixedScaleMultipleStackedMeasuresBoundaryValuesType = "com.sap.vocabularies.UI.v1.FixedScaleMultipleStackedMeasuresBoundaryValuesType",
    ChartDimensionAttributeType = "com.sap.vocabularies.UI.v1.ChartDimensionAttributeType",
    ChartMeasureAttributeType = "com.sap.vocabularies.UI.v1.ChartMeasureAttributeType",
    EmphasisLabelType = "com.sap.vocabularies.UI.v1.EmphasisLabelType",
    ValueCriticalityType = "com.sap.vocabularies.UI.v1.ValueCriticalityType",
    CriticalityLabelType = "com.sap.vocabularies.UI.v1.CriticalityLabelType",
    Facet = "com.sap.vocabularies.UI.v1.Facet",
    CollectionFacet = "com.sap.vocabularies.UI.v1.CollectionFacet",
    ReferenceFacet = "com.sap.vocabularies.UI.v1.ReferenceFacet",
    ReferenceURLFacet = "com.sap.vocabularies.UI.v1.ReferenceURLFacet",
    SelectionPresentationVariantType = "com.sap.vocabularies.UI.v1.SelectionPresentationVariantType",
    PresentationVariantType = "com.sap.vocabularies.UI.v1.PresentationVariantType",
    SelectionVariantType = "com.sap.vocabularies.UI.v1.SelectionVariantType",
    ParameterAbstract = "com.sap.vocabularies.UI.v1.ParameterAbstract",
    Parameter = "com.sap.vocabularies.UI.v1.Parameter",
    IntervalParameter = "com.sap.vocabularies.UI.v1.IntervalParameter",
    SelectOptionType = "com.sap.vocabularies.UI.v1.SelectOptionType",
    SelectionRangeType = "com.sap.vocabularies.UI.v1.SelectionRangeType",
    DataFieldAbstract = "com.sap.vocabularies.UI.v1.DataFieldAbstract",
    DataFieldForAnnotation = "com.sap.vocabularies.UI.v1.DataFieldForAnnotation",
    DataFieldForActionAbstract = "com.sap.vocabularies.UI.v1.DataFieldForActionAbstract",
    DataFieldForAction = "com.sap.vocabularies.UI.v1.DataFieldForAction",
    DataFieldForIntentBasedNavigation = "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation",
    DataField = "com.sap.vocabularies.UI.v1.DataField",
    DataFieldWithAction = "com.sap.vocabularies.UI.v1.DataFieldWithAction",
    DataFieldWithIntentBasedNavigation = "com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation",
    DataFieldWithNavigationPath = "com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath",
    DataFieldWithUrl = "com.sap.vocabularies.UI.v1.DataFieldWithUrl",
    RecommendationListType = "com.sap.vocabularies.UI.v1.RecommendationListType",
    RecommendationBinding = "com.sap.vocabularies.UI.v1.RecommendationBinding"
}
export declare type HeaderInfoTypeTypes = AnnotationTerm<HeaderInfoType>;
export declare type BadgeTypeTypes = AnnotationTerm<BadgeType>;
export declare type FieldGroupTypeTypes = AnnotationTerm<FieldGroupType>;
export declare type ConnectedFieldsTypeTypes = AnnotationTerm<ConnectedFieldsType>;
export declare type GeoLocationTypeTypes = AnnotationTerm<GeoLocationType>;
export declare type MediaResourceTypeTypes = AnnotationTerm<MediaResourceType>;
export declare type ImageTypeTypes = AnnotationTerm<ImageType>;
export declare type DataPointTypeTypes = AnnotationTerm<DataPointType>;
export declare type NumberFormatTypes = AnnotationTerm<NumberFormat>;
export declare type ReferencePeriodTypes = AnnotationTerm<ReferencePeriod>;
export declare type CriticalityCalculationTypeTypes = AnnotationTerm<CriticalityCalculationType>;
export declare type CriticalityThresholdsTypeTypes = AnnotationTerm<CriticalityThresholdsType | CriticalityCalculationTypeTypes | LevelThresholdsTypeTypes>;
export declare type LevelThresholdsTypeTypes = AnnotationTerm<LevelThresholdsType>;
export declare type TrendCalculationTypeTypes = AnnotationTerm<TrendCalculationType>;
export declare type KPITypeTypes = AnnotationTerm<KPIType>;
export declare type KPIDetailTypeTypes = AnnotationTerm<KPIDetailType>;
export declare type ChartDefinitionTypeTypes = AnnotationTerm<ChartDefinitionType>;
export declare type ChartAxisScalingTypeTypes = AnnotationTerm<ChartAxisScalingType>;
export declare type ChartAxisAutoScaleBehaviorTypeTypes = AnnotationTerm<ChartAxisAutoScaleBehaviorType>;
export declare type FixedScaleMultipleStackedMeasuresBoundaryValuesTypeTypes = AnnotationTerm<FixedScaleMultipleStackedMeasuresBoundaryValuesType>;
export declare type ChartDimensionAttributeTypeTypes = AnnotationTerm<ChartDimensionAttributeType>;
export declare type ChartMeasureAttributeTypeTypes = AnnotationTerm<ChartMeasureAttributeType>;
export declare type EmphasisLabelTypeTypes = AnnotationTerm<EmphasisLabelType>;
export declare type ValueCriticalityTypeTypes = AnnotationTerm<ValueCriticalityType>;
export declare type CriticalityLabelTypeTypes = AnnotationTerm<CriticalityLabelType>;
export declare type FacetTypes = AnnotationTerm<CollectionFacetTypes | ReferenceFacetTypes | ReferenceURLFacetTypes>;
export declare type CollectionFacetTypes = AnnotationTerm<CollectionFacet>;
export declare type ReferenceFacetTypes = AnnotationTerm<ReferenceFacet>;
export declare type ReferenceURLFacetTypes = AnnotationTerm<ReferenceURLFacet>;
export declare type SelectionPresentationVariantTypeTypes = AnnotationTerm<SelectionPresentationVariantType>;
export declare type PresentationVariantTypeTypes = AnnotationTerm<PresentationVariantType>;
export declare type SelectionVariantTypeTypes = AnnotationTerm<SelectionVariantType>;
export declare type ParameterAbstractTypes = AnnotationTerm<ParameterTypes | IntervalParameterTypes>;
export declare type ParameterTypes = AnnotationTerm<Parameter>;
export declare type IntervalParameterTypes = AnnotationTerm<IntervalParameter>;
export declare type SelectOptionTypeTypes = AnnotationTerm<SelectOptionType>;
export declare type SelectionRangeTypeTypes = AnnotationTerm<SelectionRangeType>;
export declare type DataFieldAbstractTypes = AnnotationTerm<DataFieldForAnnotationTypes | DataFieldForActionAbstractTypes | DataFieldTypes>;
export declare type DataFieldForAnnotationTypes = AnnotationTerm<DataFieldForAnnotation>;
export declare type DataFieldForActionAbstractTypes = AnnotationTerm<DataFieldForActionTypes | DataFieldForIntentBasedNavigationTypes>;
export declare type DataFieldForActionTypes = AnnotationTerm<DataFieldForAction>;
export declare type DataFieldForIntentBasedNavigationTypes = AnnotationTerm<DataFieldForIntentBasedNavigation>;
export declare type DataFieldTypes = AnnotationTerm<DataField | DataFieldWithActionTypes | DataFieldWithIntentBasedNavigationTypes | DataFieldWithNavigationPathTypes | DataFieldWithUrlTypes>;
export declare type DataFieldWithActionTypes = AnnotationTerm<DataFieldWithAction>;
export declare type DataFieldWithIntentBasedNavigationTypes = AnnotationTerm<DataFieldWithIntentBasedNavigation>;
export declare type DataFieldWithNavigationPathTypes = AnnotationTerm<DataFieldWithNavigationPath>;
export declare type DataFieldWithUrlTypes = AnnotationTerm<DataFieldWithUrl>;
export declare type RecommendationListTypeTypes = AnnotationTerm<RecommendationListType>;
export declare type RecommendationBindingTypes = AnnotationTerm<RecommendationBinding>;
