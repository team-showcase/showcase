"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pages_1 = require("./pages");
const decorators_1 = require("../../common/decoration/decorators");
const controls_1 = require("./controls");
const AnalyticalListPageChart_1 = require("../../../sync/v2/export/controls/AnalyticalListPageChart");
const v2_1 = require("../../../v2");
const application_1 = require("../application");
const manifest_1 = require("./manifest");
const utils_1 = require("../import/utils");
const Card_1 = require("../../../specification/v2/controls/Card");
const common_1 = require("../../common");
const common_2 = require("../../../specification/common");
const ObjectPageHeaderAction_1 = require("../../../sync/v2/export/controls/ObjectPageHeaderAction");
/**
 * Returns a fresh export results object with default values
 */
const getDefaultExportResult = () => ({
    flexChanges: [],
    manifest: {
        'sap.ui.generic.app': { pages: {} }
    }
});
/**
 * Create missing card from the manifest
 * @param key - card name
 * @param ovp - OVP section of manifest, to be updated
 */
function createCard(key, ovp) {
    if (!ovp.cards) {
        ovp.cards = {};
    }
    if (!(key in ovp.cards)) {
        ovp.cards[key] = {};
    }
}
/**
 * Recursive function that searches for next avaialble id by increasing number by 1.
 * @param {boolean} sectionIds All ids in use.
 * @param {string} candidateId Candidate id to check if it is available.
 * @return {string} Id string.
 */
function findAvailableId(sectionIds, candidateId) {
    if (sectionIds.includes(candidateId)) {
        const idParts = candidateId.split('|');
        if (idParts.length === 3) {
            idParts.push('1');
        }
        else {
            idParts[3] = (parseInt(idParts[3]) + 1).toString();
        }
        return findAvailableId(sectionIds, idParts.join('|'));
    }
    return candidateId;
}
/**
 * Private recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param configObject - current object to traverse
 * @param manifest - app descriptor (manifest.json)
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param jsonSchema - application specific schema
 * @param targetDefinition - the current entry point or definition in the app schema
 * @param pathHierarchy -  elements of the path indicating the hierarchical level
 */
function transferManifestEntriesOVP(configObject, manifest, exportResults, jsonSchema, targetDefinition, pathHierarchy) {
    if (targetDefinition) {
        if (targetDefinition['properties']) {
            processProperties(configObject, manifest, exportResults, jsonSchema, targetDefinition['properties'], pathHierarchy);
        }
        else if (targetDefinition['additionalProperties']) {
            processProperties(configObject, manifest, exportResults, jsonSchema, targetDefinition['additionalProperties'], pathHierarchy);
        }
    }
}
/**
 * Recursive function that transfers the content of a list of properties of a configuration to the overall exportResults
 * @param configObject - the given part of the configuration
 * @param manifest - manifest.json of the app
 * @param exportResults - overall result list, to be updated
 * @param jsonSchema - app-specific JSOn schema
 * @param propertyList - current property list of the config (properties or additional properties)
 * @param pathHierarchy -  elements of the path indicating the hierarchical level
 */
function processProperties(configObject, manifest, exportResults, jsonSchema, propertyList, pathHierarchy) {
    let currentObject;
    for (const key in propertyList) {
        currentObject = configObject[key];
        const exportPropertyRule = decorators_1.getReflectMetadata(configObject, key);
        if (exportPropertyRule) {
            if (exportPropertyRule.manifest) {
                const path = exportPropertyRule.manifest.path([...pathHierarchy, key]);
                const manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
                if (key in v2_1.CardSettingsType) {
                    manifestSection['settings'] = currentObject ? currentObject : {};
                }
                else {
                    if (currentObject !== undefined) {
                        manifestSection[key] = currentObject;
                    }
                    else if (manifestSection[key]) {
                        delete manifestSection[key];
                    }
                }
            }
        }
        if (currentObject && typeof currentObject === 'object' && propertyList[key]) {
            if (key === 'cards') {
                //inserts and updates:
                Object.keys(currentObject).forEach((newKey) => {
                    const cardType = currentObject[newKey].template;
                    switch (cardType) {
                        case Card_1.CardTemplateType.list:
                            currentObject[newKey] = Object.assign(new controls_1.ListCard(), currentObject[newKey]);
                            break;
                        case Card_1.CardTemplateType.stack:
                            currentObject[newKey] = Object.assign(new controls_1.StackCard(), currentObject[newKey]);
                            break;
                        case Card_1.CardTemplateType.linklist:
                            currentObject[newKey] = Object.assign(new controls_1.LinklistCard(), currentObject[newKey]);
                            break;
                        case Card_1.CardTemplateType.table:
                            currentObject[newKey] = Object.assign(new controls_1.TableCard(), currentObject[newKey]);
                            break;
                        case Card_1.CardTemplateType.analytical:
                            currentObject[newKey] = Object.assign(new controls_1.AnalyticalCard(), currentObject[newKey]);
                            break;
                        default:
                            currentObject[newKey] = Object.assign(new controls_1.CustomCard(), currentObject[newKey]);
                            break;
                    }
                    createCard(newKey, exportResults['manifest']['sap.ovp']);
                    let targetDefinition;
                    if (!Object.values(Card_1.CardTemplateType).includes(cardType)) {
                        targetDefinition = ['CustomCard'];
                    }
                    else {
                        targetDefinition = Object.keys(jsonSchema['definitions']).filter((definition) => jsonSchema['definitions'][definition].properties &&
                            jsonSchema['definitions'][definition].properties.template &&
                            jsonSchema['definitions'][definition].properties.template.enum &&
                            jsonSchema['definitions'][definition].properties.template.enum[0] ===
                                currentObject[newKey].template);
                    }
                    transferManifestEntriesOVP(currentObject[newKey], manifest, exportResults, jsonSchema, jsonSchema['definitions'][targetDefinition[0]], [newKey]);
                });
                //check for deletions:
                Object.keys(manifest['sap.ovp'].cards).forEach((manifestCard) => {
                    if (!currentObject[manifestCard]) {
                        delete exportResults.manifest['sap.ovp'].cards[manifestCard];
                    }
                });
            }
            else if (propertyList[key].$ref) {
                const definitionArray = propertyList[key].$ref.split('#/definitions/');
                const nextTargetDefinition = jsonSchema['definitions'][definitionArray[definitionArray.length - 1]];
                const cardSettingsType = key;
                switch (cardSettingsType) {
                    case v2_1.CardSettingsType.listCardSettings:
                        currentObject = Object.assign(new controls_1.ListCard(), currentObject);
                        break;
                    case v2_1.CardSettingsType.stackCardSettings:
                        currentObject = Object.assign(new controls_1.StackCard(), currentObject);
                        break;
                    case v2_1.CardSettingsType.linkListCardSettings:
                        currentObject = Object.assign(new controls_1.LinklistCard(), currentObject);
                        break;
                    case v2_1.CardSettingsType.tableCardSettings:
                        currentObject = Object.assign(new controls_1.TableCard(), currentObject);
                        break;
                    case v2_1.CardSettingsType.analyticalCardSettings:
                        currentObject = Object.assign(new controls_1.AnalyticalCard(), currentObject);
                        break;
                    default:
                        currentObject = Object.assign(new controls_1.CustomCard(), currentObject);
                        break;
                }
                transferManifestEntriesOVP(currentObject, manifest, exportResults, jsonSchema, nextTargetDefinition, [
                    ...pathHierarchy,
                    key
                ]);
            }
            else if (propertyList[key].anyOf) {
                processProperties(configObject, manifest, exportResults, jsonSchema, propertyList[key].anyOf, pathHierarchy);
            }
        }
    }
}
/**
 * Evaluates an export rule for a property or object, transfers to flex change or manifest setting
 * @param exportPropertyRule - export rule from the object classes decorator
 * @param configObject - current (sub)object of the configuration file
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param baseId - selector id of the current page
 * @param ids - list of parent & child ids
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param key - key of the given property
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param fullManifest - old or existing manifest
 * @param pageKeys - array of keys to identify component in manifest
 * @param manifestSection - current manifest section
 */
function evaluateExportRule(exportPropertyRule, configObject, breadcrumbs, baseId, ids, title, key, exportResults, fullManifest, pageKeys, manifestSection, ui5Version) {
    let localBreadcrumbs;
    //eliminate subsections' hierarchy
    let index = breadcrumbs.indexOf('subsections');
    while (index > -1) {
        breadcrumbs.splice(index - 1, 2);
        index = breadcrumbs.indexOf('subsections');
    }
    if (exportPropertyRule.flex) {
        if (configObject !== undefined) {
            if (breadcrumbs.length === 0) {
                //only added on top = page level, do not forward
                localBreadcrumbs = ['page'];
            }
            else {
                localBreadcrumbs = breadcrumbs;
            }
            const flexChange = {
                controlId: exportPropertyRule.flex.controlId(baseId, ids, localBreadcrumbs, exportPropertyRule.flex.controlType, title),
                controlType: exportPropertyRule.flex.controlType(),
                content: {
                    property: key
                },
                sapui5Version: ui5Version
            };
            if (configObject.toString().startsWith('{')) {
                flexChange.content.newBinding = configObject;
                flexChange.type = 'propertyBindingChange';
            }
            else {
                flexChange.content.newValue = configObject;
            }
            exportResults.flexChanges.push(exportPropertyRule.flex.exportFunction(flexChange, fullManifest));
        }
    }
    else if (exportPropertyRule.manifest) {
        let path;
        if (breadcrumbs[0] === 'sections') {
            if (breadcrumbs[1] === 'custom') {
                path = exportPropertyRule.manifest.path(pageKeys, breadcrumbs[2]);
            }
            else {
                path = exportPropertyRule.manifest.path(pageKeys, breadcrumbs[1]);
                path = path.replace('/@', '::').replace(/::@com.sap.vocabularies/g, '::com.sap.vocabularies');
            }
        }
        else {
            path = exportPropertyRule.manifest.path(pageKeys);
        }
        manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
        const manifestKey = exportPropertyRule.manifest.key || key;
        if (configObject !== undefined) {
            const exportHandler = exportPropertyRule.manifest.export;
            if (exportHandler !== false) {
                if (exportHandler && typeof exportHandler === 'function') {
                    exportHandler(manifestSection, configObject);
                }
                else {
                    manifestSection[manifestKey] = configObject;
                }
            }
        }
        else {
            if (Object.prototype.hasOwnProperty.call(manifestSection, manifestKey)) {
                delete manifestSection[manifestKey];
            }
        }
        common_1.deleteEmptyStructure(exportResults.manifest, path);
    }
}
/**
 * Instantiates the export classes for the object page section
 * @param objectPageConfig - the given object page configuration
 * @param objectPage - the overall object page export class where the sections shall be included
 */
function getExportClassesForSections(objectPageConfig, objectPage, v2Page) {
    /**
     * Instantiates the export classes for a single object page section
     * @param section - Export class as an object, to be updated
     * @param sectionId - Current section ID
     */
    function getClassesForSingleSection(section, sectionId, sectionInManifest) {
        let tableType = v2_1.TableTypeV2.ResponsiveTable;
        if (section) {
            if (section['chart'] || sectionId.includes('com.sap.vocabularies.UI.v1.Chart')) {
                section['chart'] = Object.assign(new controls_1.ObjectPageChart(), section['chart']);
                return;
            }
            if (section['table']) {
                //listed in config
                tableType = section['table'].type;
            }
            else if (sectionInManifest) {
                //only listed in manifest, deleted from config
                tableType = sectionInManifest['tableSettings'].type;
            }
            switch (tableType) {
                case v2_1.TableTypeV2.AnalyticalTable:
                    section['table'] = Object.assign(new controls_1.ObjectPageAnalyticalTable(), section['table']);
                    break;
                case v2_1.TableTypeV2.GridTable:
                    section['table'] = Object.assign(new controls_1.ObjectPageGridTable(), section['table']);
                    break;
                case v2_1.TableTypeV2.TreeTable:
                    section['table'] = Object.assign(new controls_1.ObjectPageTreeTable(), section['table']);
                    break;
                default:
                case v2_1.TableTypeV2.ResponsiveTable:
                    section['table'] = Object.assign(new controls_1.ObjectPageResponsiveTable(), section['table']);
                    break;
            }
            if (section['table'].columns) {
                for (const columnId in section['table'].columns) {
                    section['table'].columns[columnId] = Object.assign(new controls_1.TableColumn(), section['table'].columns[columnId]);
                }
            }
            // custom section
            if (sectionId === 'custom' && Array.isArray(section)) {
                // Custom sections
                for (const index in section) {
                    section[index] = Object.assign(section[index].className === v2_1.SAPUI5_FRAGMENT_CLASS
                        ? new controls_1.ObjectPageCustomSectionFragment()
                        : new controls_1.ObjectPageCustomSectionView(), section[index]);
                }
            }
        }
    }
    /**
     * Recursive sub-function for handling subsections
     * @param section - Object page section in config
     */
    function getSubsectionClasses(section) {
        if (section['subsections']) {
            let subSection, sectionInManifest;
            for (const subSectionId in section['subsections']) {
                subSection = section['subsections'][subSectionId];
                sectionInManifest =
                    v2Page.component.settings &&
                        v2Page.component.settings.sections &&
                        v2Page.component.settings.sections[subSectionId];
                getClassesForSingleSection(subSection, subSectionId, sectionInManifest);
                getSubsectionClasses(subSection);
            }
        }
    }
    // Main function
    let section, sectionInManifest;
    for (const sectionId in objectPageConfig.sections) {
        section = objectPage.sections[sectionId];
        sectionInManifest =
            v2Page.component.settings &&
                v2Page.component.settings.sections &&
                v2Page.component.settings.sections[sectionId];
        getClassesForSingleSection(section, sectionId, sectionInManifest);
        getSubsectionClasses(section);
    }
}
/**
 * Recursive function to determine the next config part, next definition in the app schema and the title
 * @param definitionArray - array comprising split parts of the previous definition
 * @param appSchema - app schema
 * @param title - defualt title
 * @param currentConfigObject - current part of the configuration that gets traversed
 * @param propertyDefinition - definition of a given property in the app schema
 * @param key - actual key
 */
function getNextTargetDefinition(definitionArray, appSchema, title, currentConfigObject, propertyDefinition, key) {
    let nextDefinition = {
        configObject: {},
        targetDefinition: {},
        title: ''
    };
    if (definitionArray.length) {
        nextDefinition.targetDefinition = appSchema['definitions'][definitionArray[definitionArray.length - 1]];
        if (nextDefinition.targetDefinition['$ref']) {
            definitionArray = nextDefinition.targetDefinition['$ref'].split('#/definitions/');
            nextDefinition = getNextTargetDefinition(definitionArray, appSchema, title, currentConfigObject, propertyDefinition, key);
            return nextDefinition;
        }
        else if (propertyDefinition['anyOf']) {
            propertyDefinition['anyOf'].forEach((element) => {
                if (element.$ref.includes(currentConfigObject.constructor.name)) {
                    definitionArray.push(...element.$ref.split('#/definitions/'));
                }
            });
            if (definitionArray.length === 0) {
                definitionArray = propertyDefinition['anyOf'][0].$ref.split('#/definitions/');
            }
        }
        if (definitionArray.length > 2) {
            definitionArray.forEach((element) => {
                if (element != '') {
                    nextDefinition.targetDefinition['properties'] = Object.assign(Object.assign({}, nextDefinition.targetDefinition['properties']), appSchema['definitions'][element]['properties']);
                }
            });
        }
        nextDefinition.title =
            nextDefinition.targetDefinition && nextDefinition.targetDefinition['title']
                ? nextDefinition.targetDefinition['title']
                : title;
        nextDefinition.configObject = currentConfigObject;
    }
    else {
        //e.g. sections ==> loop over all properties = subsections or other
        nextDefinition.targetDefinition = propertyDefinition;
        nextDefinition.title = nextDefinition.targetDefinition['title']
            ? nextDefinition.targetDefinition['title']
            : key;
        nextDefinition.configObject = currentConfigObject;
    }
    return nextDefinition;
}
/**
 * Recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param configSections - sections from configuration object
 * @param pageKey  - page key
 * @param fullManifest - full manifest object
 * @param parentIds - array of collected parent ids
 * @param manifest - app descriptor (manifest.json)
 * @param breadcrumbs - array of properties that we are currently processing. Required for instance for table column name
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param baseId - selector id of the current page
 * @param pageKeys - array of keys to identify component in manifest
 * @param jsonSchema - application specific schema
 * @param targetDefinition - the current entry point or definition in the app schema
 * @param entityAnnotations - list of annotations of the entity type that the page is referring to
 */
function transferManifestExtensions(configSections, pageKey, fullManifest, parentIds, manifest, breadcrumbs, exportResults, appId, baseId, pageKeys, jsonSchema, targetDefinition, ui5Version) {
    const sectionIds = [];
    const entity = pageKey.split('|')[1];
    for (const section of configSections) {
        const id = findAvailableId(sectionIds, [section.relativePosition, entity, section.relatedFacet].join('|'));
        sectionIds.push(id);
    }
    for (const index in sectionIds) {
        const definition = targetDefinition['anyOf'].find((element) => element.$ref.includes(configSections[index].constructor.name));
        const definitionArray = definition.$ref.split('#/definitions/');
        const nextTargetDefinition = jsonSchema['definitions'][definitionArray[definitionArray.length - 1]];
        transferManifestEntriesAndFlexChange(fullManifest, configSections[index], parentIds, manifest, [...breadcrumbs, sectionIds[index]], exportResults, appId, baseId, pageKeys, jsonSchema, nextTargetDefinition, ui5Version);
    }
    // Delete removed manifest entries
    const manifestSections = manifest_1.getManifestSectionByPathV2(exportResults.manifest, application_1.getViewExtensionsPath());
    for (const key in manifestSections) {
        if (!sectionIds.includes(key)) {
            delete manifestSections[key];
        }
    }
}
/**
 * Recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param configObject - current (sub)object of the configuration file
 * @param parentIds - array of collected parent ids
 * @param manifest - app descriptor (manifest.json)
 * @param breadcrumbs - array of properties that we are currently processing. Required for instance for table column name
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param baseId - selector id of the current page
 * @param pageKeys - array of keys to identify component in manifest
 * @param jsonSchema - application specific schema
 * @param schemaDefinition - the current entry point or definition in the app schema
 * @param title - title from the app schema (comprising for instance the facet ID)
 */
function transferManifestEntriesAndFlexChange(fullManifest, configObject, parentIds, manifest, breadcrumbs, exportResults, appId, baseId, pageKeys, jsonSchema, schemaDefinition, ui5Version, title) {
    let manifestSection, currentConfigObject;
    if (schemaDefinition && schemaDefinition['properties']) {
        for (const key in schemaDefinition['properties']) {
            currentConfigObject = configObject[key];
            const childId = decorators_1.getChildId(configObject, key);
            const ids = childId ? [...parentIds, childId] : parentIds;
            const exportPropertyRule = decorators_1.getReflectMetadata(configObject, key);
            if (exportPropertyRule) {
                evaluateExportRule(exportPropertyRule, currentConfigObject, breadcrumbs, baseId, ids, title, key, exportResults, fullManifest, pageKeys, manifestSection, ui5Version);
                continue;
            }
            const propertyDefinition = schemaDefinition['properties'][key];
            if (typeof currentConfigObject === 'object' && propertyDefinition) {
                let definitionArray = [];
                if (propertyDefinition.$ref) {
                    definitionArray = propertyDefinition.$ref.split('#/definitions/');
                }
                else if (propertyDefinition['anyOf']) {
                    propertyDefinition['anyOf'].forEach((element) => {
                        if (element.$ref.includes(currentConfigObject.constructor.name)) {
                            definitionArray.push(...element.$ref.split('#/definitions/'));
                        }
                    });
                    if (definitionArray.length === 0) {
                        definitionArray = propertyDefinition['anyOf'][0].$ref.split('#/definitions/');
                    }
                }
                else if (propertyDefinition.type === 'array' &&
                    (breadcrumbs[0] === 'sections' || breadcrumbs[0] === 'subsections') &&
                    key === 'custom') {
                    transferManifestExtensions(configObject[key], pageKeys[pageKeys.length - 1], fullManifest, ids, manifest, [...breadcrumbs, key], exportResults, appId, baseId, pageKeys, jsonSchema, propertyDefinition.items, ui5Version);
                    continue;
                }
                const nextDefinition = getNextTargetDefinition(definitionArray, jsonSchema, title, currentConfigObject, propertyDefinition, key);
                transferManifestEntriesAndFlexChange(fullManifest, nextDefinition.configObject, ids, manifest, [...breadcrumbs, key], exportResults, appId, baseId, pageKeys, jsonSchema, nextDefinition.targetDefinition, ui5Version, nextDefinition.title);
            }
        }
    }
}
/**
 * Run through the given ListReport config and return respective manifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param listReportConfig - content of the src/ListReport_<entity_set>.json file
 * @param entitySet - name of the entity set
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
const exportListReportPage = (appId, listReportConfig, entitySet, manifest, jsonSchema, ui5Version) => {
    const exportResults = getDefaultExportResult();
    exportResults.flexChanges = [];
    // when assigning a JSON structure to an object structure we need to assign all children, otherwise decorators will not exist
    const listReport = Object.assign(new pages_1.ListReport(), listReportConfig);
    if (!listReport.table) {
        listReport.table = Object.assign(new controls_1.ResponsiveTable(), listReport.table);
    }
    if (listReport.table) {
        switch (listReport.table.type) {
            case v2_1.TableTypeV2.ResponsiveTable:
                listReport.table = Object.assign(new controls_1.ResponsiveTable(), listReport.table);
                break;
            case v2_1.TableTypeV2.TreeTable:
                listReport.table = Object.assign(new controls_1.TreeTable(), listReport.table);
                break;
            case v2_1.TableTypeV2.AnalyticalTable:
                listReport.table = Object.assign(new controls_1.AnalyticalTable(), listReport.table);
                break;
            case v2_1.TableTypeV2.GridTable:
                listReport.table = Object.assign(new controls_1.GridTable(), listReport.table);
                break;
            default:
                listReport.table = Object.assign(new controls_1.ResponsiveTable(), listReport.table);
                break;
        }
        if (listReport.table.columns) {
            const complexIdMatch = new RegExp('DataField.+:::sSmartTableId::listReport.+');
            for (let columnId in listReport.table.columns) {
                if (complexIdMatch.exec(columnId) !== null) {
                    //This part was stripped off during import (table.ts)
                    columnId = 'template:::TableColumn:::' + columnId;
                }
                listReport.table.columns[columnId] = Object.assign(new controls_1.TableColumn(), listReport.table.columns[columnId]);
            }
        }
    }
    listReport.filterBar = Object.assign(new controls_1.FilterBar(), listReport.filterBar);
    const pageLayoutInformation = decorators_1.getPageLayoutInformation(listReport);
    const baseId = `${appId}::${pageLayoutInformation.id}::${entitySet}--`;
    const pageKeys = [];
    const v2Page = utils_1.findListReportPage(manifest['sap.ui.generic.app'].pages, pageKeys);
    if (!v2Page.component.settings) {
        v2Page.component.settings = {};
    }
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    if (listReportConfig && Object.keys(listReportConfig).length !== 0) {
        transferManifestEntriesAndFlexChange(exportResults.manifest, listReport, [], v2Page, [], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema, //starting point for target definition
        ui5Version);
    }
    return exportResults;
};
/**
 * Run through the given AnalyticalListPage config and return respective manifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param analyticalListPageConfig - content of the src/AnalyticalListPage_<entity_set>.json file
 * @param entitySet - name of the entity set
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
const exportAnalyticalListPage = (appId, analyticalListPageConfig, entitySet, manifest, jsonSchema, ui5Version) => {
    const exportResults = getDefaultExportResult();
    exportResults.flexChanges = [];
    const analyticalListPage = Object.assign(new pages_1.AnalyticalListPage(), analyticalListPageConfig);
    const complexIdMatch = new RegExp('DataField.+:::sSmartTableId::analyticalListPage.+');
    // when assigning a JSON structure to an object structure we need to assign all children, otherwise decorators will not exist
    // find a better way to do this generically, perhaps using the schema?
    analyticalListPage.table = Object.assign(new controls_1.AnalyticalTable(), analyticalListPage.table);
    if (analyticalListPage.table && analyticalListPage.table.columns) {
        for (let columnId in analyticalListPage.table.columns) {
            if (complexIdMatch.exec(columnId) !== null) {
                //This part was stripped off during import (table.ts)
                columnId = 'template:::TableColumn:::' + columnId;
            }
            analyticalListPage.table.columns[columnId] = Object.assign(new controls_1.TableColumn(), analyticalListPage.table.columns[columnId]);
        }
    }
    analyticalListPage.filterBar = Object.assign(new controls_1.AnalyticalListPageFilterBar(), analyticalListPage.filterBar);
    const pageLayoutInformation = decorators_1.getPageLayoutInformation(analyticalListPage);
    const baseId = `${appId}::${pageLayoutInformation.id}::${entitySet}--`;
    const pageKeys = [];
    const v2Page = utils_1.findAnalyticalListPage(manifest['sap.ui.generic.app'].pages, pageKeys);
    v2Page.component.settings = {};
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    analyticalListPage.chart = Object.assign(new AnalyticalListPageChart_1.ChartSettings(), analyticalListPage.chart);
    if (analyticalListPageConfig && Object.keys(analyticalListPageConfig).length !== 0) {
        transferManifestEntriesAndFlexChange(exportResults.manifest, analyticalListPage, [], v2Page, [], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema, //starting point for target definition
        ui5Version);
    }
    return exportResults;
};
/**
 * Run through the given ObjectPage config and return respective manifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param objectPageConfig - content of the src/ObjectPage_<entity_set>.json file
 * @param entitySet - name of the entity set
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @param entityAnnotations - list of annotations of the entity type that the page is referring to
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
const exportObjectPage = (appId, objectPageConfig, entitySet, manifest, jsonSchema, ui5Version) => {
    const exportResults = getDefaultExportResult();
    const objectPage = Object.assign(new pages_1.ObjectPage(), objectPageConfig);
    // when assigning a JSON structure to an object structure we need to assign all children, otherwise decorators will not exist
    // find a better way to do this generically, perhaps using the schema?
    if (objectPageConfig) {
        objectPage['header'] = Object.assign(new controls_1.ObjectPageHeader(), objectPage['header']);
        objectPage.header.actions = Object.assign(new controls_1.ObjectPageHeader(), objectPage.header.actions);
        for (const headerId in objectPageConfig.header) {
            if (headerId === 'actions') {
                for (const actionId in objectPageConfig.header.actions) {
                    const action = objectPage.header.actions;
                    action[actionId] = Object.assign(new ObjectPageHeaderAction_1.HeaderAction(), action[actionId]);
                }
            }
        }
        objectPage.layout = Object.assign(new controls_1.ObjectPageLayout(), objectPage.layout);
        const pageLayoutInformation = decorators_1.getPageLayoutInformation(objectPage);
        const baseId = `${appId}::${pageLayoutInformation.id}::${entitySet}--`;
        exportResults.manifest = JSON.parse(JSON.stringify(manifest));
        const pageKeys = [];
        const v2Page = utils_1.findObjectPage(manifest['sap.ui.generic.app'].pages, entitySet, pageKeys);
        if (!v2Page) {
            return exportResults;
        }
        if (!v2Page.component.settings) {
            v2Page.component.settings = {};
        }
        if (objectPageConfig && objectPageConfig.sections) {
            getExportClassesForSections(objectPageConfig, objectPage, v2Page);
        }
        if (objectPageConfig && Object.keys(objectPageConfig).length !== 0) {
            transferManifestEntriesAndFlexChange(exportResults.manifest, objectPage, [], v2Page, [], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema, //starting point for target definition
            ui5Version);
        }
        return exportResults;
    }
    else {
        exportResults.manifest = JSON.parse(JSON.stringify(manifest));
        return exportResults;
    }
};
/**
 * Run through the given ObjectPage config and return respective manifest entry and flex changes
 * @param overviewPageConfig - content of the src/OverviewPage_<entity_set>.json file
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
const exportOverviewPage = (overviewPageConfig, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    const overviewPage = Object.assign(new pages_1.OverviewPage(), overviewPageConfig);
    overviewPage.cards = Object.assign(new controls_1.CustomCard(), overviewPage.cards);
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    if (overviewPageConfig && Object.keys(overviewPageConfig).length !== 0) {
        transferManifestEntriesOVP(overviewPage, exportResults.manifest, exportResults, jsonSchema, jsonSchema, []);
    }
    return exportResults;
};
/**
 * Exports a Fiori Element V2 application.
 * It converts the entries of the input application (config file) to corresponding manifest settings and flex changes
 * @param application - content of the config file of an application
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
const exportApplicationV2 = (application, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    const applicationV2 = Object.assign(new application_1.ApplicationV2(), application);
    //transfer application settings
    applicationV2.settings = Object.assign(new application_1.AppSettings(), application['settings']);
    for (const key in jsonSchema['definitions']['AppSettings']['properties']) {
        const exportPropertyRule = decorators_1.getReflectMetadata(applicationV2.settings, key);
        if (exportPropertyRule && exportPropertyRule.manifest) {
            const path = exportPropertyRule.manifest.path();
            const manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
            if (application['settings'] && application['settings'][key] !== undefined) {
                manifestSection[key] = application['settings'][key];
            }
            else {
                delete manifestSection[key];
            }
        }
    }
    // transfer pages and routings
    const manifestPages = exportResults.manifest['sap.ui.generic.app'] && exportResults.manifest['sap.ui.generic.app'].pages;
    if (manifestPages && application['pages']) {
        manifest_1.transformPageToNewManifestV2(application.home, application['pages'], Object.values(manifestPages)[0]);
    }
    return exportResults;
};
/**
 * Exports a Fiori Element V2 page.
 * It converts the entries of the input page (config file) to corresponding manifest settings and flex changes
 * @param appId - application id
 * @param page - content of the config file of a page
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @param entityAnnotations - list of annotations of the entity type that the page is referring to
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
exports.exportPageV2 = (exportParametersV2, ui5Version) => {
    if (exportParametersV2[common_2.SchemaType.ListReport]) {
        const { appId, page, manifest, jsonSchema } = exportParametersV2[common_2.SchemaType.ListReport];
        return exportListReportPage(appId, page.config, page.entitySet, manifest, jsonSchema, ui5Version);
    }
    else if (exportParametersV2[common_2.SchemaType.ObjectPage]) {
        const { appId, page, manifest, jsonSchema } = exportParametersV2[common_2.SchemaType.ObjectPage];
        return exportObjectPage(appId, page.config, page.entitySet, manifest, jsonSchema, ui5Version);
    }
    else if (exportParametersV2[common_2.SchemaType.OverviewPage]) {
        const { page, manifest, jsonSchema } = exportParametersV2[common_2.SchemaType.OverviewPage];
        return exportOverviewPage(page.config, manifest, jsonSchema);
    }
    else if (exportParametersV2[common_2.SchemaType.Application]) {
        const { application, manifest, jsonSchema } = exportParametersV2[common_2.SchemaType.Application];
        return exportApplicationV2(application, manifest, jsonSchema);
    }
    else if (exportParametersV2[common_2.SchemaType.AnalyticalListPage]) {
        const { appId, page, manifest, jsonSchema } = exportParametersV2[common_2.SchemaType.AnalyticalListPage];
        return exportAnalyticalListPage(appId, page.config, page.entitySet, manifest, jsonSchema, ui5Version);
    }
};
//# sourceMappingURL=export.js.map