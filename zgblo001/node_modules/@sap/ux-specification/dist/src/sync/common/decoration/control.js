"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
/**
 * General export rule, joining all given breadcrumbs to the base ID
 * @param baseId - base ID, first part of the stable ID
 * @param idBreadcrumbs - array of ID parts
 */
exports.buildControlIdFromParent = (baseId, idBreadcrumbs) => {
    return baseId + idBreadcrumbs.join('::');
};
/**
 * Export rule for pages
 * @param baseId - base ID, first part of the stable ID
 * @param idBreadcrumbs - array of ID parts
 * @param breadcrumbs - array of breadcrumbs
 */
exports.buildControlIdForPage = (baseId, idBreadcrumbs, breadcrumbs) => {
    return baseId + idBreadcrumbs.join('::') + breadcrumbs[0];
};
/**
 * Converts the section id to the right string for the stable id:
 * If the corresponsing facet has ID maintained, we must take this ID. If ID is not present, take the navigation path.
 * @param sectionId - old ID that shall get converted
 * @param breadcrumbs - array of breadcrumbs
 * @param title - title from JSON schema, comprising the facet ID
 */
exports.convertSectionId = (sectionId, title) => {
    let convertedSectionId;
    const prefix = types_1.FacetTitlePrefix;
    if (title !== undefined) {
        convertedSectionId = title.split(prefix)[1];
    }
    else {
        convertedSectionId = sectionId.replace(new RegExp('/@', 'g'), '::').replace(/@com.sap/g, 'com.sap');
    }
    return convertedSectionId;
};
function escapeId(sParam) {
    /* escape all characters not allowed in stable ids with :<hexcode>
     * as we use : as escape character, also escape :
     */
    return sParam.replace(/[^-A-Za-z0-9_.:]/g, function (c) {
        const sCode = c.charCodeAt(0).toString(16);
        return ':' + (sCode.length === 1 ? '0' : '') + sCode;
    });
}
exports.escapeId = escapeId;
/**
 * Export rule  for table columns
 * @param baseId - base ID, first part of the stable ID
 * @param idBreadcrumbs - array of ID parts
 * @param breadcrumbs - array of breadcrumbs
 * @param controlType - controlType function of ecorators, not used here
 * @param title - title from JSON schema, comprising the facet ID
 */
exports.buildColumnControlId = (baseId, idBreadcrumbs, breadcrumbs, controlType, title) => {
    let sectionId, tableId = 'listReport'; //default
    idBreadcrumbs = idBreadcrumbs.map(function (item) {
        if (item === 'sections') {
            for (let index = 0; index < breadcrumbs.length; index++) {
                const breadcrumb = breadcrumbs[index];
                if (breadcrumb === 'sections') {
                    sectionId = breadcrumbs[index + 1];
                    if (sectionId.indexOf('LineItem') !== -1) {
                        return (breadcrumbs[index + 1] = exports.convertSectionId(sectionId, title) + '::Table');
                    }
                }
            }
        }
        return item;
    });
    if (breadcrumbs[0] === 'sections') {
        tableId = breadcrumbs[1]
            .replace(/::com.sap.vocabularies/g, '/@com.sap.vocabularies')
            .replace(/::@com.sap.vocabularies/g, '/@com.sap.vocabularies');
    }
    const lastIdPart = breadcrumbs[breadcrumbs.length - 1]
        .replace(/::com.sap.vocabularies/g, '/@com.sap.vocabularies')
        .replace(/::@com.sap.vocabularies/g, '/@com.sap.vocabularies')
        .replace('sTarget/@', 'sTarget::@');
    let fullId;
    const splitPoint = lastIdPart.indexOf(':::');
    if (lastIdPart.startsWith('DataField') && splitPoint > -1) {
        fullId =
            baseId +
                'template:::TableColumn:::' +
                lastIdPart.substr(0, splitPoint) +
                ':::sSmartTableId::' +
                tableId.replace('::Table', ':3a:3aTable') +
                ':::' +
                lastIdPart.substr(splitPoint + 3);
    }
    else {
        fullId = baseId + idBreadcrumbs.join('::') + '-' + lastIdPart;
    }
    return escapeId(fullId);
};
exports.addPatternForBindingChangeOfEnum = (schema, definition, propertyName) => {
    const property = definition && definition['properties'];
    const originalDefinition = property[propertyName];
    let targetDefinition;
    let pattern = types_1.BindingPropertyRegexAsString;
    if (originalDefinition.$ref) {
        targetDefinition = schema['definitions'][originalDefinition.$ref.split('#/definitions/')[1]];
    }
    else {
        targetDefinition = originalDefinition;
    }
    const description = originalDefinition.description ? originalDefinition.description : targetDefinition.description;
    if (targetDefinition.enum) {
        let enumPattern;
        targetDefinition.enum.forEach((enumValue) => {
            if (!enumValue.toString().startsWith('{')) {
                enumPattern = enumPattern ? enumPattern + '|' + enumValue.toString() : enumValue.toString();
            }
        });
        pattern = '^(' + enumPattern + ')$|' + pattern;
    }
    property[propertyName] = {
        pattern: pattern,
        anyOf: [
            originalDefinition,
            {
                type: 'string'
            }
        ]
    };
    if (description) {
        property[propertyName].description = description;
        delete originalDefinition.description;
    }
};
//# sourceMappingURL=control.js.map