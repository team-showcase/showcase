"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const annotation_converter_1 = require("@sap-ux/annotation-converter");
const edmx_parser_1 = require("@sap-ux/edmx-parser");
const common_1 = require("../../specification/common");
const schemaAccess_1 = require("../../specification/schemaAccess");
const types_1 = require("./types");
var TemplateType;
(function (TemplateType) {
    TemplateType["ListReportObjectPageV2"] = "ListReportObjectPageV2";
    TemplateType["ListReportObjectPageV4"] = "ListReportObjectPageV4";
    TemplateType["OverviewPageV2"] = "OverviewPageV2";
    TemplateType["AnalyticalListPageV2"] = "AnalyticalListPageV2";
    TemplateType["AnalyticalListPageV4"] = "AnalyticalListPageV4";
})(TemplateType = exports.TemplateType || (exports.TemplateType = {}));
/**
 * Parses, merges, and converts a list of annotation files with aid of tools from annotation-vocabularies-tools
 * @param annotationFiles - The list of all annotation files, in JSON format
 * @returns the complete service information
 */
function parseAndMergeAndConvert(annotationFiles) {
    const parseResult = [];
    if (annotationFiles) {
        annotationFiles.forEach(function (annotationData) {
            parseResult.push(edmx_parser_1.parseEDMX(annotationData.fileContent, annotationData.dataSourceUri));
        });
    }
    if (parseResult.length === 0) {
        return;
    }
    return annotation_converter_1.convertTypes(edmx_parser_1.merge(parseResult));
}
exports.parseAndMergeAndConvert = parseAndMergeAndConvert;
exports.getAnnotationPropertyValue = (annotationProperty) => annotationProperty.value || annotationProperty.path;
/**
 * Return the page type for a given V2 page in manifest
 * @param name - page component name
 */
function getPageTypeV2(name) {
    if (name) {
        return name.split('sap.suite.ui.generic.template.')[1];
    }
}
exports.getPageTypeV2 = getPageTypeV2;
/**
 * Return the page type for a given V4 page in manifest
 * @param name - page component name
 */
function getPageTypeV4(name) {
    if (name) {
        return name.split('sap.fe.templates.')[1];
    }
}
exports.getPageTypeV4 = getPageTypeV4;
/**
 * Resolve page section(get key and label->description).
 * @param facetDefinition - the actual annotation record
 * @param keyForRelatedFacetKeys - construct key for 'keyForRelatedFacetKeys' property(used to define custom sections) - we should not add '@' symbol there.
 * @returns {FacetSection} - object comprising the relevant facet information
 */
function getSectionFacet(facetDefinition, keyForRelatedFacetKeys = false) {
    const entityName = facetDefinition.fullyQualifiedName.substr(facetDefinition.fullyQualifiedName.lastIndexOf('@'));
    //Take facet ID as fallback
    let key = facetDefinition.ID ? facetDefinition.ID.toString() : entityName;
    //If reference facet: overwrite with target annotation if present
    if (facetDefinition.$Type !== 'com.sap.vocabularies.UI.v1.CollectionFacet' && 'Target' in facetDefinition) {
        const propertyValue = exports.getAnnotationPropertyValue(facetDefinition.Target);
        const separator = '::';
        const navigationParts = propertyValue.split('/');
        const navigation = navigationParts.length > 1 ? navigationParts[0] : '';
        const uiParts = (navigationParts[1] || navigationParts[0]).split('#');
        const uiClass = uiParts[0];
        const qualifier = uiParts[1] || '';
        key = uiClass.replace('@UI', `${!keyForRelatedFacetKeys ? '@' : ''}com.sap.vocabularies.UI.v1`);
        if (navigation) {
            key = `${navigation}${separator}${key}`;
        }
        if (qualifier) {
            key = `${key}${separator}${qualifier}`;
        }
    }
    key = key.replace(/\//gi, '::');
    return key
        ? Object.assign(Object.assign({ key }, (facetDefinition.Label && { label: facetDefinition.Label.toString() })), (facetDefinition.ID && { ID: facetDefinition.ID.toString() })) : undefined;
}
exports.getSectionFacet = getSectionFacet;
exports.getManifestSectionByPathV4 = (exportResultManifest, path, targetAnnotation, targetAnnotationEncoded) => {
    let exportResultSection = exportResultManifest;
    path.split('/').forEach(function (element) {
        if (targetAnnotationEncoded && targetAnnotationEncoded === element) {
            element = targetAnnotation;
        }
        if (!exportResultSection[element]) {
            exportResultSection[element] = {};
        }
        exportResultSection = exportResultSection[element];
    });
    return exportResultSection;
};
/**
 * Finds the alias for a given namespace in the references' section of the converted service metadata
 * @param {string} namespace - complete namespace, e.g. 'com.sap.vocabularies.UI.v1'
 * @param {ConverterOutput} oDataServiceAVT - combined service metadata, as returned by annotation vocabularies tools
 * @returns alias for the given namespace
 */
function findAlias(namespace, oDataServiceAVT) {
    const aliasReference = oDataServiceAVT.references.find((reference) => {
        return reference.namespace === namespace;
    });
    return aliasReference && aliasReference.alias;
}
exports.findAlias = findAlias;
function getSchemaKeyOfLineItemRecord(lineItemRecord) {
    let schemaKey, target, value;
    switch (lineItemRecord.$Type) {
        case "com.sap.vocabularies.UI.v1.DataField" /* DataField */:
            schemaKey = exports.getAnnotationPropertyValue(lineItemRecord.Value);
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithUrl" /* DataFieldWithUrl */:
            schemaKey =
                typeof lineItemRecord.Value === 'string'
                    ? lineItemRecord.Value
                    : exports.getAnnotationPropertyValue(lineItemRecord.Value);
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* DataFieldForAnnotation */:
            target = lineItemRecord.Target.value;
            schemaKey =
                'DataFieldForAnnotation:::sTarget::' +
                    target
                        .replace('@UI', '@com.sap.vocabularies.UI.v1')
                        .replace('@Communication', '@com.sap.vocabularies.Communication.v1')
                        .replace('@Contact', '@com.sap.vocabularies.Contact.v1');
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */:
            if (lineItemRecord.Inline) {
                schemaKey = 'DataFieldForAction:::sAction::' + lineItemRecord.Action;
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation" /* DataFieldWithIntentBasedNavigation */:
            value = exports.getAnnotationPropertyValue(lineItemRecord.Value);
            schemaKey =
                'DataFieldWithIntentBasedNavigation:::sProperty::' +
                    value +
                    ':::sSemanticObject::' +
                    lineItemRecord.SemanticObject +
                    ':::sAction::' +
                    lineItemRecord.Action;
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */:
            if (lineItemRecord.Inline) {
                schemaKey =
                    'DataFieldForIntentBasedNavigation:::sSemanticObject::' +
                        lineItemRecord.SemanticObject +
                        ':::sAction::' +
                        lineItemRecord.Action;
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath" /* DataFieldWithNavigationPath */:
            value = exports.getAnnotationPropertyValue(lineItemRecord.Value);
            target = exports.getAnnotationPropertyValue(lineItemRecord.Target);
            schemaKey = 'DataFieldWithNavigationPath:::sProperty::' + value + ':::sTarget::' + target;
            break;
        default:
            break;
    }
    return schemaKey;
}
exports.getSchemaKeyOfLineItemRecord = getSchemaKeyOfLineItemRecord;
/**
 * Evaluates the target annotation of a reference facet and actualizes the facets for the config
 * @param {AnnotationTerm} annotationRecord - the actual annotation record
 * @param {FacetConfigs} facets - list of facets in config format, to be updated
 * @param {string} serviceName - name of the service of the app
 * @param {string} entityName - the entity (type) name
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 */
function evaluateTargetAnnotation(annotationRecord, facets, serviceName, entityName, oDataServiceAVT) {
    const section = getSectionFacet(annotationRecord);
    const path = section.key;
    const alias = findAlias('com.sap.vocabularies.UI.v1', oDataServiceAVT);
    if (path.includes('com.sap.vocabularies.UI.v1.Chart') || path.includes(alias + '.Chart')) {
        facets[path] = { base: 'ChartFacet' };
    }
    else if (path.includes('com.sap.vocabularies.UI.v1.LineItem') || path.includes(alias + '.LineItem')) {
        facets[path] = { base: 'LineItemFacet' };
        const entityType = oDataServiceAVT.entityTypes.find((e) => e.fullyQualifiedName === `${serviceName}.${entityName}`);
        if (entityType) {
            const navPath = path.substr(0, path.lastIndexOf('::'));
            const navProp = entityType.navigationProperties.find((n) => n.name === navPath);
            const targetEntity = navProp && navProp['targetType'].fullyQualifiedName;
            let scope, version, annotation;
            if (path.includes('com.sap.vocabularies.UI.v1.LineItem')) {
                [scope, version, annotation] = path.split('com.sap.vocabularies.')[1].split('.');
            }
            else if (path.includes(alias + '.LineItem')) {
                [scope, version, annotation] = path.split(alias + '.')[1].split('.');
            }
            const targetEntityType = oDataServiceAVT.entityTypes.find((et) => et.fullyQualifiedName === targetEntity);
            if (targetEntityType &&
                targetEntityType.annotations &&
                targetEntityType.annotations[scope] &&
                targetEntityType.annotations[scope][annotation]) {
                facets[path]['lineItem'] = targetEntityType.annotations[scope][annotation];
                facets[path]['entityType'] = targetEntityType;
            }
        }
    }
    else if (path.includes('com.sap.vocabularies.UI.v1.FieldGroup') || path.includes(alias + '.FieldGroup')) {
        facets[path] = { base: 'FormFacet' };
    }
    else {
        facets[path] = { base: '' };
    }
    if (annotationRecord.Label) {
        facets[path].Label = annotationRecord.Label;
    }
    // Add Facet ID
    if (annotationRecord.ID) {
        facets[path]['ID'] = annotationRecord.ID;
    }
}
/**
 * Adds the information from facets to the config
 * @param {AnnotationTerm} annotationRecord - the actual annotation record
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {string} serviceName - name of the service of the app
 * @param {string} entityName - the entity (type) name
 * @param {FacetConfigs} facets - list of facets in config format, to be updated
 */
function addFacetToConfig(annotationRecord, oDataServiceAVT, serviceName, entityName, facets) {
    switch (annotationRecord.$Type) {
        case "com.sap.vocabularies.UI.v1.ReferenceFacet" /* ReferenceFacet */: {
            evaluateTargetAnnotation(annotationRecord, facets, serviceName, entityName, oDataServiceAVT);
            break;
        }
        case "com.sap.vocabularies.UI.v1.CollectionFacet" /* CollectionFacet */: {
            const section = getSectionFacet(annotationRecord);
            const facet = (facets[section.key] = {
                base: 'CollectionFacet',
                facets: {}
            });
            annotationRecord.Facets.forEach((collectionItem) => {
                addFacetToConfig(collectionItem, oDataServiceAVT, serviceName, entityName, facet.facets);
            });
            break;
        }
    }
}
/**
 * Retrieve facet configurations that can be used to generate ObjectPage schemas
 * @param {QualifiedName} entityTypeName - the name of the actual entity type
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 */
function getObjectPageFacets(entityTypeName, oDataServiceAVT) {
    const facets = {};
    const entityType = oDataServiceAVT.entityTypes.find((et) => et.name === entityTypeName);
    if (!entityType || !entityType.annotations) {
        return;
    }
    const alias = findAlias('com.sap.vocabularies.UI.v1', oDataServiceAVT);
    const facetAnnotation = alias && entityType.annotations[alias] && entityType.annotations[alias].Facets;
    if (facetAnnotation) {
        const lastDot = entityType.fullyQualifiedName.lastIndexOf('.');
        const serviceName = entityType.fullyQualifiedName.substr(0, lastDot);
        // Add facets to configuration
        facetAnnotation.forEach((item) => {
            addFacetToConfig(item, oDataServiceAVT, serviceName, entityTypeName, facets);
        });
    }
    return facets;
}
exports.getObjectPageFacets = getObjectPageFacets;
/**
 * Returns the version of Fiori elements (v2/v4) from a given manifest
 * @param manifest - the manifest.json file
 */
function getVersionFromManifest(manifest) {
    if (manifest['sap.ui.generic.app'] || manifest['sap.ovp']) {
        return common_1.FioriElementsVersion.v2;
    }
    else {
        return common_1.FioriElementsVersion.v4;
    }
}
exports.getVersionFromManifest = getVersionFromManifest;
function getTemplateTypeFromManifest(manifest) {
    let templateType;
    if (manifest['sap.ovp']) {
        templateType = TemplateType.OverviewPageV2;
    }
    else if (manifest['sap.ui.generic.app']) {
        const v2Pages = manifest['sap.ui.generic.app'].pages;
        if (!v2Pages) {
            return;
        }
        templateType = TemplateType.ListReportObjectPageV2;
        for (const pageKey in v2Pages) {
            const v2Page = v2Pages[pageKey];
            if (getPageTypeV2(v2Page.component.name) === common_1.PageType.AnalyticalListPage) {
                templateType = TemplateType.AnalyticalListPageV2;
                break;
            }
        }
    }
    else if (manifest['sap.ui5'].routing.targets) {
        const v4Pages = manifest['sap.ui5'].routing.targets;
        templateType = TemplateType.ListReportObjectPageV4;
        for (const pageKey in v4Pages) {
            const v4Page = v4Pages[pageKey];
            if (getPageTypeV4(v4Page.name) === common_1.PageType.AnalyticalListPage) {
                templateType = TemplateType.AnalyticalListPageV4;
                break;
            }
        }
    }
    return templateType;
}
exports.getTemplateTypeFromManifest = getTemplateTypeFromManifest;
/**
 * Creates a default object for a new section or subsection, and adds the ID as title if present.
 * @param facet Facet configuration, to be analyzed
 * @returns the new section object
 */
function createSectionWithoutProperties(facet) {
    const section = {
        type: 'object',
        properties: {},
        additionalProperties: false
    };
    if (facet && facet.ID) {
        section['title'] = facet.ID;
    }
    return section;
}
exports.createSectionWithoutProperties = createSectionWithoutProperties;
/**
 * Retrieve page section data(so far id/key and label/description).
 * @param {QualifiedName} entityTypeName The actual entitySet (corresponds to the given page)
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 */
function getObjectPageFacetSection(entityTypeName, oDataServiceAVT) {
    const entityType = oDataServiceAVT.entityTypes.find((et) => et.name === entityTypeName);
    const alias = findAlias('com.sap.vocabularies.UI.v1', oDataServiceAVT);
    if (entityType) {
        const facetAnnotation = alias && entityType.annotations && entityType.annotations[alias] && entityType.annotations[alias].Facets;
        if (!facetAnnotation) {
            return [];
        }
        return facetAnnotation.reduce(function (result, item) {
            const section = getSectionFacet(item, true);
            if (section) {
                result.push(section);
            }
            return result;
        }, []);
    }
}
exports.getObjectPageFacetSection = getObjectPageFacetSection;
/**
 * Cleans empty sub-structures from the export result for manifest
 * @param manifest - manifest.json part of the export result
 * @param path  - path in the manifest
 * @param targetAnnotation - target annotation (optional, in case of sections, subsections)
 * @param targetAnnotationEncoded - encoded version of the target annotation, as represented in the manifest
 */
exports.deleteEmptyStructure = (manifest, path, targetAnnotation, targetAnnotationEncoded) => {
    let manifestSection = manifest;
    path.split('/').forEach(function (element) {
        if (element === targetAnnotationEncoded) {
            element = targetAnnotation;
        }
        if (!manifestSection[element]) {
            return;
        }
        if (Object.keys(manifestSection[element]).length === 0) {
            delete manifestSection[element];
            return;
        }
        manifestSection = manifestSection && manifestSection[element];
    });
};
/**
 * Method which returns generic schema file name.
 * @param {SchemaType | PageType} schemaType Schema type or Page type.
 * @return {string} File name of generic schema.
 */
const getGenericSchemaFileName = (schemaType) => {
    return `${schemaType}`;
};
/**
 * Method which returns schema file name and path depending on passed schema or page type.
 * @param {SchemaType | PageType} schemaType Schema type or Page type.
 * @param {string} [entitySet] Entity set string.
 * @return {SchemaFilePath} File path info.
 */
exports.getSchemaFilePath = (schemaType, entitySet) => {
    const schemaFile = {
        filename: '',
        path: ''
    };
    switch (schemaType) {
        // Application schema
        case schemaAccess_1.SchemaType.Application: {
            // File name
            schemaFile.filename = `App`;
            // Full path
            schemaFile.path = `./${types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
        // List report and object page
        case schemaAccess_1.SchemaType.ListReport:
        case schemaAccess_1.SchemaType.ObjectPage: {
            // File name
            schemaFile.filename = entitySet ? `${schemaType}_${entitySet}` : getGenericSchemaFileName(schemaType);
            // Full path
            schemaFile.path = `../${types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
        // Other page configs
        default: {
            // File name
            schemaFile.filename = getGenericSchemaFileName(schemaType);
            // Full path
            schemaFile.path = `../${types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
    }
    schemaFile.path += '.json';
    return schemaFile;
};
/**
 * Method which generates id of page according to passed parameters.
 * @param appVersion - Fiori Elements version - V2 or V4.
 * @param pageType - Page type.
 * @param entitySet - Entity Set.
 * @param navigationProperty - Navigation property (optional).
 * @param viewId - Custom page's viewId (optional).
 * @returns {string} Generated page id
 */
function generatePageId(appVersion, pageType, entitySet, navigationProperty, viewId) {
    let parts = [];
    if (appVersion === common_1.FioriElementsVersion.v2) {
        // Page generation for V2 page
        parts.push(pageType);
        if (entitySet) {
            parts.push(entitySet);
        }
        // Page navigation - Optional
        if (navigationProperty) {
            parts.push(navigationProperty);
        }
    }
    else {
        // Page generation for V4 page
        let name = '';
        // Populate with page entity or name
        if (pageType === common_1.PageType.CustomPage) {
            const names = viewId.split('.');
            name = names[names.length - 1];
        }
        else {
            name = entitySet;
        }
        // Populate with page type prefix
        const pageTypeMap = new Map([
            [common_1.PageType.ListReport, 'List'],
            [common_1.PageType.ObjectPage, common_1.PageType.ObjectPage],
            [common_1.PageType.CustomPage, 'Page'],
            [common_1.PageType.ObjectPage, common_1.PageType.ObjectPage]
        ]);
        name += pageTypeMap.get(pageType);
        // Use standard separator for further parts
        parts = [name];
        if (navigationProperty) {
            parts.push(navigationProperty);
        }
    }
    return parts.join('_');
}
exports.generatePageId = generatePageId;
//# sourceMappingURL=utils.js.map