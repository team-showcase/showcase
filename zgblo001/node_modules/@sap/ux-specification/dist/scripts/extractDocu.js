"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This script extracts all existing documentation (i.e. descriptions) from the generic schemas of a certain OData version (V2 or V4).
 * All descriptions are collected in an Excel sheet that you afterwards can find under dist/documentation: it is named Specificationv2.xslx or Specificationv4.xslx, depending on the chosen version.
 * You can find one worksheet for each generic schema file.
 *
 * The script expects that you supply an argument --version with either v2 or v4.
 * You can also start it from one of the debugger scripts named in launch.json: "Extract V2 documentation" or "Extract V4 documentation".
 */
const page_1 = require("../src/specification/common/page");
const path_1 = require("path");
const fs = __importStar(require("fs"));
const excel = __importStar(require("excel4node"));
/**
 * Handles reference ($ref) within the schema, finds the corresponding definition
 * @param schema - Object representing the whole generic schema
 * @param reference - Content for the $ref property
 * @param output - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv like)
 * @param definition - The current hierarchy element (list of path parts separated by ';')
 */
function dereference(schema, reference, output, definition, description) {
    const currentDefinition = reference.split('#/definitions/')[1];
    try {
        parseSchema(schema, schema['definitions'][currentDefinition], output, definition, description);
    }
    catch (error) {
        console.log(error);
    }
}
/**
 * Handles one property of a sub-schema
 * @param schema - Object representing the whole generic schema
 * @param subSchema - Object representing the current sub-structure of the schema
 * @param property - Name of the property ithin the subSchema
 * @param output  - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv like)
 * @param definition - The current hierarchy element (list of path parts separated by ';')
 */
function processElement(schema, subSchema, property, output, definition) {
    if (['$schema', 'id', 'pages', 'home', '2', '3', '4', '5', '6', '7', '8', '9'].includes(property)) {
        return;
    }
    const element = subSchema[property];
    definition = definition ? definition + ';' + property : property;
    if (property === 'columns') {
        definition = definition + ';columnId';
    }
    if (property === 'sections') {
        definition = definition + ';sectionId';
    }
    if (property === 'cards') {
        definition = definition + ';cardKey';
    }
    if (element['description'] !== undefined) {
        if (element['$ref'] !== undefined) {
            dereference(schema, element['$ref'], output, definition, element['description']);
            return;
        }
        else if (element['anyOf'] !== undefined) {
            handleAnyOf(schema, element['anyOf'], output, definition, element['description']);
            return;
        }
    }
    if (element['description'] !== undefined && element['type'] !== undefined && element['items']) {
        const reference = element['items']['$ref'] || (element['items'][0] && element['items'][0]['$ref']);
        if (reference) {
            dereference(schema, reference, output, definition, element['description']);
        }
        else {
            output.push(definition + ';' + `TYPE_${element['type']}` + ';' + element['description']);
        }
        return;
    }
    if (element['description'] !== undefined && element['type'] !== undefined) {
        output.push(definition + ';' + `TYPE_${element['type']}` + ';' + element['description']);
    }
    // Temporary as Description is not maintained for some properties - description should be added
    if (!element['description'] && element['type'] !== undefined) {
        output.push(definition + ';' + `TYPE_${element['type']}`);
    }
    if (element['$ref'] !== undefined) {
        dereference(schema, element['$ref'], output, definition);
    }
    else {
        parseSchema(schema, element, output, definition);
    }
}
/**
 * Special handing of anyOf elements of a JSON schema
 * @param schema - Object representing the whole generic schema
 * @param anyOfSchema - Object representing the current sub-structure of the schema
 * @param output - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv like)
 * @param definition - The current hierarchy element (list of path parts separated by ';')
 */
function handleAnyOf(schema, anyOfSchema, output, definition, description) {
    for (let index = 0; index < anyOfSchema.length; index++) {
        const element = anyOfSchema[index];
        if (Object.keys(element)[0] === '$ref') {
            dereference(schema, element['$ref'], output, definition);
        }
        else {
            parseSchema(schema, element, output, definition, description);
        }
    }
}
/**
 * Parses a sub-structure of the schema
 * @param schema - Object representing the whole generic schema
 * @param subSchema - Object representing the current sub-structure of the schema
 * @param output - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv like)
 * @param definition - The current hierarchy element (list of path parts separated by ';')
 */
function parseSchema(schema, subSchema, output, definition, description) {
    if (Object.keys(subSchema) && Object.keys(subSchema)[0] === 'anyOf') {
        handleAnyOf(schema, subSchema['anyOf'], output, definition);
        return;
    }
    for (const property in subSchema['properties']) {
        if (property === '$ref') {
            dereference(schema, subSchema['properties']['$ref'], output, definition);
        }
        else if (property === 'anyOf') {
            handleAnyOf(schema, subSchema['properties']['anyOf'], output, definition);
        }
        else {
            processElement(schema, subSchema['properties'], property, output, definition);
        }
    }
    for (const property in subSchema['additionalProperties']) {
        if (property === '$ref') {
            dereference(schema, subSchema['additionalProperties']['$ref'], output, definition);
        }
        else if (property === 'anyOf') {
            handleAnyOf(schema, subSchema['additionalProperties']['anyOf'], output, definition);
        }
        else {
            processElement(schema, subSchema['additionalProperties'], property, output, definition);
        }
    }
    if (subSchema['enum'] && description) {
        output.push(definition + ';' + `TYPE_${[subSchema['enum'].join('|')]}` + ';' + description);
    }
    else if (subSchema['type'] && description) {
        output.push(definition + ';' + `TYPE_${subSchema['type']}` + ';' + description);
    }
}
/**
 * Fills an excel4node workbook based on csv like information
 * @param workbook - Excel workbook (excel4node format)
 * @param output - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv like)
 * @param file - file name of the original schema
 */
function writeToExcel(workbook, output, file) {
    const sheetName = file.split('.')[0];
    const worksheet = workbook.addWorksheet(sheetName);
    worksheet.headerFooter = { evenHeader: output[0] };
    // Create a reusable style
    const style = workbook.createStyle({
        font: {
            //color: '#800000',
            size: 12
        },
        numberFormat: '$#,##0.00; ($#,##0.00); -'
    });
    for (let rowIndex = 1; rowIndex < output.length; rowIndex++) {
        const element = output[rowIndex];
        const cellArray = element.split(';');
        for (let cellIndex = 0; cellIndex < cellArray.length; cellIndex++) {
            const cell = cellArray[cellIndex];
            worksheet
                .cell(rowIndex, cellIndex + 1)
                .string(cell)
                .style(style);
        }
    }
}
function generateIxiaSoftFormat(output, file, version) {
    let iXiaFormat = `<simpletable frame="all" relcolwidth="1* 1*" id="simpletable_uqj_klr_jlb">
        <sthead>
            <stentry> Settings </stentry>
            <stentry> Description </stentry>
        </sthead>
    `;
    const fileName = file.split('.')[0];
    for (let rowIndex = 1; rowIndex < output.length; rowIndex++) {
        const element = output[rowIndex];
        const cellArray = element.split(';');
        let setting = '{';
        iXiaFormat = iXiaFormat + `\t<strow>\n`;
        for (let cellIndex = 0; cellIndex < cellArray.length - 1; cellIndex++) {
            let cell = cellArray[cellIndex];
            if (['0', '1'].includes(cell)) {
                cell = 'variantKey' + cell;
            }
            if (cellArray[cellIndex + 1].includes('TYPE')) {
                setting = setting + `"${cell}": ${cellArray[cellIndex + 1].split('_')[1]}`;
                let noOfOpeningBraces = setting.match(/{/g).length;
                while (noOfOpeningBraces > 0) {
                    setting = setting + '}';
                    noOfOpeningBraces--;
                }
                iXiaFormat = iXiaFormat + `\t\t<stentry> ${setting} </stentry>\n`;
            }
            else {
                setting = setting + `"${cell}": {`;
            }
        }
        // add description to the table
        iXiaFormat = iXiaFormat + `\t\t<stentry> ${cellArray[cellArray.length - 1]} </stentry>\n\t</strow>\n`;
    }
    iXiaFormat = iXiaFormat + `</simpletable>`;
    const outDir = path_1.join('dist', 'documentation');
    if (!fs.existsSync(outDir)) {
        fs.mkdirSync(outDir);
    }
    const outFile = path_1.join(outDir, 'Specification' + version + fileName + '.txt');
    fs.writeFile(outFile, iXiaFormat, (err) => {
        if (err)
            throw err;
        console.log(`${outFile} was succesfully saved!`);
    });
}
/**
 * Writes an Excel workbook to a file in the dist/documentation folder.
 * @param workbook - Excel workbook (excel4node format)
 * @param version - OData version
 */
function writeToFile(workbook, version) {
    const outDir = path_1.join('dist', 'documentation');
    if (!fs.existsSync(outDir)) {
        fs.mkdirSync(outDir);
    }
    const outFile = path_1.join(outDir, 'Specification' + version + '.xlsx');
    workbook.write(outFile);
}
/********************** Main ***************************/
function generateDocmentation() {
    const myArgs = process.argv.slice(2);
    let version;
    let format;
    myArgs.forEach((arg) => {
        const value = arg.split('=')[1];
        if (arg.includes('version')) {
            version = value;
        }
        else if (arg.includes('format')) {
            format = value;
        }
    });
    let directoryPath = '';
    switch (version) {
        case page_1.FioriElementsVersion.v2:
            directoryPath = path_1.join('schemas', 'v2');
            break;
        case page_1.FioriElementsVersion.v4:
            directoryPath = path_1.join('schemas', 'v4');
            break;
        default:
            console.log('Invalid version ' + version + '; processing stopped.');
            break;
    }
    if (directoryPath.length > 0) {
        const workbook = new excel.Workbook();
        fs.readdir(directoryPath, function (err, files) {
            if (err) {
                return console.log(err);
            }
            files.forEach((file) => {
                const filePath = path_1.join(directoryPath, file);
                const output = [filePath];
                const data = fs.readFileSync(filePath, 'utf8');
                const schema = JSON.parse(data);
                parseSchema(schema, schema, output);
                //console.log(output);
                if (format === 'excel') {
                    writeToExcel(workbook, output, file);
                }
                if (format === 'iXiaSoft') {
                    generateIxiaSoftFormat(output, file, version);
                }
            });
            if (format === 'excel') {
                writeToFile(workbook, version);
            }
        });
    }
}
generateDocmentation();
//# sourceMappingURL=extractDocu.js.map