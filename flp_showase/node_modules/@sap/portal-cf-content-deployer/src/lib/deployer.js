'use strict';
const
    xsenv = require('@sap/xsenv'),
    utils = require('../lib/utils'),
    jszip = require('jszip'),
    fs = require('fs'),
    axios = require('axios'),
    glob = require('glob'),
    FormData = require('form-data'),
    rimraf = require('rimraf'),
    path = require('path'),
    url = require('url'),
    TIMEOUT = 300000;

/*
    Create Archive from files within site folder (design time site and i18n translations)
    receive structure:
    - portal-site
          CommonDataModel.json
          - i18n
               *.properties

     create zip file structure:
     - site
        CommonDataModel.json
        i18n/
            *.properties

     */
function getArchiveStream() {
    return new Promise((resolve, reject) => {
            try {
                let buildDirectory = path.normalize(process.cwd() + '/deploymentTemp');
                if (!fs.existsSync(buildDirectory)) {
                    if (!fs.existsSync(buildDirectory)) {
                        fs.mkdirSync(buildDirectory);
                    }
                    let zip = new jszip();
                    let options = {cwd: process.cwd()};

                    // Matches only *.json or *.properties inside folder "portal-site", "portal-site\i18n" and "portal-site\business-apps"
                    let cdmPath = `${path.sep}CommonDataModel.json`;
                    let translationFilesPath = `${path.sep}i18n${path.sep}*.properties`;
                    let businessAppFilesPath = `${path.sep}business-apps${path.sep}*.json`;

                    let pattern = `portal-site{${cdmPath},${translationFilesPath},${businessAppFilesPath}}`;

                    glob(pattern, options, (err, files) => {
                        files.forEach((filePath) => {
                            let fileData = fs.readFileSync(filePath);

                            //getting folder name 'portal-site', need to generate folder 'site'
                            filePath = filePath.substring('portal-'.length);
                            zip.file(filePath, fileData);
                        });
                        resolve(zip.generateNodeStream());
                    });
                }
            } catch
                (err) {
                console.error('flp-ct-content-deployer failed creating zip file before sending to portal service: ', err.message);
                reject(err)
            }
        }
    );
}

function deleteArchive() {
    return new Promise((resolve, reject) => {
        try {
            let buildDirectory = path.normalize(process.cwd() + '/deploymentTemp');
            rimraf(buildDirectory, (err) => {
                if (err) {
                    console.error('Failed to delete temporary archive folder: ', err.message);
                    return reject(err);
                }
                console.log('deleteArchive: deploymentTemp folder was deleted successfully');
                return resolve();
            });
        } catch (err) {
            return reject(err);
        }
    });
}

/*
    Fetch the apphostIds from bounded services.
    Deployer is bound to html5-repo deployer instance and to the business services
*/
function fetchAppHostIdsXsAppNameServicesMap() {
    return new Promise((resolve) => {
        let result = {
            appHostIds:
                {
                    'appHostIds': [],
                    'boundAppHostIds': []
                },
            xsAppNameServicesMap: {}
        };

        //extract main app_host_id --> deployer is bound to html5-repo deployer instance
        try {
            let serviceCredentials = xsenv.filterCFServices({tag: 'html5-apps-repo-dt'});
            for (let i = 0; i < serviceCredentials.length; i++) {
                let credentials = serviceCredentials[i].credentials;
                if (credentials && credentials['app_host_id']) {
                    let appHostIds = credentials['app_host_id'];
                    //support for multiple app_host_ids
                    if (appHostIds) {
                        for (let appHostId of appHostIds.split(',')) {
                            result.appHostIds.appHostIds.push(appHostId.trim());
                        }
                    }
                }
            }
        } catch (err) {
            console.error('fetchAppHostIdsXsAppNameServicesMap - main app_host_id exception was thrown: ', err.message);
        }

        //extract main uaa xsappname for xsAppNameServicesMap -> com.sap.portal.no.business.service
        try {
            let serviceCredentials = xsenv.cfServiceCredentials({tag: 'xsuaa'});
            if (serviceCredentials && serviceCredentials.xsappname) {
                result.xsAppNameServicesMap['com.sap.portal.no.business.service'] = serviceCredentials.xsappname;
            }
        } catch (err) {
            console.error('fetchAppHostIdsXsAppNameServicesMap - main uaa xsappname exception was thrown: ', err.message);
        }

        //extract app_host_id's, sap.cloud.service & xsaapname of business services
        try {
            let services = xsenv.readCFServices();
            for (let serviceName of Object.keys(services)) {
                //skip the portal service itself
                let service = services[serviceName];
                if (!service.tags || !service.tags.includes('portal-service')) {
                    let credentials = service.credentials;
                    if (credentials && credentials['html5-apps-repo'] && credentials['html5-apps-repo']['app_host_id']) {
                        let boundAppHostIds = credentials['html5-apps-repo']['app_host_id'];
                        //support for multiple app_host_ids
                        if (boundAppHostIds) {
                            for (let boundAppHostId of boundAppHostIds.split(',')) {
                                result.appHostIds.boundAppHostIds.push(boundAppHostId.trim());
                            }
                        }
                    }
                    //add business service xsappname
                    if (credentials['sap.cloud.service'] && credentials.uaa && credentials.uaa.xsappname) {
                        result.xsAppNameServicesMap[credentials['sap.cloud.service']] = credentials.uaa.xsappname;
                    }
                }
            }
        } catch (err) {
            console.error('fetchAppHostIdsXsAppNameServicesMap - app_host_ids, sap.cloud.service & xsaapname of business services exception was thrown: ', err.message);
        }
        resolve(result);
    });
}

function fetchBlueBoxMetadata() {
    return new Promise(async (resolve) => {
        let result;
        let tenantHostPattern = process.env.TENANT_HOST_PATTERN;
        if (tenantHostPattern) {
            try {

                // extract main uaa xsappname
                let serviceCredentials = xsenv.cfServiceCredentials({tag: 'xsuaa'});

                // extract SaaS registry metadata
                let saasServiceCredentials = xsenv.cfServiceCredentials({tag: 'SaaS'});
                if (saasServiceCredentials && serviceCredentials) {

                    // Extract app-router url
                    let appRouterUrl, appUrls = saasServiceCredentials.appUrls;
                    if (appUrls) {
                        appUrls = JSON.parse(saasServiceCredentials.appUrls);
                        appRouterUrl = url.parse(appUrls.getDependencies).hostname;
                    }

                    // prepare payload
                    result = {
                        providerType: 'cf',
                        data: {
                            id: saasServiceCredentials.appName,
                            deprecatedId: saasServiceCredentials.xsappname && saasServiceCredentials.xsappname.replace(/(!|\|.*)/g, ""),
                            xsappname: serviceCredentials.xsappname,
                            url: appRouterUrl,
                            tenantHostPattern: tenantHostPattern,
                            category: saasServiceCredentials.category || '',
                            translations: [{
                                locale: '',
                                textDictionary: {
                                    title: saasServiceCredentials.display_name || saasServiceCredentials.appName || '',
                                    description: saasServiceCredentials.description || ''
                                }
                            }]
                        }
                    };
                }
            } catch (err) {
                console.error('fetchBlueBoxMetadata - exception was thrown: ', err.message);
            }
        }

        resolve(result);
    });
}

//Send the zip file and the app_host_ids for deployment to the Portal service
async function portalServiceDeploy(archiveStream, appHostIdsXsAppNameServicesMap, blueBoxMetadata, token) {
    try {
        console.log('portalServiceDeploy sending archive with appHostIdsXsAppNameServicesMap= ' + JSON.stringify(appHostIdsXsAppNameServicesMap));
        if (blueBoxMetadata) {
            console.log('portalServiceDeploy sending archive with blueBoxMetadata= ' + JSON.stringify(blueBoxMetadata));
        }
        let portalService = xsenv.cfServiceCredentials({tag: 'portal-service'});
        let portalURL = portalService.endpoints['portal-service'];
        let dtsImportURL = `${portalURL}/dts/api/v1/transport/import`;

        let formData = new FormData();
        formData.append('site', archiveStream, {
            filename: 'site.zip',
            contentType: 'multipart/form-data'
        });
        formData.append('appHostIds', JSON.stringify(appHostIdsXsAppNameServicesMap.appHostIds));
        formData.append('xsAppNameServicesMap', JSON.stringify(appHostIdsXsAppNameServicesMap.xsAppNameServicesMap));
        if (blueBoxMetadata) {
            formData.append('blueBoxMetadata', JSON.stringify(blueBoxMetadata));
        }
        let headers = formData.getHeaders();
        headers.Authorization = 'Bearer ' + token;
        let requestOptions = {
            headers: headers,
            timeout: TIMEOUT
        };

        console.time("Deploy site elapsed time");
        let response = await axios.post(dtsImportURL, formData, requestOptions);
        console.timeEnd("Deploy site elapsed time");
        if (response) {
            //response success in range of 2xx
            let data = JSON.stringify(response.data);
            console.log(`Portal service deploy success. status = ${response.status}, data: ${data}`);
            return data;
        } else {
            throw new Error('Deploy to portal service failed, Portal service response is undefined');
        }
    } catch (err) {
        console.timeEnd("Deploy site elapsed time");
        let errorMessage = "";
        if (err.response) {
            // The request was made and the server responded with a status code that falls out of the range of 2xx
            errorMessage = 'Deploy to portal service failed, got status = ' + err.response.status + ', data: ' + err.response.data;
        } else if (err.request) {
            // The request was made but no response was received
            errorMessage = 'Deploy to portal service failed, No response received from portal service, error = ' + err.message;
        } else {
            // Something happened in setting up the request that triggered an Error
            errorMessage = 'Deploy to portal service failed, error while setting up request to portal service, error = ' + err.message;
        }
        throw new Error(errorMessage);
    }
}

class DeployUtils {
    /*
    Start the deployment process:
    1. Create archive Zip
    2. Fetch app host ids
    3. Fetch BlueBox metadata for register provider
    4. Fetch technical user token
    5. Send them to the portal service with technical user jwt token
    6. Delete deployment temp folder
     */
    static async deploy() {
        let results, deployResult;
        try {
            let deployPromises = [];
            deployPromises.push(getArchiveStream());
            deployPromises.push(fetchAppHostIdsXsAppNameServicesMap());
            deployPromises.push(fetchBlueBoxMetadata());
            deployPromises.push(utils.getTechnicalUserToken());
            results = await Promise.all(deployPromises);
            deployResult = await portalServiceDeploy(...results);
            if (deployResult) {
                return deployResult;
            } else {
                throw new Error('Portal service deploy failed with empty result');
            }
        } catch (err) {
            throw new Error(err);
        } finally {
            try {
                await deleteArchive(); //Delete created archive
            } catch (err) {
                console.error('Failed to delete deployment temp folder: ', err.message);
            }
        }
    }
}

module.exports = DeployUtils;
